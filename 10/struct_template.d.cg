import object;
struct DataStructure(T)
{
	T[] data;
}
void main()
{
	import std.stdio;
	DataStructure!int ds = 0;
	ds.data = [1, 2, 3, 4, 5, 6];
	writeln(ds.data);
	return 0;
}
mixin _d_cmain!();
{
	extern (C) 
	{
		extern (C) int _d_run_main(int argc, char** argv, void* mainFunc);
		extern (C) int _Dmain(char[][] args);
		extern (C) int main(int argc, char** argv)
		{
			return _d_run_main(argc, argv, & _Dmain);
		}
		version (Solaris)
		{
			extern (C) int _main(int argc, char** argv)
			{
				return main(argc, argv);
			}
		}
	}
}
DataStructure!int
{
	struct DataStructure
	{
		int[] data;
	}

}
RTInfo!(DataStructure!int)
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
NoPointersBitmapPayload!1LU
{
	enum ulong[1] NoPointersBitmapPayload = [0LU];

}
RTInfoImpl!([16LU, 2LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [16LU, 2LU];

}
__equals!(int, int)
{
	pure nothrow @nogc @trusted bool __equals(scope const(int[]) lhs, scope const(int[]) rhs)
	{
		const const(ulong) length = lhs.length;
		if (__ctfe)
			return length == rhs.length && isEqual(cast(const(int)*)lhs, cast(const(int)*)rhs, length);
		else
		{
			import core.stdc.string : memcmp;
			return length == rhs.length && (!length || 0 == memcmp(cast(const(void*))cast(const(int)*)lhs, cast(const(void*))cast(const(int)*)rhs, length * 4LU));
		}
	}

}
isEqual!(int, int)
{
	pure nothrow @nogc @system bool isEqual(scope const(int*) t1, scope const(int*) t2, ulong length)
	{
		{
			ulong __key40 = 0LU;
			ulong __limit41 = length;
			for (; __key40 < __limit41; __key40 += 1LU)
			{
				const const(ulong) i = __key40;
				if (t1[i] != t2[i])
					return false;
			}
		}
		return true;
	}

}
static __gshared TypeInfo_Const _D12TypeInfo_xAi6__initZ;
writeln!(int[])
{
	@safe void writeln(int[] _param_0)
	{
		(trustedStdout()).write(_param_0, '\n');
	}

}
write!(int[], char)
{
	@safe void write(int[] _param_0, char _param_1)
	{
		import std.traits : isBoolean, isIntegral, isAggregateType;
		import std.utf : UTFException;
		LockingTextWriter w = this.lockingTextWriter();
		try
		{
			/*unrolled*/ {
				{
					int[] arg = _param_0;
					try
					{
						alias A = int[];
						import std.format.write : formattedWrite;
						formattedWrite(w, "%s", arg);
					}
					catch(UTFException e)
					{
						w.highSurrogate = '\0';
						throw e;
					}
				}
				{
					char arg = _param_1;
					try
					{
						alias A = char;
						put(w, arg);
					}
					catch(UTFException e)
					{
						w.highSurrogate = '\0';
						throw e;
					}
				}
			}
		}
		finally
			w.~this();
	}

}
isAggregateType!(int[])
{
	enum bool isAggregateType = false;

}
isSomeString!(int[])
{
	enum bool isSomeString = false;

}
isIntegral!(int[])
{
	enum bool isIntegral = false;

}
isBoolean!(int[])
{
	enum bool isBoolean = false;

}
isSomeChar!(int[])
{
	enum bool isSomeChar = false;

}
formattedWrite!(LockingTextWriter, char, int[])
{
	@safe uint formattedWrite(ref LockingTextWriter w, scope const(char[]) fmt, int[] _param_2)
	{
		import std.conv : text;
		import std.format : enforceFmt, FormatException;
		import std.traits : isSomeChar;
		FormatSpec!char spec = spec = FormatSpec , spec.this(fmt);
		uint currentArg = 0u;
		for (; spec.writeUpToNextSpec(w);)
		{
			{
				if (cast(ulong)currentArg == 1LU && !spec.indexStart)
				{
					enforce(fmt.length == 0LU, delegate const(char)[]() pure nothrow @nogc @safe => text("Orphan format specifier: %", spec.spec), "/usr/include/dmd/phobos/std/format/write.d", 542LU);
					break;
				}
				if (spec.width == 2147483647)
				{
					int width = getNthInt(currentArg, _param_2);
					if (width < 0)
					{
						spec.flDash(true);
						width = -width;
					}
					spec.width = width;
					currentArg += 1u;
				}
				else if (spec.width < 0)
				{
					uint index = cast(uint)-spec.width;
					assert(index > 0u, "The index must be greater than zero");
					int width = getNthInt(index - 1u, _param_2);
					if (currentArg < index)
						currentArg = index;
					if (width < 0)
					{
						spec.flDash(true);
						width = -width;
					}
					spec.width = width;
				}
				if (spec.precision == 2147483647)
				{
					int precision = getNthInt(currentArg, _param_2);
					if (precision >= 0)
						spec.precision = precision;
					else
						spec.precision = 2147483646;
					currentArg += 1u;
				}
				else if (spec.precision < 0)
				{
					uint index = cast(uint)-spec.precision;
					assert(index > 0u, "The precision must be greater than zero");
					int precision = getNthInt(index - 1u, _param_2);
					if (currentArg < index)
						currentArg = index;
					if (precision >= 0)
						spec.precision = precision;
					else
						spec.precision = 2147483646;
				}
				if (spec.separators == 2147483647)
				{
					int separators = getNthInt(currentArg, _param_2);
					spec.separators = separators;
					currentArg += 1u;
				}
				if (spec.dynamicSeparatorChar)
				{
					dchar separatorChar = getNth(currentArg, _param_2);
					spec.separatorChar = separatorChar;
					spec.dynamicSeparatorChar = false;
					currentArg += 1u;
				}
				if (cast(ulong)currentArg == 1LU && !spec.indexStart)
				{
					enforce(fmt.length == 0LU, delegate const(char)[]() pure nothrow @nogc @safe => text("Orphan format specifier: %", spec.spec), "/usr/include/dmd/phobos/std/format/write.d", 612LU);
					break;
				}
				ulong index = cast(ulong)currentArg;
				if (cast(int)spec.indexStart != 0)
					index = cast(ulong)(cast(int)spec.indexStart - 1);
				else
					currentArg += 1u;
				SWITCH:
				switch (index)
				{
					/*unrolled*/ {
						{
							enum ulong i = 0LU;
							alias Tunused = int[];
							case 0LU:
							{
								formatValue(w, _param_2, spec);
								if (currentArg < cast(uint)cast(int)spec.indexEnd)
									currentArg = cast(uint)spec.indexEnd;
								if (1LU < cast(ulong)cast(int)spec.indexEnd)
								{
									goto default;
								}
								else
									break SWITCH;
							}
						}
					}
					default:
					{
						throw new FormatException(text("Positional specifier %", spec.indexStart, '$', spec.spec, " index exceeds ", 1LU), "/usr/include/dmd/phobos/std/format/write.d", 651LU, null);
					}
				}
			}
		}
		return currentArg;
	}

}
Unqual!(char, char)
{
	alias Unqual = char;

}
FormatSpec!char
{
	struct FormatSpec
	{
		import std.algorithm.searching : startsWith;
		import std.ascii : isDigit;
		import std.conv : parse, text, to;
		import std.range.primitives;
		int width = 0;
		int precision = 2147483646;
		int separators = 2147483646;
		bool dynamicSeparatorChar = false;
		deprecated("separatorCharPos will be removed in 2.107.0. Please use dynamicSeparatorChar instead.") deprecated deprecated pure nothrow @nogc @safe int separatorCharPos()
		{
			return this.dynamicSeparatorChar ? 2147483647 : 2147483646;
		}
		deprecated("separatorCharPos will be removed in 2.107.0. Please use dynamicSeparatorChar instead.") deprecated deprecated pure nothrow @nogc @safe void separatorCharPos(int value)
		{
			this.dynamicSeparatorChar = value == 2147483647;
		}
		dchar separatorChar = ',';
		enum int DYNAMIC = 2147483647;
		enum int UNSPECIFIED = 2147483646;
		char spec = 's';
		ubyte indexStart;
		ubyte indexEnd;
		version (StdDdoc)
		{
			bool flDash;
			bool flZero;
			bool flSpace;
			bool flPlus;
			bool flHash;
			bool flEqual;
			bool flSeparator;
			ubyte allFlags;
		}
		else
		{
			union
			{
				import std.bitmanip : bitfields;
				mixin(bitfields!(bool, "flDash", 1, bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
				{
					pure nothrow @nogc @safe string bitfields()
					{
						import std.conv : to;
						return "private ubyte _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf;@property bool flDash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 1U) != 0;}\n@property void flDash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 1U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))1U);}\n@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}\n@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}\n@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}\n@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}\n@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";
					}

				}
				);
				ubyte allFlags;
			}
		}
		const(char)[] nested;
		const(char)[] sep;
		const(char)[] trailing;
		enum string seqBefore = "[";
		enum string seqAfter = "]";
		enum string keySeparator = ":";
		enum string seqSeparator = ", ";
		pure nothrow @nogc @safe this(in char[] fmt)
		{
			this.trailing = fmt;
			return this;
		}
		scope bool writeUpToNextSpec(OutputRange)(ref OutputRange writer)
		{
			import std.format : enforceFmt;
			if (trailing.empty)
				return false;
			for (size_t i = 0;
			 i < trailing.length; ++i)
			{
				{
					if (trailing[i] != '%')
						continue;
					put(writer, trailing[0..i]);
					trailing = trailing[i..__dollar];
					enforceFmt(trailing.length >= 2, "Unterminated format specifier: \"%\"");
					trailing = trailing[1..__dollar];
					if (trailing[0] != '%')
					{
						fillUp();
						return true;
					}
					i = 0;
				}
			}
			put(writer, trailing);
			trailing = null;
			return false;
		}
		private pure scope @safe void fillUp()
		{
			import std.format : enforceFmt, FormatException;
			if (__ctfe)
			{
				this.flDash(false);
				this.flZero(false);
				this.flSpace(false);
				this.flPlus(false);
				this.flEqual(false);
				this.flHash(false);
				this.flSeparator(false);
			}
			else
			{
				this.allFlags = cast(ubyte)0u;
			}
			this.width = 0;
			this.precision = 2147483646;
			this.nested = null;
			{
				ulong i = 0LU;
				for (; i < this.trailing.length;)
				{
					{
						switch (cast(int)this.trailing[i])
						{
							case 40:
							{
								ulong j = i + 1LU;
								{
									uint innerParens = 0u;
									for (;;)
									{
										{
											enforce(j + 1LU < this.trailing.length, delegate const(char)[]() pure nothrow @nogc @safe => text("Incorrect format specifier: %", this.trailing[i..__dollar]), "/usr/include/dmd/phobos/std/format/spec.d", 312LU);
											if (cast(int)this.trailing[j++] != 37)
											{
												continue;
											}
											if (cast(int)this.trailing[j] == 45)
											{
												j += 1LU;
												enforce(j < this.trailing.length, delegate const(char)[]() pure nothrow @nogc @safe => text("Incorrect format specifier: %", this.trailing[i..__dollar]), "/usr/include/dmd/phobos/std/format/spec.d", 322LU);
											}
											if (cast(int)this.trailing[j] == 41)
											{
												if (innerParens-- == 0u)
													break;
											}
											else if (cast(int)this.trailing[j] == 124)
											{
												if (innerParens == 0u)
													break;
											}
											else if (cast(int)this.trailing[j] == 40)
											{
												innerParens += 1u;
											}
										}
									}
								}
								if (cast(int)this.trailing[j] == 124)
								{
									ulong k = j;
									{
										j += 1LU;
										for (;;)
										{
											{
												if (cast(int)this.trailing[j++] != 37)
													continue;
												if (cast(int)this.trailing[j] == 37)
													j += 1LU;
												else if (cast(int)this.trailing[j] == 41)
													break;
												else
													throw new FormatException(text("Incorrect format specifier: %", this.trailing[j..__dollar]), "/usr/include/dmd/phobos/std/format/spec.d", 350LU, null);
											}
										}
									}
									this.nested = this.trailing[i + 1LU..k - 1LU];
									this.sep = this.trailing[k + 1LU..j - 1LU];
								}
								else
								{
									this.nested = this.trailing[i + 1LU..j - 1LU];
									this.sep = null;
								}
								this.spec = '(';
								this.trailing = this.trailing[j + 1LU..__dollar];
								return ;
							}
							case 45:
							{
								this.flDash(true);
								i += 1LU;
								break;
							}
							case 43:
							{
								this.flPlus(true);
								i += 1LU;
								break;
							}
							case 61:
							{
								this.flEqual(true);
								i += 1LU;
								break;
							}
							case 35:
							{
								this.flHash(true);
								i += 1LU;
								break;
							}
							case 48:
							{
								this.flZero(true);
								i += 1LU;
								break;
							}
							case 32:
							{
								this.flSpace(true);
								i += 1LU;
								break;
							}
							case 42:
							{
								if (isDigit(cast(dchar)this.trailing[i += 1LU]))
								{
									this.trailing = this.trailing[1..__dollar];
									this.width = -parse(this.trailing);
									i = 0LU;
									enforce(cast(int)this.trailing[i++] == 36, delegate const(char)[]() pure nothrow @nogc @safe => text("$ expected after '*", -this.width, "' in format string"), "/usr/include/dmd/phobos/std/format/spec.d", 381LU);
								}
								else
								{
									this.width = 2147483647;
								}
								break;
							}
							case 49:
							;
							case 50:
							;
							case 51:
							;
							case 52:
							;
							case 53:
							;
							case 54:
							;
							case 55:
							;
							case 56:
							;
							case 57:
							{
								const(char)[] tmp = this.trailing[i..__dollar];
								const const(uint) widthOrArgIndex = parse(tmp);
								enforce(tmp.length, delegate const(char)[]() pure nothrow @nogc @safe => text("Incorrect format specifier %", this.trailing[i..__dollar]), "/usr/include/dmd/phobos/std/format/spec.d", 393LU);
								i = this.trailing.length - tmp.length;
								if (startsWith(tmp, '$'))
								{
									this.indexEnd = (this.indexStart = to(widthOrArgIndex));
									i += 1LU;
								}
								else if (startsWith(tmp, ':'))
								{
									this.indexStart = to(widthOrArgIndex);
									tmp = tmp[1..__dollar];
									if (startsWith(tmp, '$'))
									{
										this.indexEnd = cast(ubyte)255u;
									}
									else
									{
										this.indexEnd = parse(tmp);
									}
									i = this.trailing.length - tmp.length;
									enforce(cast(int)this.trailing[i++] == 36, delegate const(char)[]() pure nothrow @nogc @safe => "$ expected", "/usr/include/dmd/phobos/std/format/spec.d", 416LU);
								}
								else
								{
									this.width = to(widthOrArgIndex);
								}
								break;
							}
							case 44:
							{
								i += 1LU;
								this.flSeparator(true);
								if (cast(int)this.trailing[i] == 42)
								{
									i += 1LU;
									this.separators = 2147483647;
								}
								else if (isDigit(cast(dchar)this.trailing[i]))
								{
									const(char)[] tmp = this.trailing[i..__dollar];
									this.separators = parse(tmp);
									i = this.trailing.length - tmp.length;
								}
								else
								{
									this.separators = 3;
								}
								if (cast(int)this.trailing[i] == 63)
								{
									this.dynamicSeparatorChar = true;
									i += 1LU;
								}
								break;
							}
							case 46:
							{
								if (cast(int)this.trailing[i += 1LU] == 42)
								{
									if (isDigit(cast(dchar)this.trailing[i += 1LU]))
									{
										this.trailing = this.trailing[i..__dollar];
										i = 0LU;
										this.precision = -parse(this.trailing);
										enforce(cast(int)this.trailing[i++] == 36, delegate const(char)[]() pure nothrow @nogc @safe => "$ expected", "/usr/include/dmd/phobos/std/format/spec.d", 466LU);
									}
									else
									{
										this.precision = 2147483647;
									}
								}
								else if (cast(int)this.trailing[i] == 45)
								{
									this.precision = 0;
									const(char)[] tmp = this.trailing[i..__dollar];
									parse(tmp);
									i = this.trailing.length - tmp.length;
								}
								else if (isDigit(cast(dchar)this.trailing[i]))
								{
									const(char)[] tmp = this.trailing[i..__dollar];
									this.precision = parse(tmp);
									i = this.trailing.length - tmp.length;
								}
								else
								{
									this.precision = 0;
								}
								break;
							}
							default:
							{
								this.spec = this.trailing[i++];
								this.trailing = this.trailing[i..__dollar];
								return ;
							}
						}
					}
				}
			}
			throw new FormatException(text("Incorrect format specifier: ", this.trailing), "/usr/include/dmd/phobos/std/format/spec.d", 502LU, null);
		}
		package scope bool readUpToNextSpec(R)(ref R r)
		{
			import std.ascii : isLower, isWhite;
			import std.format : enforceFmt;
			import std.utf : stride;
			if (__ctfe)
			{
				flDash = false;
				flZero = false;
				flSpace = false;
				flPlus = false;
				flHash = false;
				flEqual = false;
				flSeparator = false;
			}
			else
			{
				allFlags = 0;
			}
			width = 0;
			precision = UNSPECIFIED;
			nested = null;
			while (trailing.length)
			{
				const c = trailing[0];
				if (c == '%' && (trailing.length > 1))
				{
					const c2 = trailing[1];
					if (c2 == '%')
					{
						assert(!r.empty, "Required at least one more input");
						enforceFmt(r.front == '%', text("parseToFormatSpec: Cannot find character '", c2, "' in the input string."));
						trailing = trailing[2..__dollar];
						r.popFront();
					}
					else
					{
						enforceFmt(isLower(c2) || c2 == '*' || c2 == '(', text("'%", c2, "' not supported with formatted read"));
						trailing = trailing[1..__dollar];
						fillUp();
						return true;
					}
				}
				else
				{
					if (c == ' ')
					{
						while (!r.empty && isWhite(r.front))
						r.popFront();
					}
					else
					{
						enforceFmt(!r.empty && (r.front == trailing.front), text("parseToFormatSpec: Cannot find character '", c, "' in the input string."));
						r.popFront();
					}
					trailing = trailing[stride(trailing, 0)..__dollar];
				}
			}
			return false;
		}
		package const pure @safe string getCurFmtStr()
		{
			import std.array : appender;
			import std.format.write : formatValue;
			Appender!string w = appender();
			FormatSpec!char f = f = FormatSpec , f.this("%s");
			put(w, '%');
			if (cast(int)this.indexStart != 0)
			{
				formatValue(w, this.indexStart, f);
				put(w, '$');
			}
			if (this.flDash())
				put(w, '-');
			if (this.flZero())
				put(w, '0');
			if (this.flSpace())
				put(w, ' ');
			if (this.flPlus())
				put(w, '+');
			if (this.flEqual())
				put(w, '=');
			if (this.flHash())
				put(w, '#');
			if (this.width != 0)
				formatValue(w, this.width, f);
			if (this.precision != 2147483646)
			{
				put(w, '.');
				formatValue(w, this.precision, f);
			}
			if (this.flSeparator())
				put(w, ',');
			if (this.separators != 2147483646)
				formatValue(w, this.separators, f);
			put(w, this.spec);
			return w.data();
		}
		const pure @safe string toString()
		{
			import std.array : appender;
			Appender!string app = appender();
			app.reserve(200LU + this.trailing.length);
			this.toString(app);
			return app.data();
		}
		const void toString(OutputRange)(ref OutputRange writer) if (isOutputRange!(OutputRange, char)
		{
		}
		)
		{
			import std.format.write : formatValue;
			auto s = singleSpec("%s");
			put(writer, "address = ");
			formatValue(writer, &this, s);
			put(writer, "\nwidth = ");
			formatValue(writer, width, s);
			put(writer, "\nprecision = ");
			formatValue(writer, precision, s);
			put(writer, "\nspec = ");
			formatValue(writer, spec, s);
			put(writer, "\nindexStart = ");
			formatValue(writer, indexStart, s);
			put(writer, "\nindexEnd = ");
			formatValue(writer, indexEnd, s);
			put(writer, "\nflDash = ");
			formatValue(writer, flDash, s);
			put(writer, "\nflZero = ");
			formatValue(writer, flZero, s);
			put(writer, "\nflSpace = ");
			formatValue(writer, flSpace, s);
			put(writer, "\nflPlus = ");
			formatValue(writer, flPlus, s);
			put(writer, "\nflEqual = ");
			formatValue(writer, flEqual, s);
			put(writer, "\nflHash = ");
			formatValue(writer, flHash, s);
			put(writer, "\nflSeparator = ");
			formatValue(writer, flSeparator, s);
			put(writer, "\nnested = ");
			formatValue(writer, nested, s);
			put(writer, "\ntrailing = ");
			formatValue(writer, trailing, s);
			put(writer, '\n');
		}
	}

}
bitfields!(bool, "flDash", 1, bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	pure nothrow @nogc @safe string bitfields()
	{
		import std.conv : to;
		return "private ubyte _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf;@property bool flDash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 1U) != 0;}\n@property void flDash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 1U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))1U);}\n@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}\n@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}\n@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}\n@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}\n@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";
	}

}
__equals!(char, char)
{
	pure nothrow @nogc @trusted bool __equals(scope const(char[]) lhs, scope const(char[]) rhs)
	{
		const const(ulong) length = lhs.length;
		if (__ctfe)
			return length == rhs.length && isEqual(cast(const(char)*)lhs, cast(const(char)*)rhs, length);
		else
		{
			import core.stdc.string : memcmp;
			return length == rhs.length && (!length || 0 == memcmp(cast(const(void*))cast(const(char)*)lhs, cast(const(void*))cast(const(char)*)rhs, length * 1LU));
		}
	}

}
isEqual!(char, char)
{
	pure nothrow @nogc @system bool isEqual(scope const(char*) t1, scope const(char*) t2, ulong length)
	{
		{
			ulong __key70 = 0LU;
			ulong __limit71 = length;
			for (; __key70 < __limit71; __key70 += 1LU)
			{
				const const(ulong) i = __key70;
				if (cast(int)t1[i] != cast(int)t2[i])
					return false;
			}
		}
		return true;
	}

}
createStorageAndFields!(bool, "flDash", 1, bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStorageAndFields = "private ubyte _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf;@property bool flDash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 1U) != 0;}\n@property void flDash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 1U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))1U);}\n@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}\n@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}\n@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}\n@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}\n@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createStoreName!(bool, "flDash", 1, bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStoreName = "_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf";

}
createStoreName!(bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStoreName = "_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf";

}
createStoreName!(bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStoreName = "_flSpace_flPlus_flHash_flEqual_flSeparator__bf";

}
createStoreName!(bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStoreName = "_flPlus_flHash_flEqual_flSeparator__bf";

}
createStoreName!(bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStoreName = "_flHash_flEqual_flSeparator__bf";

}
createStoreName!(bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStoreName = "_flEqual_flSeparator__bf";

}
createStoreName!(bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createStoreName = "_flSeparator__bf";

}
createStoreName!(ubyte, "", 1)
{
	enum string createStoreName = "__bf";

}
createStoreName!()
{
	enum string createStoreName = "_bf";

}
sizeOfBitField!(bool, "flDash", 1, bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum int sizeOfBitField = 8;

}
sizeOfBitField!(bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum int sizeOfBitField = 7;

}
sizeOfBitField!(bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum int sizeOfBitField = 6;

}
sizeOfBitField!(bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum int sizeOfBitField = 5;

}
sizeOfBitField!(bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum int sizeOfBitField = 4;

}
sizeOfBitField!(bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum int sizeOfBitField = 3;

}
sizeOfBitField!(bool, "flSeparator", 1, ubyte, "", 1)
{
	enum int sizeOfBitField = 2;

}
sizeOfBitField!(ubyte, "", 1)
{
	enum int sizeOfBitField = 1;

}
sizeOfBitField!()
{
	enum int sizeOfBitField = 0;

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 0LU, bool, "flDash", 1, bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createFields = "@property bool flDash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 1U) != 0;}\n@property void flDash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 1U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))1U);}\n@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}\n@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}\n@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}\n@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}\n@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", bool, "flDash", 1LU, 0LU)
{
	enum string createAccessors = "@property bool flDash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 1U) != 0;}\n@property void flDash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 1U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))1U);}\n";

}
unsignedToTempString!10u
{
	pure nothrow @nogc @safe char[] unsignedToTempString(ulong value, return scope char[] buf)
	{
		@nogc ulong i = buf.length;
		do
		{
			@nogc uint x = void;
			if (value < 10LU)
			{
				x = cast(uint)value;
				value = 0LU;
			}
			else
			{
				x = cast(uint)(value % 10LU);
				value /= 10LU;
			}
			buf[i -= 1LU] = cast(char)(x + 48u);
		}
		while (value);
		return buf[i..__dollar];
	}

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 1LU, bool, "flZero", 1, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createFields = "@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}\n@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}\n@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}\n@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}\n@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", bool, "flZero", 1LU, 1LU)
{
	enum string createAccessors = "@property bool flZero() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 2U) != 0;}\n@property void flZero(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 2U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))2U);}\n";

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 2LU, bool, "flSpace", 1, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createFields = "@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}\n@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}\n@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", bool, "flSpace", 1LU, 2LU)
{
	enum string createAccessors = "@property bool flSpace() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 4U) != 0;}\n@property void flSpace(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 4U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))4U);}\n";

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 3LU, bool, "flPlus", 1, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createFields = "@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", bool, "flPlus", 1LU, 3LU)
{
	enum string createAccessors = "@property bool flPlus() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 8U) != 0;}\n@property void flPlus(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 8U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))8U);}\n";

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 4LU, bool, "flHash", 1, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createFields = "@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", bool, "flHash", 1LU, 4LU)
{
	enum string createAccessors = "@property bool flHash() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 16U) != 0;}\n@property void flHash(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 16U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))16U);}\n";

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 5LU, bool, "flEqual", 1, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createFields = "@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", bool, "flEqual", 1LU, 5LU)
{
	enum string createAccessors = "@property bool flEqual() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 32U) != 0;}\n@property void flEqual(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 32U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))32U);}\n";

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 6LU, bool, "flSeparator", 1, ubyte, "", 1)
{
	enum string createFields = "@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", bool, "flSeparator", 1LU, 6LU)
{
	enum string createAccessors = "@property bool flSeparator() @safe pure nothrow @nogc const { return (_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf & 64U) != 0;}\n@property void flSeparator(bool v) @safe pure nothrow @nogc { if (v) _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf |= 64U;else _flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf &= cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))(-1-cast(typeof(_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf))64U);}\n";

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 7LU, ubyte, "", 1)
{
	enum string createFields = "";

}
createAccessors!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", ubyte, "", 1LU, 7LU)
{
	enum string createAccessors = "";

}
createFields!("_flDash_flZero_flSpace_flPlus_flHash_flEqual_flSeparator__bf", 8LU)
{
	enum string createFields = "";

}
writeUpToNextSpec!(LockingTextWriter)
{
	scope @safe bool writeUpToNextSpec(ref LockingTextWriter writer)
	{
		import std.format : enforceFmt;
		if (empty(this.trailing))
			return false;
		{
			ulong i = 0LU;
			for (; i < this.trailing.length; i += 1LU)
			{
				{
					if (cast(int)this.trailing[i] != 37)
						continue;
					put(writer, this.trailing[0..i]);
					this.trailing = this.trailing[i..__dollar];
					enforce(this.trailing.length >= 2LU, delegate const(char)[]() pure nothrow @nogc @safe => "Unterminated format specifier: \"%\"", "/usr/include/dmd/phobos/std/format/spec.d", 260LU);
					this.trailing = this.trailing[1..__dollar];
					if (cast(int)this.trailing[0] != 37)
					{
						this.fillUp();
						return true;
					}
					i = 0LU;
				}
			}
		}
		put(writer, this.trailing);
		this.trailing = null;
		return false;
	}

}
empty!(const(char)[])
{
	pure nothrow @nogc @property @safe bool empty(ref scope const(char)[] a)
	{
		return !a.length;
	}

}
put!(LockingTextWriter, const(char)[])
{
	@safe void put(ref LockingTextWriter r, const(char)[] e)
	{
		doPut(r, e);
	}

}
doPut!(LockingTextWriter, const(char)[])
{
	@safe void doPut(ref LockingTextWriter r, ref const(char)[] e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
hasMember!(LockingTextWriter, "put")
{
	enum bool hasMember = true;

}
ElementType!(const(char)[])
{
	alias ElementType = dchar;

}
isAutodecodableString!(char[])
{
	enum bool isAutodecodableString = true;

}
front!char
{
	pure @property @safe dchar front(scope const(char)[] a)
	{
		import std.utf : decode;
		assert(a.length, "Attempting to fetch the front of an empty array of char");
		ulong i = 0LU;
		return decode(a, i);
	}

}
opDispatch!"useReplacementDchar"
{
	enum Flag opDispatch = Flag.no;

}
isSomeString!(const(char)[])
{
	enum bool isSomeString = true;

}
decode!(Flag.no, const(char)[])
{
	pure @trusted dchar decode(ref scope const(char)[] str, ref ulong index)
	in
	{
		assert(index < str.length, "Attempted to decode past the end of a string");
	}
	out(result)
	{
		assert(isValidDchar(result));
	}
	do
	{
		{
			{
				assert(index < str.length, "Attempted to decode past the end of a string");
			}
		}
		if (cast(int)str[index] < 128)
			__result = cast(dchar)str[index++];
			goto __returnLabel;
		else
		{
			__result = decodeImpl(str, index);
			goto __returnLabel;
		}
		__returnLabel:
		{
			const ref const(dchar) result = __result;
			{
				assert(isValidDchar(result));
			}
		}
		return __result;
	}

}
ElementEncodingType!(const(char)[])
{
	alias ElementEncodingType = const(char);

}
StringTypeOf!(const(char)[])
{
	alias StringTypeOf = const(char)[];

}
isSomeChar!(const(char))
{
	enum bool isSomeChar = true;

}
codeUnitLimit!(const(char)[])
{
	enum char codeUnitLimit = '\x80';

}
isInputRange!(const(char)[])
{
	enum bool isInputRange = true;

}
isCallable!(function (const(char)[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (const(char)[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (const(char)[] r) pure nothrow @nogc @safe => empty(r))
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (const(char)[] r) pure nothrow @nogc @safe => empty(r))
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(const(char)[] r);

}
isCallable!(function (const(char)[] r) pure @safe => front(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (const(char)[] r) pure @safe => front(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (const(char)[] r) pure @safe => front(r))
{
	alias ReturnType = dchar;

}
FunctionTypeOf!(function (const(char)[] r) pure @safe => front(r))
{
	alias pure @safe dchar FunctionTypeOf(const(char)[] r);

}
popFront!char
{
	pure nothrow @nogc @trusted void popFront(ref scope inout(char)[] str)
	{
		import std.algorithm.comparison : min;
		assert(str.length, "Attempting to popFront() past the end of an array of char");
		static immutable immutable(ubyte[]) charWidthTab = [cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)2u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)3u, cast(ubyte)4u, cast(ubyte)4u, cast(ubyte)4u, cast(ubyte)4u, cast(ubyte)4u, cast(ubyte)4u, cast(ubyte)4u, cast(ubyte)4u, cast(ubyte)5u, cast(ubyte)5u, cast(ubyte)5u, cast(ubyte)5u, cast(ubyte)6u, cast(ubyte)6u, cast(ubyte)1u, cast(ubyte)1u];
		immutable immutable(char) c = str[0];
		immutable immutable(int) charWidth = cast(int)c < 192 ? 1 : cast(int)(cast(immutable(ubyte)*)charWidthTab)[cast(ulong)(cast(int)c - 192)];
		str = (cast(inout(char)*)str)[cast(ulong)min(str.length, charWidth)..str.length];
	}

}
CommonType!(ulong, immutable(int))
{
	alias CommonType = ulong;

}
CommonType!ulong
{
	alias CommonType = ulong;

}
min!(ulong, immutable(int))
{
	auto pure nothrow @nogc @safe immutable(int) min(ulong _param_0, immutable(int) _param_1)
	{
		alias a = ulong _param_0;
		;
		alias T0 = ulong;
		alias b = immutable immutable(int) _param_1;
		;
		alias T1 = immutable(int);
		alias Result = immutable(int);
		import std.functional : lessThan;
		immutable immutable(bool) chooseB = safeOp(_param_1, _param_0);
		return chooseB ? cast(immutable(int))cast(ulong)_param_1 : cast(immutable(int))_param_0;
	}

}
isNumeric!ulong
{
	enum bool isNumeric = true;

}
mostNegative!ulong
{
	enum byte mostNegative = cast(byte)0;

}
isNumeric!(immutable(int))
{
	enum bool isNumeric = true;

}
mostNegative!(immutable(int))
{
	enum immutable immutable(int) mostNegative = -2147483648;

}
Select!(true, immutable(int), ulong)
{
	alias Select = immutable(int);

}
safeOp!(immutable(int), ulong)
{
	pure nothrow @nogc @safe bool safeOp(ref immutable(int) a, ref ulong b)
	{
		import std.traits : mostNegative;
		immutable immutable(bool) result = a < 0 || unsafeOp(a, b);
		return result;
	}

}
isIntegral!(immutable(int))
{
	enum bool isIntegral = true;

}
isIntegral!ulong
{
	enum bool isIntegral = true;

}
unsafeOp!(immutable(int), ulong)
{
	pure nothrow @nogc @safe bool unsafeOp(immutable(int) a, ulong b)
	{
		import std.traits : CommonType;
		alias T = ulong;
		return cast(ulong)a < b;
	}

}
CommonType!(immutable(int), ulong)
{
	alias CommonType = ulong;

}
decodeImpl!(true, Flag.no, const(char)[])
{
	pure @system dchar decodeImpl(ref const(char)[] str, ref ulong index)
	{
		alias bitMask = TList;
		const(char)* pstr = cast(const(char)*)str + cast(long)index * 1L;
		immutable immutable(ulong) length = str.length - index;
		ubyte fst = cast(ubyte)pstr[0];
		static UTFException exception(S)(S str, string msg)
		{
			uint[4] sequence = void;
			size_t i;
			do
			{
				sequence[i] = str[i];
			}
			while (++i < str.length && (i < 4) && ((str[i] & 192) == 128));
			return (new UTFException(msg, i)).setSequence(sequence[0..i]);
		}
		pure nothrow @system UTFException invalidUTF()
		{
			return exception(pstr[0..length], "Invalid UTF-8 sequence");
		}
		pure nothrow @system UTFException outOfBounds()
		{
			return exception(pstr[0..length], "Attempted to decode past the end of a string");
		}
		if ((cast(int)fst & 192) != 192)
		{
			throw invalidUTF();
		}
		ubyte tmp = void;
		dchar d = cast(dchar)fst;
		cast(int)fst <<= 1;
		/*unrolled*/ {
			{
				enum int i = 1;
				if (1LU == length)
				{
					throw outOfBounds();
				}
				tmp = cast(ubyte)pstr[1];
				if ((cast(int)tmp & 192) != 128)
				{
					throw invalidUTF();
				}
				d = cast(dchar)(cast(uint)d << 6 | cast(uint)(cast(int)tmp & 63));
				cast(int)fst <<= 1;
				if (!(cast(int)fst & 128))
				{
					cast(uint)d &= 2047u;
					if ((cast(uint)d & 4294967168u) == 0u)
					{
						throw invalidUTF();
					}
					index += 2LU;
					return d;
				}
			}
			{
				enum int i = 2;
				if (2LU == length)
				{
					throw outOfBounds();
				}
				tmp = cast(ubyte)pstr[2];
				if ((cast(int)tmp & 192) != 128)
				{
					throw invalidUTF();
				}
				d = cast(dchar)(cast(uint)d << 6 | cast(uint)(cast(int)tmp & 63));
				cast(int)fst <<= 1;
				if (!(cast(int)fst & 128))
				{
					cast(uint)d &= 65535u;
					if ((cast(uint)d & 4294965248u) == 0u)
					{
						throw invalidUTF();
					}
					if (!isValidDchar(d))
					{
						throw invalidUTF();
					}
					index += 3LU;
					return d;
				}
			}
			{
				enum int i = 3;
				if (3LU == length)
				{
					throw outOfBounds();
				}
				tmp = cast(ubyte)pstr[3];
				if ((cast(int)tmp & 192) != 128)
				{
					throw invalidUTF();
				}
				d = cast(dchar)(cast(uint)d << 6 | cast(uint)(cast(int)tmp & 63));
				cast(int)fst <<= 1;
				if (!(cast(int)fst & 128))
				{
					cast(uint)d &= 2097151u;
					if ((cast(uint)d & 4294901760u) == 0u)
					{
						throw invalidUTF();
					}
					if (cast(uint)d > 1114111u)
					{
						throw invalidUTF();
					}
					index += 4LU;
					return d;
				}
			}
		}
		throw invalidUTF();
	}

}
exception!(const(char)[])
{
	static pure nothrow @safe UTFException exception(const(char)[] str, string msg)
	{
		uint[4] sequence = void;
		ulong i = 0LU;
		do
		{
			sequence[i] = cast(uint)str[i];
		}
		while ((i += 1LU) < str.length && (i < 4LU) && ((cast(int)str[i] & 192) == 128));
		return (new UTFException(msg, i, "/usr/include/dmd/phobos/std/utf.d", 1556LU, null)).setSequence(sequence[0..i]);
	}

}
isSomeChar!dchar
{
	enum bool isSomeChar = true;

}
isInfinite!(const(char)[])
{
	enum bool isInfinite = false;

}
isSomeChar!(const(char)[])
{
	enum bool isSomeChar = false;

}
put!(const(char)[])
{
	@safe void put(scope const(char)[] writeme)
	{
		import std.exception : errnoEnforce;
		alias C = const(char);
		if (this.orientation_ <= 0)
		{
			ulong result = trustedFwrite((*this.file_._p).handle, writeme);
			if (result != writeme.length)
				enforce(0, delegate const(char)[]() pure nothrow @nogc @safe => null, "/usr/include/dmd/phobos/std/stdio.d", 3174LU);
			return ;
		}
		{
			scope const(char)[] __r93 = writeme[];
			ulong __key94 = 0LU;
			for (; __key94 < __r93.length; __key94 += 1LU)
			{
				const const(char) c = __r93[__key94];
				this.put(c);
			}
		}
	}

}
trustedFwrite!char
{
	auto nothrow @nogc @trusted ulong trustedFwrite(shared(_IO_FILE)* f, const(char[]) obj)
	{
		return fwrite(cast(const(void*))cast(const(char)*)obj, 1LU, obj.length, f);
	}

}
enforce!int
{
	@safe int enforce(int value, lazy const(char)[] msg = null, string file = __FILE__, ulong line = cast(ulong)__LINE__)
	{
		if (!value)
			bailOut(file, line, msg());
		return value;
	}

}
bailOut!(ErrnoException)
{
	@safe noreturn bailOut(string file, ulong line, scope const(char)[] msg)
	{
		throw new ErrnoException(msg ? idup(msg) : "Enforcement failed", file, line);
	}

}
idup!(const(char))
{
	pure nothrow @property @safe string idup(const(char)[] a)
	{
		import core.internal.array.duplication : _dup;
		return _dup(a);
	}

}
_dup!(const(char), immutable(char))
{
	pure nothrow @trusted string _dup(scope const(char)[] a)
	{
		if (__ctfe)
			return _dupCtfe(a);
		import core.stdc.string : memcpy;
		void[] arr = _d_newarrayU(typeid(const(char)[]), a.length);
		memcpy(cast(void*)arr, cast(const(void)*)cast(const(char)*)a, 1LU * a.length);
		return *& arr;
	}

}
_dupCtfe!(const(char), immutable(char))
{
	pure nothrow @safe string _dupCtfe(scope const(char)[] a)
	{
		string res = null;
		{
			const(char)[] __r90 = a[];
			ulong __key91 = 0LU;
			for (; __key91 < __r90.length; __key91 += 1LU)
			{
				const ref const(char) e = __r90[__key91];
				(immutable ref immutable(char) __appendtmp92 = e;) , (_d_arrayappendcTX(res, 1LU) , res[res.length - 1LU] = __appendtmp92 , res);
			}
		}
		return res;
	}

}
_d_arrayappendcTXImpl!(string, immutable(char))
{
	import core.internal.array.utils : _d_HookTraceImpl;
	private enum string errorMessage = "Cannot append to array if compiling without support for runtime type information!";
	pure nothrow ref @trusted string _d_arrayappendcTX(return ref scope string px, ulong n)
	{
		TypeInfo_Array ti = typeid(string);
		byte[] pxx = (cast(byte*)cast(immutable(char)*)px)[0..px.length];
		_d_arrayappendcTX(ti, pxx, n);
		px = (cast(immutable(char)*)cast(byte*)pxx)[0..pxx.length];
		return px;
	}
	alias _d_arrayappendcTXTrace = auto pure nothrow @trusted string _d_HookTraceImpl(string file, int line, string funcname, return ref scope string _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "string";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arrayappendcTX(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}
	;
}
_d_HookTraceImpl!(string, _d_arrayappendcTX, "Cannot append to array if compiling without support for runtime type information!")
{
	auto pure nothrow @trusted string _d_HookTraceImpl(string file, int line, string funcname, return ref scope string _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "string";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arrayappendcTX(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}

}
Parameters!(_d_arrayappendcTX)
{
	alias Parameters = (return ref scope string, ulong);

}
FunctionTypeOf!(_d_arrayappendcTX)
{
	alias pure nothrow ref @trusted string FunctionTypeOf(return ref scope string px, ulong n);

}
ElementType!(const(char))
{
	alias ElementType = void;

}
isSomeChar!void
{
	enum bool isSomeChar = false;

}
put!(const(char))
{
	@safe void put(const(char) c)
	{
		import std.utf : decodeFront, encode, stride;
		this.highSurrogateShouldBeEmpty();
		if (this.orientation_ <= 0)
			trustedFPUTC(cast(int)c, this.handle_());
		else if (cast(int)c <= 127)
			trustedFPUTWC(cast(dchar)c, this.handle_());
		else if (cast(int)c >= 192)
		{
			this.rbuf8[0] = c;
			this.rbuf8Filled = 1LU;
		}
		else
		{
			this.rbuf8[this.rbuf8Filled] = c;
			this.rbuf8Filled += 1LU;
			if (cast(ulong)stride(this.rbuf8[]) == this.rbuf8Filled)
			{
				char[] str = this.rbuf8[0..this.rbuf8Filled];
				immutable immutable(dchar) d = decodeFront(str);
				dchar[1] wbuf = '\uffff';
				immutable immutable(ulong) size = encode(wbuf, d);
				{
					ulong __key99 = 0LU;
					ulong __limit100 = size;
					for (; __key99 < __limit100; __key99 += 1LU)
					{
						ulong i = __key99;
						trustedFPUTWC(wbuf[i], this.handle_());
					}
				}
				this.rbuf8Filled = 0LU;
			}
		}
	}

}
isInputRange!(char[])
{
	enum bool isInputRange = true;

}
empty!(char[])
{
	pure nothrow @nogc @property @safe bool empty(ref scope char[] a)
	{
		return !a.length;
	}

}
isCallable!(function (char[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (char[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (char[] r) pure nothrow @nogc @safe => empty(r))
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (char[] r) pure nothrow @nogc @safe => empty(r))
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(char[] r);

}
isCallable!(function (char[] r) pure @safe => front(cast(const(char)[])r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (char[] r) pure @safe => front(cast(const(char)[])r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (char[] r) pure @safe => front(cast(const(char)[])r))
{
	alias ReturnType = dchar;

}
FunctionTypeOf!(function (char[] r) pure @safe => front(cast(const(char)[])r))
{
	alias pure @safe dchar FunctionTypeOf(char[] r);

}
ElementType!(char[])
{
	alias ElementType = dchar;

}
ElementEncodingType!(char[])
{
	alias ElementEncodingType = char;

}
StringTypeOf!(char[])
{
	alias StringTypeOf = char[];

}
stride!(char[])
{
	pure @safe uint stride(char[] str)
	{
		immutable immutable(char) c = str[0];
		if (cast(int)c < 128)
			return 1u;
		else
			return strideImpl(c, 0LU);
	}

}
decodeFront!(Flag.no, char[])
{
	pure @safe dchar decodeFront(ref char[] str)
	{
		ulong numCodeUnits = 0LU;
		return decodeFront(str, numCodeUnits);
	}

}
isSomeString!(char[])
{
	enum bool isSomeString = true;

}
decodeFront!(Flag.no, char[])
{
	pure @trusted dchar decodeFront(ref scope char[] str, out ulong numCodeUnits)
	in
	{
		assert(!empty(str));
	}
	out(result)
	{
		assert(isValidDchar(result));
	}
	do
	{
		numCodeUnits = 0LU;
		{
			{
				assert(!empty(str));
			}
		}
		if (cast(int)str[0] < 128)
		{
			numCodeUnits = 1LU;
			immutable immutable(char) retval = str[0];
			str = str[1..__dollar];
			__result = cast(dchar)retval;
			goto __returnLabel;
		}
		else
		{
			immutable immutable(dchar) retval = decodeImpl(cast(const(char)[])str, numCodeUnits);
			str = str[numCodeUnits..__dollar];
			__result = retval;
			goto __returnLabel;
		}
		__returnLabel:
		{
			const ref const(dchar) result = __result;
			{
				assert(isValidDchar(result));
			}
		}
		return __result;
	}

}
isSomeChar!char
{
	enum bool isSomeChar = true;

}
codeUnitLimit!(char[])
{
	enum char codeUnitLimit = '\x80';

}
decodeImpl!(true, Flag.no, const(char)[])
{
	pure @system dchar decodeImpl(const(char)[] str, ref ulong index)
	{
		alias bitMask = TList;
		const(char)* pstr = cast(const(char)*)str + cast(long)index * 1L;
		immutable immutable(ulong) length = str.length - index;
		ubyte fst = cast(ubyte)pstr[0];
		static UTFException exception(S)(S str, string msg)
		{
			uint[4] sequence = void;
			size_t i;
			do
			{
				sequence[i] = str[i];
			}
			while (++i < str.length && (i < 4) && ((str[i] & 192) == 128));
			return (new UTFException(msg, i)).setSequence(sequence[0..i]);
		}
		pure nothrow @system UTFException invalidUTF()
		{
			return exception(pstr[0..length], "Invalid UTF-8 sequence");
		}
		pure nothrow @system UTFException outOfBounds()
		{
			return exception(pstr[0..length], "Attempted to decode past the end of a string");
		}
		if ((cast(int)fst & 192) != 192)
		{
			throw invalidUTF();
		}
		ubyte tmp = void;
		dchar d = cast(dchar)fst;
		cast(int)fst <<= 1;
		/*unrolled*/ {
			{
				enum int i = 1;
				if (1LU == length)
				{
					throw outOfBounds();
				}
				tmp = cast(ubyte)pstr[1];
				if ((cast(int)tmp & 192) != 128)
				{
					throw invalidUTF();
				}
				d = cast(dchar)(cast(uint)d << 6 | cast(uint)(cast(int)tmp & 63));
				cast(int)fst <<= 1;
				if (!(cast(int)fst & 128))
				{
					cast(uint)d &= 2047u;
					if ((cast(uint)d & 4294967168u) == 0u)
					{
						throw invalidUTF();
					}
					index += 2LU;
					return d;
				}
			}
			{
				enum int i = 2;
				if (2LU == length)
				{
					throw outOfBounds();
				}
				tmp = cast(ubyte)pstr[2];
				if ((cast(int)tmp & 192) != 128)
				{
					throw invalidUTF();
				}
				d = cast(dchar)(cast(uint)d << 6 | cast(uint)(cast(int)tmp & 63));
				cast(int)fst <<= 1;
				if (!(cast(int)fst & 128))
				{
					cast(uint)d &= 65535u;
					if ((cast(uint)d & 4294965248u) == 0u)
					{
						throw invalidUTF();
					}
					if (!isValidDchar(d))
					{
						throw invalidUTF();
					}
					index += 3LU;
					return d;
				}
			}
			{
				enum int i = 3;
				if (3LU == length)
				{
					throw outOfBounds();
				}
				tmp = cast(ubyte)pstr[3];
				if ((cast(int)tmp & 192) != 128)
				{
					throw invalidUTF();
				}
				d = cast(dchar)(cast(uint)d << 6 | cast(uint)(cast(int)tmp & 63));
				cast(int)fst <<= 1;
				if (!(cast(int)fst & 128))
				{
					cast(uint)d &= 2097151u;
					if ((cast(uint)d & 4294901760u) == 0u)
					{
						throw invalidUTF();
					}
					if (cast(uint)d > 1114111u)
					{
						throw invalidUTF();
					}
					index += 4LU;
					return d;
				}
			}
		}
		throw invalidUTF();
	}

}
exception!(const(char)[])
{
	static pure nothrow @safe UTFException exception(const(char)[] str, string msg)
	{
		uint[4] sequence = void;
		ulong i = 0LU;
		do
		{
			sequence[i] = cast(uint)str[i];
		}
		while ((i += 1LU) < str.length && (i < 4LU) && ((cast(int)str[i] & 192) == 128));
		return (new UTFException(msg, i, "/usr/include/dmd/phobos/std/utf.d", 1556LU, null)).setSequence(sequence[0..i]);
	}

}
encode!Flag.no
{
	pure @safe ulong encode(out dchar[1] buf, dchar c)
	{
		buf[] = '\uffff';
		if (55296u <= cast(uint)c && (cast(uint)c <= 57343u) || 1114111u < cast(uint)c)
			c = _utfException("Encoding an invalid code point in UTF-32", c);
		else
			assert(isValidDchar(c));
		buf[0] = c;
		return 1LU;
	}

}
_utfException!Flag.no
{
	pure @safe dchar _utfException(string msg, dchar c)
	{
		throw (new UTFException(msg, "/usr/include/dmd/phobos/std/utf.d", 2311LU, null)).setSequence([cast(uint)c][]);
	}

}
TraceHook!("string", "_d_arrayappendcTX")
{
	const const(char[]) TraceHook = "\n        import core.internal.array.utils : gcStatsPure, accumulatePure;\n\n        pragma(inline, false);\n        string name = `string`;\n\n        // FIXME: use rt.tracegc.accumulator when it is accessable in the future.\n        version (tracegc)\n    {\n\n            import core.stdc.stdio;\n\n            printf(\"%sTrace file = '%.*s' line = %d function = '%.*s' type = %.*s\\n\",\n            \"_d_arrayappendcTX\".ptr,\n                file.length, file.ptr,\n                line,\n                funcname.length, funcname.ptr,\n                name.length, name.ptr\n            );\n        }\n\n        ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;\n\n        scope(exit)\n        {\n            ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;\n            if (size > 0)\n                if (!accumulatePure(file, line, funcname, name, size)) {\n                    // This 'if' and 'assert' is needed to force the compiler to not remove the call to\n                    // `accumulatePure`. It really want to do that while optimizing as the function is\n                    // `pure` and it does not influence the result of this hook.\n\n                    // `accumulatePure` returns the value of `size`, which can never be zero due to the\n                    // previous 'if'. So this assert will never be triggered.\n                    assert(0);\n                }\n        }\n    ";

}
enforce!bool
{
	pure @safe bool enforce(bool value, lazy const(char)[] msg = null, string file = __FILE__, ulong line = cast(ulong)__LINE__)
	{
		if (!value)
			bailOut(file, line, msg());
		return value;
	}

}
bailOut!(FormatException)
{
	pure @safe noreturn bailOut(string file, ulong line, scope const(char)[] msg)
	{
		throw new FormatException(msg ? idup(msg) : "Enforcement failed", file, line, null);
	}

}
text!(string, const(char)[])
{
	pure nothrow @safe string text(string _param_0, const(char)[] _param_1)
	{
		return textImpl(_param_0, _param_1);
	}

}
textImpl!(string, string, const(char)[])
{
	pure nothrow @safe string textImpl(string _param_0, const(char)[] _param_1)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(40LU);
		app.put(_param_0);
		app.put(_param_1);
		return app.data();
	}

}
isDynamicArray!string
{
	enum bool isDynamicArray = true;

}
appender!string
{
	pure nothrow @safe Appender!string appender()
	{
		return Appender(null).this(null);
	}

}
Appender!string
{
	struct Appender
	{
		import core.memory : GC;
		private alias T = immutable(char);
		private struct Data
		{
			ulong capacity;
			char[] arr;
			bool tryExtendBlock = false;
		}
		private Data* _data;
		pure nothrow @trusted this(string arr)
		{
			this._data = new Data(0LU, null, false);
			(*this._data).arr = cast(char[])arr;
			if (__ctfe)
				return this;
			(*this._data).capacity = arr.length;
			return this;
		}
		pure nothrow @safe void reserve(ulong newCapacity)
		{
			if (this._data)
			{
				if (newCapacity > (*this._data).capacity)
					this.ensureAddable(newCapacity - (*this._data).arr.length);
			}
			else
			{
				this.ensureAddable(newCapacity);
			}
		}
		const pure nothrow @nogc @property @safe ulong capacity()
		{
			return this._data ? (*this._data).capacity : 0LU;
		}
		inout pure nothrow @nogc @property @trusted string data()
		{
			return this.opSlice();
		}
		inout pure nothrow @nogc @property @trusted string opSlice()
		{
			return this._data ? cast(string)(*this._data).arr : null;
		}
		private pure nothrow @safe void ensureAddable(ulong nelems)
		{
			if (!this._data)
				this._data = new Data(0LU, null, false);
			immutable immutable(ulong) len = (*this._data).arr.length;
			immutable immutable(ulong) reqlen = len + nelems;
			if ((*this._data).capacity >= reqlen)
				return ;
			if (__ctfe)
			{
				_d_arraysetlengthT((*this._data).arr, reqlen);
				(*this._data).arr = (*this._data).arr[0..len];
				(*this._data).capacity = reqlen;
			}
			else
			{
				ulong newlen = appenderNewCapacity((*this._data).capacity, reqlen);
				if ((*this._data).tryExtendBlock)
				{
					immutable immutable(ulong) u = delegate () pure nothrow @trusted => extend(cast(void*)cast(char*)(*this._data).arr, nelems * 1LU, (newlen - len) * 1LU, null)();
					if (u)
					{
						(*this._data).capacity = u / 1LU;
						return ;
					}
				}
				import core.checkedint : mulu;
				bool overflow = false;
				const const(ulong) nbytes = mulu(newlen, 1LU, overflow);
				if (overflow)
					assert(false, "the reallocation would exceed the available pointer range");
				BlkInfo_ bi = delegate () pure nothrow @trusted => qalloc(nbytes, 2u, null)();
				(*this._data).capacity = bi.size / 1LU;
				import core.stdc.string : memcpy;
				if (len)
					delegate () pure nothrow @nogc @trusted
					{
						memcpy(bi.base, cast(const(void*))cast(char*)(*this._data).arr, len * 1LU);
					}
					();
				(*this._data).arr = delegate () pure nothrow @nogc @trusted => (cast(char*)bi.base)[0..len]();
				(*this._data).tryExtendBlock = true;
			}
		}
		private enum bool canPutItem(U) = isImplicitlyConvertible!(Unqual!U
		{
		}
		, Unqual!T
		{
		}
		)
		{
		}
		 || isSomeChar!T
		{
		}
		 && isSomeChar!U
		{
		}
		;
		private enum bool canPutConstRange(Range) = isInputRange!(Unqual!Range
		{
		}
		)
		{
		}
		 && !isInputRange!Range
		{
		}
		 && is(typeof(Appender.init.put(Range.init.front)));
		private enum bool canPutRange(Range) = isInputRange!Range
		{
		}
		 && is(typeof(Appender.init.put(Range.init.front)));
		void put(U)(U item) if (canPutItem!U
		{
		}
		)
		{
			static if (isSomeChar!T
			{
			}
			 && isSomeChar!U
			{
			}
			 && (T.sizeof < U.sizeof))
			{
				import std.utf : encode;
				Unqual!T
				{
				}
				[T.sizeof == 1 ? 4 : 2] encoded;
				auto len = encode(encoded, item);
				put(encoded[0..len]);
			}
			else
			{
				import core.lifetime : emplace;
				ensureAddable(1);
				immutable len = _data.arr.length;
				auto bigData = () @trusted => _data.arr.ptr[0..len + 1]();
				auto itemUnqual = () @trusted => &cast()item();
				emplace(&bigData[len], *itemUnqual);
				_data.arr = bigData;
			}
		}
		void put(Range)(Range items) if (canPutConstRange!Range
		{
		}
		)
		{
			alias p = put!(Unqual!Range
			{
			}
			)
			{
			}
			;
			p(items);
		}
		void put(Range)(Range items) if (canPutRange!Range
		{
		}
		)
		{
			static if (!(isSomeChar!T
			{
			}
			 && isSomeChar!(ElementType!Range
			{
			}
			)
			{
			}
			 && !is(immutable(Range) == immutable(T[]))) && is(typeof(items.length) == size_t))
			{
				static if (!isSomeChar!T
				{
				}
				)
				{
					if (items.length == 1)
					{
						put(items.front);
						return ;
					}
				}

				auto bigDataFun(size_t extra)
				{
					ensureAddable(extra);
					return () @trusted => _data.arr.ptr[0.._data.arr.length + extra]();
				}
				auto bigData = bigDataFun(items.length);
				immutable len = _data.arr.length;
				immutable newlen = bigData.length;
				alias UT = Unqual!T
				{
				}
				;
				static if (is(typeof(_data.arr[] = items[])) && !hasElaborateAssign!UT
				{
				}
				 && isAssignable!(UT, ElementEncodingType!Range
				{
				}
				)
				{
				}
				)
				{
					bigData[len..newlen] = items[];
				}
				else
				{
					import core.internal.lifetime : emplaceRef;
					foreach (ref it; bigData[len..newlen])
					{
						emplaceRef!T
						{
						}
						(it, items.front);
						items.popFront();
					}
				}
				_data.arr = bigData;
			}
			else
			{
				static if (isSomeChar!T
				{
				}
				 && isSomeChar!(ElementType!Range
				{
				}
				)
				{
				}
				 && !is(immutable(T) == immutable(ElementType!Range
				{
				}
				)))
				{
					import std.utf : decodeFront;
					while (!items.empty)
					{
						auto c = items.decodeFront;
						put(c);
					}
				}
				else
				{
					for (; !items.empty; items.popFront())
					{
						{
							put(items.front);
						}
					}
				}
			}
		}
		template opOpAssign(string op : "~")
		{
			alias opOpAssign = put;
		}
		static if (isMutable!(immutable(char))
		{
			enum bool isMutable = false;

		}
		)
		{
			pure nothrow @trusted void clear()
			{
				if (_data)
				{
					_data.arr = _data.arr.ptr[0..0];
				}
			}
			pure @trusted void shrinkTo(size_t newlength)
			{
				import std.exception : enforce;
				if (_data)
				{
					enforce(newlength <= _data.arr.length, "Attempting to shrink Appender with newlength > length");
					_data.arr = _data.arr.ptr[0..newlength];
				}
				else
					enforce(newlength == 0, "Attempting to shrink empty Appender with non-zero newlength");
			}
		}
		const string toString()()
		{
			import std.format.spec : singleSpec;
			auto app = appender!string
			{
			}
			();
			auto spec = singleSpec("%s");
			immutable len = _data ? _data.arr.length : 0;
			static if (isSomeString!A
			{
			}
			)
			{
				app.reserve(len + 25);
			}
			else
			{
				app.reserve(len * 3 + 25);
			}
			toString(app, spec);
			return app.data;
		}
		import std.format.spec : FormatSpec;
		const void toString(Writer)(ref Writer w, ref scope const FormatSpec!char
		{
		}
		 fmt) if (isOutputRange!(Writer, char)
		{
		}
		)
		{
			import std.format.write : formatValue;
			import std.range.primitives : put;
			put(w, Unqual!(typeof(this))
			{
			}
			.stringof);
			put(w, '(');
			formatValue(w, data, fmt);
			put(w, ')');
		}
	}

}
ElementEncodingType!string
{
	alias ElementEncodingType = immutable(char);

}
StringTypeOf!string
{
	alias StringTypeOf = string;

}
Unqual!(immutable(char), char)
{
	alias Unqual = char;

}
isMutable!(immutable(char))
{
	enum bool isMutable = false;

}
static __gshared TypeInfo_Struct _D44TypeInfo_S3std5array__T8AppenderTAyaZQo4Data6__initZ;
_d_arraysetlengthTImpl!(char[], char)
{
	import core.internal.array.utils : _d_HookTraceImpl;
	private enum string errorMessage = "Cannot resize arrays if compiling without support for runtime type information!";
	pure nothrow @trusted ulong _d_arraysetlengthT(ref return scope char[] arr, ulong newlength)
	{
		TypeInfo_Array ti = typeid(char[]);
		_d_arraysetlengthiT(ti, newlength, cast(void[]*)&arr);
		return arr.length;
	}
	alias _d_arraysetlengthTTrace = auto pure nothrow @trusted ulong _d_HookTraceImpl(string file, int line, string funcname, ref return scope char[] _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "char[]";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arraysetlengthT(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}
	;
}
_d_HookTraceImpl!(char[], _d_arraysetlengthT, "Cannot resize arrays if compiling without support for runtime type information!")
{
	auto pure nothrow @trusted ulong _d_HookTraceImpl(string file, int line, string funcname, ref return scope char[] _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "char[]";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arraysetlengthT(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}

}
Parameters!(_d_arraysetlengthT)
{
	alias Parameters = (ref return scope char[], ulong);

}
FunctionTypeOf!(_d_arraysetlengthT)
{
	alias pure nothrow @trusted ulong FunctionTypeOf(ref return scope char[] arr, ulong newlength);

}
appenderNewCapacity!1LU
{
	pure nothrow @nogc @safe ulong appenderNewCapacity(ulong curLen, ulong reqLen)
	{
		import core.bitop : bsr;
		import std.algorithm.comparison : max;
		if (curLen == 0LU)
			return max(reqLen, 8);
		ulong mult = 100LU + 1000LU / cast(ulong)(bsr(curLen * 1LU) + 1);
		if (mult > 200LU)
			mult = 200LU;
		ulong sugLen = (curLen * mult + 99LU) / 100LU;
		return max(reqLen, sugLen);
	}

}
CommonType!(ulong, int)
{
	alias CommonType = ulong;

}
max!(ulong, int)
{
	auto pure nothrow @nogc @safe ulong max(ulong _param_0, int _param_1)
	{
		alias a = ulong _param_0;
		;
		alias T0 = ulong;
		alias b = int _param_1;
		;
		alias T1 = int;
		alias Result = ulong;
		import std.functional : lessThan;
		immutable immutable(bool) chooseB = safeOp(_param_0, _param_1);
		return chooseB ? cast(ulong)_param_1 : _param_0;
	}

}
isNumeric!int
{
	enum bool isNumeric = true;

}
mostNegative!int
{
	enum int mostNegative = -2147483648;

}
Select!(false, int, ulong)
{
	alias Select = ulong;

}
safeOp!(ulong, int)
{
	pure nothrow @nogc @safe bool safeOp(ref ulong a, ref int b)
	{
		import std.traits : mostNegative;
		immutable immutable(bool) result = b >= 0 && unsafeOp(a, b);
		return result;
	}

}
isIntegral!int
{
	enum bool isIntegral = true;

}
unsafeOp!(ulong, int)
{
	pure nothrow @nogc @safe bool unsafeOp(ulong a, int b)
	{
		import std.traits : CommonType;
		alias T = ulong;
		return a < cast(ulong)b;
	}

}
CommonType!(ulong, ulong)
{
	alias CommonType = ulong;

}
max!(ulong, ulong)
{
	pure nothrow @nogc @safe ulong max(ulong a, ulong b)
	{
		return a < b ? b : a;
	}

}
mulu!()
{
	pure nothrow @nogc @safe ulong mulu(ulong x, ulong y, ref bool overflow)
	{
		immutable @nogc immutable(ulong) r = x * y;
		if ((x | y) >> 32 && x && (r / x != y))
			overflow = true;
		return r;
	}

}
blockAttribute!(immutable(char))
{
	enum BlkAttr blockAttribute = BlkAttr.NO_SCAN;

}
hasIndirections!(immutable(char))
{
	enum bool hasIndirections = false;

}
_hasIndirections!(immutable(char))
{
	enum bool hasIndirections = false;

}
isFunctionPointer!(immutable(char))
{
	enum bool isFunctionPointer = false;

}
isPointer!(immutable(char))
{
	enum bool isPointer = false;

}
isAggregateType!(immutable(char))
{
	enum bool isAggregateType = false;

}
isDelegate!(immutable(char))
{
	enum bool isDelegate = false;

}
isDynamicArray!(immutable(char))
{
	enum bool isDynamicArray = false;

}
OriginalType!(immutable(char))
{
	alias OriginalType = immutable(char);

}
ModifyTypePreservingTQ!(Impl, immutable(char))
{
	alias ModifyTypePreservingTQ = immutable immutable(char);

}
Modifier!char
{
	alias Impl = char;

}
isSomeChar!string
{
	enum bool isSomeChar = false;

}
isSomeString!string
{
	enum bool isSomeString = true;

}
canPutItem!string
{
	enum bool canPutItem = false;

}
Unqual!(string, string)
{
	alias Unqual = string;

}
isImplicitlyConvertible!(string, char)
{
	enum bool isImplicitlyConvertible = false;

}
isSomeChar!(immutable(char))
{
	enum bool isSomeChar = true;

}
canPutConstRange!string
{
	enum bool canPutConstRange = false;

}
isInputRange!string
{
	enum bool isInputRange = true;

}
empty!string
{
	pure nothrow @nogc @property @safe bool empty(ref scope string a)
	{
		return !a.length;
	}

}
isCallable!(function (string r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (string r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (string r) pure nothrow @nogc @safe => empty(r))
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (string r) pure nothrow @nogc @safe => empty(r))
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(string r);

}
isCallable!(function (string r) pure @safe => front(cast(const(char)[])r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (string r) pure @safe => front(cast(const(char)[])r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (string r) pure @safe => front(cast(const(char)[])r))
{
	alias ReturnType = dchar;

}
FunctionTypeOf!(function (string r) pure @safe => front(cast(const(char)[])r))
{
	alias pure @safe dchar FunctionTypeOf(string r);

}
canPutItem!dchar
{
	enum bool canPutItem = true;

}
Unqual!(dchar, dchar)
{
	alias Unqual = dchar;

}
isImplicitlyConvertible!(dchar, char)
{
	enum bool isImplicitlyConvertible = false;

}
canPutConstRange!dchar
{
	enum bool canPutConstRange = false;

}
isInputRange!dchar
{
	enum bool isInputRange = false;

}
canPutRange!dchar
{
	enum bool canPutRange = false;

}
put!dchar
{
	pure @safe void put(dchar item)
	{
		import std.utf : encode;
		char[4] encoded = '\xff';
		ulong len = encode(encoded, item);
		this.put(encoded[0..len]);
	}

}
encode!Flag.no
{
	pure @safe ulong encode(out char[4] buf, dchar c)
	{
		buf[] = '\xff';
		if (cast(uint)c <= 127u)
		{
			assert(isValidDchar(c));
			buf[0] = cast(char)c;
			return 1LU;
		}
		if (cast(uint)c <= 2047u)
		{
			assert(isValidDchar(c));
			buf[0] = cast(char)(192u | cast(uint)c >> 6);
			buf[1] = cast(char)(128u | cast(uint)c & 63u);
			return 2LU;
		}
		if (cast(uint)c <= 65535u)
		{
			if (55296u <= cast(uint)c && (cast(uint)c <= 57343u))
				c = _utfException("Encoding a surrogate code point in UTF-8", c);
			assert(isValidDchar(c));
			L3:
			buf[0] = cast(char)(224u | cast(uint)c >> 12);
			buf[1] = cast(char)(128u | cast(uint)c >> 6 & 63u);
			buf[2] = cast(char)(128u | cast(uint)c & 63u);
			return 3LU;
		}
		if (cast(uint)c <= 1114111u)
		{
			assert(isValidDchar(c));
			buf[0] = cast(char)(240u | cast(uint)c >> 18);
			buf[1] = cast(char)(128u | cast(uint)c >> 12 & 63u);
			buf[2] = cast(char)(128u | cast(uint)c >> 6 & 63u);
			buf[3] = cast(char)(128u | cast(uint)c & 63u);
			return 4LU;
		}
		assert(!isValidDchar(c));
		c = _utfException("Encoding an invalid code point in UTF-8", c);
		goto L3;
	}

}
canPutItem!(char[])
{
	enum bool canPutItem = false;

}
Unqual!(char[], char[])
{
	alias Unqual = char[];

}
isImplicitlyConvertible!(char[], char)
{
	enum bool isImplicitlyConvertible = false;

}
isSomeChar!(char[])
{
	enum bool isSomeChar = false;

}
canPutConstRange!(char[])
{
	enum bool canPutConstRange = false;

}
canPutRange!(char[])
{
	enum bool canPutRange = true;

}
put!(char[])
{
	pure nothrow @safe void put(char[] items)
	{
		auto pure nothrow @safe char[] bigDataFun(ulong extra)
		{
			this.ensureAddable(extra);
			return delegate () pure nothrow @nogc @trusted => (cast(char*)(*this._data).arr)[0..(*this._data).arr.length + extra]();
		}
		char[] bigData = bigDataFun(items.length);
		immutable immutable(ulong) len = (*this._data).arr.length;
		immutable immutable(ulong) newlen = bigData.length;
		alias UT = char;
		bigData[len..newlen] = items[];
		(*this._data).arr = bigData;
	}

}
hasElaborateAssign!char
{
	enum bool hasElaborateAssign = false;

}
isStaticArray!char
{
	enum bool isStaticArray = false;

}
isAssignable!(char, char)
{
	enum bool isAssignable = true;

}
isRvalueAssignable!(char, char)
{
	enum bool isRvalueAssignable = true;

}
lvalueOf!char
{
	@property ref char lvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
rvalueOf!char
{
	@property char rvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
isLvalueAssignable!(char, char)
{
	enum bool isLvalueAssignable = true;

}
canPutRange!string
{
	enum bool canPutRange = true;

}
put!string
{
	pure nothrow @safe void put(string items)
	{
		auto pure nothrow @safe char[] bigDataFun(ulong extra)
		{
			this.ensureAddable(extra);
			return delegate () pure nothrow @nogc @trusted => (cast(char*)(*this._data).arr)[0..(*this._data).arr.length + extra]();
		}
		char[] bigData = bigDataFun(items.length);
		immutable immutable(ulong) len = (*this._data).arr.length;
		immutable immutable(ulong) newlen = bigData.length;
		alias UT = char;
		bigData[len..newlen] = items[];
		(*this._data).arr = bigData;
	}

}
ElementType!string
{
	alias ElementType = dchar;

}
isAssignable!(char, immutable(char))
{
	enum bool isAssignable = true;

}
isRvalueAssignable!(char, immutable(char))
{
	enum bool isRvalueAssignable = true;

}
rvalueOf!(immutable(char))
{
	@property immutable(char) rvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
isLvalueAssignable!(char, immutable(char))
{
	enum bool isLvalueAssignable = true;

}
lvalueOf!(immutable(char))
{
	@property ref immutable(char) lvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
canPutItem!(const(char)[])
{
	enum bool canPutItem = false;

}
Unqual!(const(char)[], const(char)[])
{
	alias Unqual = const(char)[];

}
isImplicitlyConvertible!(const(char)[], char)
{
	enum bool isImplicitlyConvertible = false;

}
canPutConstRange!(const(char)[])
{
	enum bool canPutConstRange = false;

}
canPutRange!(const(char)[])
{
	enum bool canPutRange = true;

}
put!(const(char)[])
{
	pure nothrow @safe void put(const(char)[] items)
	{
		auto pure nothrow @safe char[] bigDataFun(ulong extra)
		{
			this.ensureAddable(extra);
			return delegate () pure nothrow @nogc @trusted => (cast(char*)(*this._data).arr)[0..(*this._data).arr.length + extra]();
		}
		char[] bigData = bigDataFun(items.length);
		immutable immutable(ulong) len = (*this._data).arr.length;
		immutable immutable(ulong) newlen = bigData.length;
		alias UT = char;
		bigData[len..newlen] = items[];
		(*this._data).arr = bigData;
	}

}
isAssignable!(char, const(char))
{
	enum bool isAssignable = true;

}
isRvalueAssignable!(char, const(char))
{
	enum bool isRvalueAssignable = true;

}
rvalueOf!(const(char))
{
	@property const(char) rvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
isLvalueAssignable!(char, const(char))
{
	enum bool isLvalueAssignable = true;

}
lvalueOf!(const(char))
{
	@property ref const(char) lvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
opDispatch!"doCount"
{
	enum Flag opDispatch = Flag.no;

}
Flag!"doCount"
{
	enum Flag : bool
	{
		Flag no = cast(Flag)false,
		Flag yes = cast(Flag)true,
	}

}
isFloatingPoint!int
{
	enum bool isFloatingPoint = false;

}
staticIndexOf!(immutable(int), immutable(dchar), immutable(char))
{
	enum int staticIndexOf = -1;

}
isSame!(immutable(int), immutable(dchar))
{
	enum bool isSame = false;

}
isSame!(immutable(int), immutable(char))
{
	enum bool isSame = false;

}
isDynamicArray!int
{
	enum bool isDynamicArray = false;

}
isExactSomeString!(const(char)[])
{
	enum bool isExactSomeString = true;

}
isStaticArray!int
{
	enum bool isStaticArray = false;

}
isAssociativeArray!int
{
	enum bool isAssociativeArray = false;

}
parse!(int, const(char)[], Flag.no)
{
	auto pure @safe int parse(ref scope const(char)[] s)
	{
		bool sign = false;
		enum char maxLastDigit = '\x07';
		uint c = 0u;
		import std.string : representation;
		const(ubyte)[] source = representation(s);
		ulong count = 0LU;
		if (empty(source))
			goto Lerr;
		c = cast(uint)front(source);
		switch (c)
		{
			case 45u:
			{
				sign = true;
				goto case 43u;
			}
			case 43u:
			{
				count += 1LU;
				popFront(source);
				if (empty(source))
					goto Lerr;
				c = cast(uint)front(source);
				break;
			}
			default:
			{
				break;
			}
		}
		c -= 48u;
		if (c <= 9u)
		{
			int v = cast(int)c;
			count += 1LU;
			popFront(source);
			for (; !empty(source);)
			{
				{
					c = cast(uint)(cast(int)front(source) - 48);
					if (c > 9u)
						break;
					if (v >= 0 && (v < 214748364 || v == 214748364 && (c <= cast(uint)(7 + cast(int)sign))))
					{
						v = cast(int)(cast(uint)(v * 10) + c);
						count += 1LU;
						popFront(source);
					}
					else
						throw new ConvOverflowException("Overflow in integral conversion", "/usr/include/dmd/phobos/std/conv.d", 2504LU);
				}
			}
			if (sign)
				v = -v;
			s = s[__dollar - source.length..__dollar];
			return v;
		}
		Lerr:
		throw convError(cast(const(char)[])source, "/usr/include/dmd/phobos/std/conv.d", 2524LU);
	}

}
isNarrowString!(const(char)[])
{
	enum bool isNarrowString = true;

}
opEquals!(CodepointInterval)
{
	const pure nothrow @nogc @safe bool opEquals(CodepointInterval val)
	{
		return this._tuple[0] == val._tuple[0] && (this._tuple[1] == val._tuple[1]);
	}

}
opEquals!()
{
	const pure nothrow @nogc @safe bool opEquals(const(CowArray!(GcPolicy)) rhs)
	{
		try
		{
			if (this.empty() ^ rhs.empty())
				return false;
			return this.empty() || __equals(this.data[0..__dollar - 1LU], rhs.data[0..__dollar - 1LU]);
		}
		finally
			rhs.~this();
	}

}
isDynamicArray!(uint[])
{
	enum bool isDynamicArray = true;

}
Unqual!(uint[], uint[])
{
	alias Unqual = uint[];

}
opEquals!(SliceOverIndexed!(Grapheme))
{
	const pure nothrow @nogc @safe bool opEquals(SliceOverIndexed!(Grapheme) arr)
	{
		if (arr.length() != this.length())
			return false;
		{
			ulong i = 0LU;
			for (; i < this.length(); i++)
			{
				if (cast(uint)this.opIndex(i) != cast(uint)arr.opIndex(i))
					return false;
			}
		}
		return true;
	}

}
representation!(const(char))
{
	auto pure nothrow @nogc @safe const(ubyte)[] representation(const(char)[] s)
	{
		import std.traits : ModifyTypePreservingTQ;
		template ToRepType(T)
		{
			alias ToRepType = AliasSeq!(ubyte, ushort, uint)
			{
			}
			[T.sizeof / 2];
		}
		return cast(const(ubyte)[])s;
	}

}
ModifyTypePreservingTQ!(ToRepType, const(char))
{
	alias ModifyTypePreservingTQ = const(ubyte);

}
_ModifyTypePreservingTQ!(ToRepType, const(char))
{
	alias ModifyTypePreservingTQ = const const(ubyte);

}
Modifier!char
{
	alias ToRepType = ubyte;

}
empty!(const(ubyte)[])
{
	pure nothrow @nogc @property @safe bool empty(ref scope const(ubyte)[] a)
	{
		return !a.length;
	}

}
isAutodecodableString!(ubyte[])
{
	enum bool isAutodecodableString = false;

}
front!ubyte
{
	pure nothrow @nogc @property ref @safe inout(ubyte) front(return scope inout(ubyte)[] a)
	{
		assert(a.length, "Attempting to fetch the front of an empty array of ubyte");
		return a[0];
	}

}
popFront!ubyte
{
	pure nothrow @nogc @safe void popFront(ref scope inout(ubyte)[] a)
	{
		assert(a.length, "Attempting to popFront() past the end of an array of ubyte");
		a = a[1..__dollar];
	}

}
convError!(const(char)[], int)
{
	auto pure @safe ConvException convError(const(char)[] source, string fn = __FILE__, ulong ln = cast(ulong)__LINE__)
	{
		string msg = null;
		if (empty(source))
			msg = "Unexpected end of input when converting from type const(char)[] to type int";
		else
		{
			dchar el = front(source);
			if (cast(uint)el == 10u)
				msg = text("Unexpected '\\n' when converting from type const(char)[] to type int");
			else
				msg = text("Unexpected '", el, "' when converting from type const(char)[] to type int");
		}
		return new ConvException(msg, fn, ln, null);
	}

}
text!string
{
	pure nothrow @nogc @safe string text(string _param_0)
	{
		return textImpl(_param_0);
	}

}
textImpl!(string, string)
{
	pure nothrow @nogc @safe string textImpl(string _param_0)
	{
		return to(_param_0);
	}

}
to!string
{
	T to(A...)(A args) if (A.length > 0)
	{
		return toImpl!T
		{
		}
		(args);
	}

}
isStaticArray!string
{
	enum bool isStaticArray = false;

}
isAggregateType!string
{
	enum bool isAggregateType = false;

}
to!string
{
	pure nothrow @nogc @safe string to(string _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(string, string)
{
	enum bool isImplicitlyConvertible = true;

}
isEnumStrToStr!(string, string)
{
	enum bool isEnumStrToStr = false;

}
isNullToStr!(string, string)
{
	enum bool isNullToStr = false;

}
isTuple!string
{
	enum bool isTuple = false;

}
isExactSomeString!string
{
	enum bool isExactSomeString = true;

}
toImpl!(string, string)
{
	pure nothrow @nogc @safe string toImpl(string value)
	{
		enum isSignedInt(T) = isIntegral!T
		{
		}
		 && isSigned!T
		{
		}
		;
		alias isUnsignedInt = template isUnsigned(T)
		{
			static if (!__traits(isUnsigned, T))
			{
				enum isUnsigned = false;
			}
			else
			{
				static if (is(T U == enum))
				{
					enum isUnsigned = isUnsigned!U
					{
					}
					;
				}
				else
				{
					enum isUnsigned = __traits(isZeroInit, T) && !is(immutable(T) == immutable(bool)) && !is(T == __vector);
				}
			}
		}
		;
		return value;
	}

}
isUnsignedInt!string
{
	enum bool isUnsigned = false;

}
isSignedInt!string
{
	enum bool isSignedInt = false;

}
isIntegral!string
{
	enum bool isIntegral = false;

}
text!(string, dchar, string)
{
	pure @safe string text(string _param_0, dchar _param_1, string _param_2)
	{
		return textImpl(_param_0, _param_1, _param_2);
	}

}
textImpl!(string, string, dchar, string)
{
	pure @safe string textImpl(string _param_0, dchar _param_1, string _param_2)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(60LU);
		app.put(_param_0);
		app.put(_param_1);
		app.put(_param_2);
		return app.data();
	}

}
text!(string, int, string)
{
	pure nothrow @safe string text(string _param_0, int _param_1, string _param_2)
	{
		return textImpl(_param_0, _param_1, _param_2);
	}

}
textImpl!(string, string, int, string)
{
	pure nothrow @safe string textImpl(string _param_0, int _param_1, string _param_2)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(60LU);
		app.put(_param_0);
		app.put(textImpl(_param_1));
		app.put(_param_2);
		return app.data();
	}

}
isSomeChar!int
{
	enum bool isSomeChar = false;

}
isSomeString!int
{
	enum bool isSomeString = false;

}
isInputRange!int
{
	enum bool isInputRange = false;

}
textImpl!(string, int)
{
	pure nothrow @safe string textImpl(int _param_0)
	{
		return to(_param_0);
	}

}
isAggregateType!int
{
	enum bool isAggregateType = false;

}
to!int
{
	pure nothrow @safe string to(int _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(int, string)
{
	enum bool isImplicitlyConvertible = false;

}
isInfinite!int
{
	enum bool isInfinite = false;

}
isCopyable!int
{
	enum bool isCopyable = true;

}
isNumeric!string
{
	enum bool isNumeric = false;

}
isBoolean!string
{
	enum bool isBoolean = false;

}
toImpl!(string, int)
{
	pure nothrow @safe string toImpl(int value)
	{
		return toImpl(value, 10u, LetterCase.upper);
	}

}
isExactSomeString!int
{
	enum bool isExactSomeString = false;

}
isSomeFiniteCharInputRange!int
{
	enum bool isSomeFiniteCharInputRange = false;

}
toImpl!(string, int)
{
	pure nothrow @trusted string toImpl(int value, uint radix, LetterCase letterCase = LetterCase.upper)
	in
	{
		assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
	}
	do
	{
		{
			{
				assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
			}
		}
		alias EEType = char;
		T toStringRadixConvert(ulong bufLen)(uint runtimeRadix = 0)
		{
			Unsigned!(Unqual!S
			{
			}
			)
			{
			}
			 div = void, mValue = unsigned(value);
			size_t index = bufLen;
			EEType[bufLen] buffer = void;
			char baseChar = letterCase == LetterCase.lower ? 'a' : 'A';
			char mod = void;
			do
			{
				div = cast(S)(mValue / runtimeRadix);
				mod = cast(ubyte)(mValue % runtimeRadix);
				mod += mod < 10 ? '0' : baseChar - 10;
				buffer[--index] = cast(char)mod;
				mValue = div;
			}
			while (mValue);
			return cast(T)buffer[index..__dollar].dup;
		}
		import std.array : array;
		switch (radix)
		{
			case 10u:
			{
				return array(toChars(value + 0));
			}
			case 16u:
			{
				if (cast(int)letterCase == 0)
					return array(toChars(unsigned(unsigned(value) + 0u)));
				else
					return array(toChars(unsigned(unsigned(value) + 0u)));
			}
			case 2u:
			{
				return array(toChars(unsigned(unsigned(value) + 0u)));
			}
			case 8u:
			{
				return array(toChars(unsigned(unsigned(value) + 0u)));
			}
			default:
			{
				return toStringRadixConvert(radix);
			}
		}
	}

}
toChars!(10, char, LetterCase.lower, int)
{
	auto pure nothrow @nogc @safe Result toChars(int value)
	{
		alias UT = int;
		static struct Result
		{
			pure nothrow @nogc @safe void initialize(int value)
			{
				bool neg = false;
				if (value < 10)
				{
					if (value >= 0)
					{
						this.lwr = 0u;
						this.upr = 1u;
						this.buf[0] = cast(char)(cast(uint)value + 48u);
						return ;
					}
					value = -value;
					neg = true;
				}
				uint i = 10u;
				for (; cast(uint)value >= 10u;)
				{
					{
						this.buf[cast(ulong)i] = cast(char)cast(ubyte)(48u + cast(uint)value % 10u);
						value = cast(int)(unsigned(value) / 10u);
						i -= 1u;
					}
				}
				this.buf[cast(ulong)i] = cast(char)(cast(uint)value + 48u);
				if (neg)
				{
					this.buf[cast(ulong)(i - 1u)] = '-';
					i -= 1u;
				}
				this.lwr = i;
				this.upr = 11u;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)(this.upr - this.lwr);
			}
			alias opDollar = pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)(this.upr - this.lwr);
			}
			;
			pure nothrow @nogc @property @safe bool empty()
			{
				return this.upr == this.lwr;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.buf[cast(ulong)this.lwr];
			}
			pure nothrow @nogc @safe void popFront()
			{
				this.lwr += 1u;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.buf[cast(ulong)(this.upr - 1u)];
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.upr -= 1u;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				return this.buf[cast(ulong)this.lwr + i];
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.buf = this.buf;
				result.lwr = cast(uint)(cast(ulong)this.lwr + lwr);
				result.upr = cast(uint)(cast(ulong)this.lwr + upr);
				return result;
			}
			private
			{
				uint lwr = void;
				uint upr = void;
				char[11] buf = void;
			}
		}
		Result result = 0;
		result.initialize(value);
		return result;
	}

}
Unqual!(int, int)
{
	alias Unqual = int;

}
isSigned!int
{
	enum bool isSigned = true;

}
Unsigned!int
{
	alias Unsigned = uint;

}
OriginalType!int
{
	alias OriginalType = int;

}
_OriginalType!int
{
	alias OriginalType = int;

}
ModifyTypePreservingTQ!(Impl, int)
{
	alias ModifyTypePreservingTQ = int;

}
Modifier!int
{
	alias Impl = int;

}
ModifyTypePreservingTQ!(Impl, int)
{
	alias ModifyTypePreservingTQ = uint;

}
_ModifyTypePreservingTQ!(Impl, int)
{
	alias ModifyTypePreservingTQ = uint;

}
Modifier!int
{
	alias Impl = uint;

}
isUnsigned!int
{
	enum bool isUnsigned = false;

}
unsigned!int
{
	auto pure nothrow @nogc @safe uint unsigned(int x)
	{
		return cast(uint)x;
	}

}
Unqual!(uint, uint)
{
	alias Unqual = uint;

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r153 = r;
				for (; !__r153.empty(); __r153.popFront())
				{
					char e = __r153.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r159 = r;
				for (; !__r159.empty(); __r159.popFront())
				{
					char e = __r159.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
isCallable!(char function(inout(int)) pure nothrow @nogc @safe)
{
	enum bool isCallable = true;

}
isSomeFunction!(char function(inout(int)) pure nothrow @nogc @safe)
{
	enum bool isSomeFunction = true;

}
ReturnType!(char function(inout(int)) pure nothrow @nogc @safe)
{
	alias ReturnType = char;

}
FunctionTypeOf!(char function(inout(int)) pure nothrow @nogc @safe)
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(inout(int));

}
_d_arrayappendcTXImpl!(char[], char)
{
	import core.internal.array.utils : _d_HookTraceImpl;
	private enum string errorMessage = "Cannot append to array if compiling without support for runtime type information!";
	pure nothrow ref @trusted char[] _d_arrayappendcTX(return ref scope char[] px, ulong n)
	{
		TypeInfo_Array ti = typeid(char[]);
		byte[] pxx = (cast(byte*)cast(char*)px)[0..px.length];
		_d_arrayappendcTX(ti, pxx, n);
		px = (cast(char*)cast(byte*)pxx)[0..pxx.length];
		return px;
	}
	alias _d_arrayappendcTXTrace = auto pure nothrow @trusted char[] _d_HookTraceImpl(string file, int line, string funcname, return ref scope char[] _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "char[]";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arrayappendcTX(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}
	;
}
_d_HookTraceImpl!(char[], _d_arrayappendcTX, "Cannot append to array if compiling without support for runtime type information!")
{
	auto pure nothrow @trusted char[] _d_HookTraceImpl(string file, int line, string funcname, return ref scope char[] _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "char[]";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arrayappendcTX(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}

}
Parameters!(_d_arrayappendcTX)
{
	alias Parameters = (return ref scope char[], ulong);

}
FunctionTypeOf!(_d_arrayappendcTX)
{
	alias pure nothrow ref @trusted char[] FunctionTypeOf(return ref scope char[] px, ulong n);

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
isDynamicArray!(char[])
{
	enum bool isDynamicArray = true;

}
allSatisfy!(isIntegral, const(ulong))
{
	enum bool allSatisfy = true;

}
F!(const(ulong))
{
	enum bool isIntegral = true;

}
hasIndirections!char
{
	enum bool hasIndirections = false;

}
_hasIndirections!char
{
	enum bool hasIndirections = false;

}
isFunctionPointer!char
{
	enum bool isFunctionPointer = false;

}
isPointer!char
{
	enum bool isPointer = false;

}
isAggregateType!char
{
	enum bool isAggregateType = false;

}
isDelegate!char
{
	enum bool isDelegate = false;

}
isDynamicArray!char
{
	enum bool isDynamicArray = false;

}
OriginalType!char
{
	alias OriginalType = char;

}
ModifyTypePreservingTQ!(Impl, char)
{
	alias ModifyTypePreservingTQ = char;

}
Modifier!char
{
	alias Impl = char;

}
uninitializedArray!(char[], const(ulong))
{
	auto pure nothrow @trusted char[] uninitializedArray(const(ulong) _param_0)
	{
		enum isSize_t(E) = is(E : size_t);
		template toSize_t(E)
		{
			alias toSize_t = size_t;
		}
		alias ST = (ulong);
		return arrayAllocImpl(_param_0);
	}

}
allSatisfy!(isSize_t, const(ulong))
{
	enum bool allSatisfy = true;

}
F!(const(ulong))
{
	enum bool isSize_t = true;

}
staticMap!(toSize_t, const(ulong))
{
	staticMap
}
fun!(const(ulong))
{
	alias toSize_t = ulong;

}
arrayAllocImpl!(false, char[], ulong)
{
	auto pure nothrow @system char[] arrayAllocImpl(ulong _param_0)
	{
		alias E = char;
		char[] ret = null;
		alias size = ulong _param_0;
		;
		if (__ctfe)
		{
			ret = new char[](_param_0);
		}
		else
		{
			import core.stdc.string : memset;
			*& ret = _d_newarrayU(typeid(char[]), _param_0);
		}
		return ret;
	}

}
nDimensions!(char[])
{
	enum int nDimensions = 1;

}
isArray!(char[])
{
	enum bool isArray = true;

}
isStaticArray!(char[])
{
	enum bool isStaticArray = false;

}
nDimensions!char
{
	enum int nDimensions = 0;

}
isArray!char
{
	enum bool isArray = false;

}
isDynamicArray!char
{
	enum bool isDynamicArray = false;

}
emplaceRef!(char, char, char)
{
	pure nothrow @nogc @safe void emplaceRef(ref char chunk, ref char _param_1)
	{
		static struct S
		{
			char payload;
			this()(auto ref Args args)
			{
				static if (__traits(compiles, payload = forward!args
				{
				}
				))
				{
					payload = forward!args
					{
					}
					;
				}
				else
				{
					payload = T(forward!args
					{
					}
					);
				}
			}
		}
		if (__ctfe)
		{
			chunk = _param_1;
		}
		else
		{
			S* p = delegate () pure nothrow @nogc @trusted => cast(S*)&chunk();
			emplaceInitializer(*p);
			(*p).this(_param_1);
		}
	}

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
forward!(_param_1)
{
	ref char _param_1;

}
fwd!(_param_1)
{
	ref char _param_1;

}
emplaceInitializer!(S)
{
	pure nothrow @nogc @trusted void emplaceInitializer(ref S chunk)
	{
		import core.internal.traits : hasElaborateAssign;
		chunk = S('\xff');
	}

}
hasElaborateAssign!(S)
{
	enum bool hasElaborateAssign = false;

}
Fields!(S)
{
	alias Fields = (char);

}
anySatisfy!(hasElaborateAssign, char)
{
	enum bool anySatisfy = false;

}
F!char
{
	enum bool hasElaborateAssign = false;

}
__ctor!()
{
	pure nothrow @nogc @safe this(ref char _param_0)
	{
		this.payload = _param_0;
		return this;
	}

}
forward!(_param_0)
{
	ref char _param_0;

}
fwd!(_param_0)
{
	ref char _param_0;

}
emplaceInitializer!char
{
	pure nothrow @nogc @trusted void emplaceInitializer(ref char chunk)
	{
		import core.internal.traits : hasElaborateAssign;
		chunk = '\xff';
	}

}
isIntegral!uint
{
	enum bool isIntegral = true;

}
isSomeChar!uint
{
	enum bool isSomeChar = false;

}
unsigned!uint
{
	auto pure nothrow @nogc @safe uint unsigned(uint x)
	{
		return x;
	}

}
Unsigned!uint
{
	alias Unsigned = uint;

}
OriginalType!uint
{
	alias OriginalType = uint;

}
_OriginalType!uint
{
	alias OriginalType = uint;

}
ModifyTypePreservingTQ!(Impl, uint)
{
	alias ModifyTypePreservingTQ = uint;

}
Modifier!uint
{
	alias Impl = uint;

}
ModifyTypePreservingTQ!(Impl, uint)
{
	alias ModifyTypePreservingTQ = uint;

}
_ModifyTypePreservingTQ!(Impl, uint)
{
	alias ModifyTypePreservingTQ = uint;

}
Modifier!uint
{
	alias Impl = uint;

}
isUnsigned!uint
{
	enum bool isUnsigned = true;

}
toChars!(16, char, LetterCase.upper, uint)
{
	auto pure nothrow @nogc @safe Result toChars(uint value)
	{
		alias UT = uint;
		enum int SHIFT = 4;
		static struct Result
		{
			pure nothrow @nogc @safe this(uint value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 4;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 4;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 4LU) & 15u);
				return cast(int)c < 10 ? cast(char)(cast(int)c + 48) : cast(char)(cast(int)c + 65 - 10);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 4LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				uint value;
				ubyte len;
			}
		}
		return Result(0u, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r166 = r;
				for (; !__r166.empty(); __r166.popFront())
				{
					char e = __r166.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r167 = r;
				for (; !__r167.empty(); __r167.popFront())
				{
					char e = __r167.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toChars!(16, char, LetterCase.lower, uint)
{
	auto pure nothrow @nogc @safe Result toChars(uint value)
	{
		alias UT = uint;
		enum int SHIFT = 4;
		static struct Result
		{
			pure nothrow @nogc @safe this(uint value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 4;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 4;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 4LU) & 15u);
				return cast(int)c < 10 ? cast(char)(cast(int)c + 48) : cast(char)(cast(int)c + 97 - 10);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 4LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				uint value;
				ubyte len;
			}
		}
		return Result(0u, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r173 = r;
				for (; !__r173.empty(); __r173.popFront())
				{
					char e = __r173.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r174 = r;
				for (; !__r174.empty(); __r174.popFront())
				{
					char e = __r174.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toChars!(2, char, LetterCase.lower, uint)
{
	auto pure nothrow @nogc @safe Result toChars(uint value)
	{
		alias UT = uint;
		enum int SHIFT = 1;
		static struct Result
		{
			pure nothrow @nogc @safe this(uint value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 1;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 1;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 1LU) & 1u);
				return cast(char)(cast(int)c + 48);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 1LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				uint value;
				ubyte len;
			}
		}
		return Result(0u, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r180 = r;
				for (; !__r180.empty(); __r180.popFront())
				{
					char e = __r180.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r181 = r;
				for (; !__r181.empty(); __r181.popFront())
				{
					char e = __r181.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toChars!(8, char, LetterCase.lower, uint)
{
	auto pure nothrow @nogc @safe Result toChars(uint value)
	{
		alias UT = uint;
		enum int SHIFT = 3;
		static struct Result
		{
			pure nothrow @nogc @safe this(uint value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 3;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 3;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 3LU) & 7u);
				return cast(char)(cast(int)c + 48);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 3LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				uint value;
				ubyte len;
			}
		}
		return Result(0u, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r187 = r;
				for (; !__r187.empty(); __r187.popFront())
				{
					char e = __r187.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r188 = r;
				for (; !__r188.empty(); __r188.popFront())
				{
					char e = __r188.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toStringRadixConvert!24LU
{
	pure nothrow @system string toStringRadixConvert(uint runtimeRadix = 0u)
	{
		uint div = void;
		uint mValue = unsigned(value);
		ulong index = 24LU;
		char[24] buffer = void;
		char baseChar = cast(int)letterCase == 1 ? 'a' : 'A';
		char mod = void;
		do
		{
			div = cast(uint)cast(int)(mValue / runtimeRadix);
			mod = cast(char)cast(ubyte)(mValue % runtimeRadix);
			cast(int)mod += cast(int)mod < 10 ? 48 : cast(int)baseChar - 10;
			buffer[index -= 1LU] = mod;
			mValue = div;
		}
		while (mValue);
		return cast(string)dup(buffer[index..24]);
	}

}
dup!char
{
	pure nothrow @property @safe char[] dup(const(char)[] a)
	{
		import core.internal.array.duplication : _dup;
		return _dup(a);
	}

}
_dup!(const(char), char)
{
	pure nothrow @trusted char[] _dup(scope const(char)[] a)
	{
		if (__ctfe)
			return _dupCtfe(a);
		import core.stdc.string : memcpy;
		void[] arr = _d_newarrayU(typeid(const(char)[]), a.length);
		memcpy(cast(void*)arr, cast(const(void)*)cast(const(char)*)a, 1LU * a.length);
		return *& arr;
	}

}
_dupCtfe!(const(char), char)
{
	pure nothrow @safe char[] _dupCtfe(scope const(char)[] a)
	{
		char[] res = null;
		{
			const(char)[] __r191 = a[];
			ulong __key192 = 0LU;
			for (; __key192 < __r191.length; __key192 += 1LU)
			{
				const ref const(char) e = __r191[__key192];
				(ref char __appendtmp193 = e;) , (_d_arrayappendcTX(res, 1LU) , res[res.length - 1LU] = __appendtmp193 , res);
			}
		}
		return res;
	}

}
isFloatingPoint!uint
{
	enum bool isFloatingPoint = false;

}
staticIndexOf!(immutable(uint), immutable(dchar), immutable(char))
{
	enum int staticIndexOf = -1;

}
isSame!(immutable(uint), immutable(dchar))
{
	enum bool isSame = false;

}
isSame!(immutable(uint), immutable(char))
{
	enum bool isSame = false;

}
isDynamicArray!uint
{
	enum bool isDynamicArray = false;

}
isStaticArray!uint
{
	enum bool isStaticArray = false;

}
isAssociativeArray!uint
{
	enum bool isAssociativeArray = false;

}
parse!(uint, const(char)[], Flag.no)
{
	auto pure @safe uint parse(ref scope const(char)[] s)
	{
		enum bool sign = false;
		enum char maxLastDigit = '\x05';
		uint c = 0u;
		import std.string : representation;
		const(ubyte)[] source = representation(s);
		ulong count = 0LU;
		if (empty(source))
			goto Lerr;
		c = cast(uint)front(source);
		c -= 48u;
		if (c <= 9u)
		{
			uint v = c;
			count += 1LU;
			popFront(source);
			for (; !empty(source);)
			{
				{
					c = cast(uint)(cast(int)front(source) - 48);
					if (c > 9u)
						break;
					if (v >= 0u && (v < 429496729u || v == 429496729u && (c <= 5u)))
					{
						v = v * 10u + c;
						count += 1LU;
						popFront(source);
					}
					else
						throw new ConvOverflowException("Overflow in integral conversion", "/usr/include/dmd/phobos/std/conv.d", 2504LU);
				}
			}
			if (false)
				v = -v;
			s = s[__dollar - source.length..__dollar];
			return v;
		}
		Lerr:
		throw convError(cast(const(char)[])source, "/usr/include/dmd/phobos/std/conv.d", 2524LU);
	}

}
convError!(const(char)[], uint)
{
	auto pure @safe ConvException convError(const(char)[] source, string fn = __FILE__, ulong ln = cast(ulong)__LINE__)
	{
		string msg = null;
		if (empty(source))
			msg = "Unexpected end of input when converting from type const(char)[] to type uint";
		else
		{
			dchar el = front(source);
			if (cast(uint)el == 10u)
				msg = text("Unexpected '\\n' when converting from type const(char)[] to type uint");
			else
				msg = text("Unexpected '", el, "' when converting from type const(char)[] to type uint");
		}
		return new ConvException(msg, fn, ln, null);
	}

}
enforce!ulong
{
	pure @safe ulong enforce(ulong value, lazy const(char)[] msg = null, string file = __FILE__, ulong line = cast(ulong)__LINE__)
	{
		if (!value)
			bailOut(file, line, msg());
		return value;
	}

}
isInputRange!char
{
	enum bool isInputRange = false;

}
binaryFun!("a == b", "a", "b")
{
	auto binaryFun(ElementType1, ElementType2)(auto ref ElementType1 __a, auto ref ElementType2 __b)
	{
		mixin("alias " ~ parm1Name ~ " = __a ;");
		mixin("alias " ~ parm2Name ~ " = __b ;");
		return mixin(fun);
	}

}
binaryFun!(dchar, char)
{
	auto pure nothrow @nogc @safe bool binaryFun(dchar __a, ref char __b)
	{
		alias a = dchar __a;
		;
		alias b = ref char __b;
		;
		return cast(uint)__a == cast(uint)cast(int)__b;
	}

}
startsWith!("a == b", const(char)[], char)
{
	pure nothrow @nogc @safe bool startsWith(const(char)[] doesThisStart, char withThis)
	{
		if (empty(doesThisStart))
			return false;
		enum bool isDefaultPred = true;
		alias predFunc = auto binaryFun(ElementType1, ElementType2)(auto ref ElementType1 __a, auto ref ElementType2 __b)
		{
			mixin("alias " ~ parm1Name ~ " = __a ;");
			mixin("alias " ~ parm2Name ~ " = __b ;");
			return mixin(fun);
		}
		;
		return cast(int)doesThisStart[0] == cast(int)withThis;
	}

}
to!ubyte
{
	T to(A...)(A args) if (A.length > 0)
	{
		return toImpl!T
		{
		}
		(args);
	}

}
isStaticArray!(const(uint))
{
	enum bool isStaticArray = false;

}
isAggregateType!(const(uint))
{
	enum bool isAggregateType = false;

}
to!(const(uint))
{
	pure @safe ubyte to(const(uint) _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(const(uint), ubyte)
{
	enum bool isImplicitlyConvertible = false;

}
isTuple!ubyte
{
	enum bool isTuple = false;

}
isInfinite!(const(uint))
{
	enum bool isInfinite = false;

}
isInputRange!(const(uint))
{
	enum bool isInputRange = false;

}
isExactSomeString!ubyte
{
	enum bool isExactSomeString = false;

}
isSomeString!ubyte
{
	enum bool isSomeString = false;

}
isNumeric!(const(uint))
{
	enum bool isNumeric = true;

}
isNumeric!ubyte
{
	enum bool isNumeric = true;

}
isSomeString!(const(uint))
{
	enum bool isSomeString = false;

}
isDynamicArray!(const(uint))
{
	enum bool isDynamicArray = false;

}
isAssociativeArray!(const(uint))
{
	enum bool isAssociativeArray = false;

}
isSomeChar!ubyte
{
	enum bool isSomeChar = false;

}
toImpl!(ubyte, const(uint))
{
	pure @safe ubyte toImpl(const(uint) value)
	{
		enum byte sSmallest = cast(byte)0;
		enum byte tSmallest = cast(byte)0;
		if (value > 255u)
			throw new ConvOverflowException("Conversion positive overflow", "/usr/include/dmd/phobos/std/conv.d", 1563LU);
		return (*function (ref const(uint) value) pure nothrow @nogc @trusted => cast(ubyte)value)(value);
	}

}
isFloatingPoint!(const(uint))
{
	enum bool isFloatingPoint = false;

}
mostNegative!(const(uint))
{
	enum byte mostNegative = cast(byte)0;

}
mostNegative!ubyte
{
	enum byte mostNegative = cast(byte)0;

}
__lambda4!(const(uint))
{
	function (ref const(uint) value) pure nothrow @nogc @trusted => cast(ubyte)value
}
isIntegral!ubyte
{
	enum bool isIntegral = true;

}
isFloatingPoint!ubyte
{
	enum bool isFloatingPoint = false;

}
staticIndexOf!(immutable(ubyte), immutable(dchar), immutable(char))
{
	enum int staticIndexOf = -1;

}
isSame!(immutable(ubyte), immutable(dchar))
{
	enum bool isSame = false;

}
isSame!(immutable(ubyte), immutable(char))
{
	enum bool isSame = false;

}
isDynamicArray!ubyte
{
	enum bool isDynamicArray = false;

}
isStaticArray!ubyte
{
	enum bool isStaticArray = false;

}
isAssociativeArray!ubyte
{
	enum bool isAssociativeArray = false;

}
parse!(ubyte, const(char)[], Flag.no)
{
	auto pure @safe ubyte parse(ref scope const(char)[] s)
	{
		Tuple!(uint, "data", ulong, "count") v = parse(s);
		ubyte result = delegate () pure nothrow @nogc @trusted => cast(ubyte)v.__expand_field_0();
		if (cast(uint)cast(int)result == v.__expand_field_0)
		{
			return result;
		}
		throw new ConvOverflowException("Overflow in integral conversion", "/usr/include/dmd/phobos/std/conv.d", 2426LU);
	}

}
Select!(false, int, uint)
{
	alias Select = uint;

}
opDispatch!"doCount"
{
	enum Flag opDispatch = Flag.yes;

}
parse!(uint, const(char)[], Flag.yes)
{
	auto pure @safe Tuple!(uint, "data", ulong, "count") parse(ref scope const(char)[] s)
	{
		enum bool sign = false;
		enum char maxLastDigit = '\x05';
		uint c = 0u;
		import std.string : representation;
		const(ubyte)[] source = representation(s);
		ulong count = 0LU;
		if (empty(source))
			goto Lerr;
		c = cast(uint)front(source);
		c -= 48u;
		if (c <= 9u)
		{
			uint v = c;
			count += 1LU;
			popFront(source);
			for (; !empty(source);)
			{
				{
					c = cast(uint)(cast(int)front(source) - 48);
					if (c > 9u)
						break;
					if (v >= 0u && (v < 429496729u || v == 429496729u && (c <= 5u)))
					{
						v = v * 10u + c;
						count += 1LU;
						popFront(source);
					}
					else
						throw new ConvOverflowException("Overflow in integral conversion", "/usr/include/dmd/phobos/std/conv.d", 2504LU);
				}
			}
			if (false)
				v = -v;
			s = s[__dollar - source.length..__dollar];
			return tuple(v, count);
		}
		Lerr:
		throw convError(cast(const(char)[])source, "/usr/include/dmd/phobos/std/conv.d", 2524LU);
	}

}
tuple!("data", "count")
{
	auto tuple(Args...)(Args args)
	{
		static if (Names.length == 0)
		{
			return Tuple!Args
			{
			}
			(args);
		}
		else
		{
			static if (!is(typeof(Names[0]) : string))
			{
				return Tuple!Names
				{
				}
				(args);
			}
			else
			{
				static assert(Names.length == Args.length, "Insufficient number of names given.");
				template Interleave(A...)
				{
					template and(B...) if (B.length == 1)
					{
						alias and = AliasSeq!(A[0], B[0])
						{
						}
						;
					}
					template and(B...) if (B.length != 1)
					{
						alias and = AliasSeq!(A[0], B[0], Interleave!(A[1 .. __dollar])
						{
						}
						.and!(B[1 .. __dollar])
						{
						}
						)
						{
						}
						;
					}
				}
				return Tuple!(Interleave!Args
				{
				}
				.and!Names
				{
				}
				)
				{
				}
				(args);
			}
		}
	}

}
tuple!(uint, ulong)
{
	auto pure nothrow @nogc @safe Tuple!(uint, "data", ulong, "count") tuple(uint _param_0, ulong _param_1)
	{
		template Interleave(A...)
		{
			template and(B...) if (B.length == 1)
			{
				alias and = AliasSeq!(A[0], B[0])
				{
				}
				;
			}
			template and(B...) if (B.length != 1)
			{
				alias and = AliasSeq!(A[0], B[0], Interleave!(A[1 .. __dollar])
				{
				}
				.and!(B[1 .. __dollar])
				{
				}
				)
				{
				}
				;
			}
		}
		return Tuple(0u, 0LU).this(_param_0, _param_1);
	}

}
Interleave!(uint, ulong)
{
	template and(B...) if (B.length == 1)
	{
		alias and = AliasSeq!(A[0], B[0])
		{
		}
		;
	}
	template and(B...) if (B.length != 1)
	{
		alias and = AliasSeq!(A[0], B[0], Interleave!(A[1 .. __dollar])
		{
		}
		.and!(B[1 .. __dollar])
		{
		}
		)
		{
		}
		;
	}
}
and!("data", "count")
{
	TList
}
Interleave!ulong
{
	template and(B...) if (B.length == 1)
	{
		alias and = AliasSeq!(A[0], B[0])
		{
		}
		;
	}
	template and(B...) if (B.length != 1)
	{
		alias and = AliasSeq!(A[0], B[0], Interleave!(A[1 .. __dollar])
		{
		}
		.and!(B[1 .. __dollar])
		{
		}
		)
		{
		}
		;
	}
}
and!"count"
{
	TList
}
distinctFieldNames!(uint, "data", ulong, "count")
{
	enum bool distinctFieldNames = true;

}
Tuple!(uint, "data", ulong, "count")
{
	struct Tuple
	{
		alias Types = (uint, ulong);
		private alias _Fields = Specs;
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		alias fieldNames = staticMap;
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		(uint, ulong) expand;
		mixin((*function () pure nothrow @safe => decl)());
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		static if (is(Specs))
		{
			alias expand this;
}
		else
		{
			inout pure nothrow @nogc @property ref @trusted inout(Tuple!(uint, ulong)) _Tuple_super() return
			{
				return *cast(inout(Tuple!(uint, ulong))*)&this.__expand_field_0;
			}
			alias _Tuple_super this;
}
		alias field = expand;
		static if (2LU > 0LU)
		{
			pure nothrow @nogc @safe this(uint _param_0, ulong _param_1)
			{
				tuple(this.__expand_field_0 = _param_0, this.__expand_field_1 = _param_1);
				return this;
			}
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		this(U, ulong n)(U[n] values) if (n == Types.length && allSatisfy!(isBuildableFrom!U
		{
		}
		, Types)
		{
		}
		)
		{
			static foreach (i; 0 .. Types.length)
			{
				field[i] = values[i];
			}
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		this(U)(U another) if (areBuildCompatibleTuples!(typeof(this), U)
		{
		}
		)
		{
			field[] = another.field[];
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		bool opEquals(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "==")
		{
		}
		)
		{
			return field[] == rhs.field[];
		}
		const bool opEquals(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "==")
		{
		}
		)
		{
			return field[] == rhs.field[];
		}
		bool opEquals(R...)(auto ref R rhs) if (R.length > 1 && areCompatibleTuples!(typeof(this), Tuple!R
		{
		}
		, "==")
		{
		}
		)
		{
			static foreach (i; 0 .. Types.length)
			{
				if (field[i] != rhs[i])
					return false;
			}
			return true;
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		auto opCmp(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "<")
		{
		}
		)
		{
			static foreach (i; 0 .. Types.length)
			{
				if (field[i] != rhs.field[i])
				{
					import std.math.traits : isNaN;
					static if (isFloatingPoint!(Types[i])
					{
					}
					)
					{
						if (isNaN(field[i]))
							return (float).nan;
					}

					static if (isFloatingPoint!(typeof(rhs.field[i]))
					{
					}
					)
					{
						if (isNaN(rhs.field[i]))
							return (float).nan;
					}

					static if (is(typeof(field[i].opCmp(rhs.field[i]))) && isFloatingPoint!(typeof(field[i].opCmp(rhs.field[i])))
					{
					}
					)
					{
						if (isNaN(field[i].opCmp(rhs.field[i])))
							return (float).nan;
					}

					return field[i] < rhs.field[i] ? -1 : 1;
				}
			}
			return 0;
		}
		auto const opCmp(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "<")
		{
		}
		)
		{
			static foreach (i; 0LU .. Types.length)
			{
				if (field[i] != rhs.field[i])
				{
					import std.math.traits : isNaN;
					static if (isFloatingPoint!(Types[i])
					{
					}
					)
					{
						if (isNaN(field[i]))
							return (float).nan;
					}

					static if (isFloatingPoint!(typeof(rhs.field[i]))
					{
					}
					)
					{
						if (isNaN(rhs.field[i]))
							return (float).nan;
					}

					static if (is(typeof(field[i].opCmp(rhs.field[i]))) && isFloatingPoint!(typeof(field[i].opCmp(rhs.field[i])))
					{
					}
					)
					{
						if (isNaN(field[i].opCmp(rhs.field[i])))
							return (float).nan;
					}

					return field[i] < rhs.field[i] ? -1 : 1;
				}
			}
			return 0;
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		auto opBinary(string op, T)(auto ref T t) if (op == "~" && !(is(T : U[], U) && isTuple!U
		{
		}
		))
		{
			static if (isTuple!T
			{
			}
			)
			{
				static assert(distinctFieldNames!(_Fields, T._Fields)
				{
				}
				, "Cannot concatenate tuples with duplicate fields: " ~ fieldNames.stringof ~ " - " ~ T.fieldNames.stringof);
				return Tuple!(_Fields, T._Fields)
				{
				}
				(expand, t.expand);
			}
			else
			{
				return Tuple!(_Fields, T)
				{
				}
				(expand, t);
			}
		}
		auto opBinaryRight(string op, T)(auto ref T t) if (op == "~" && !(is(T : U[], U) && isTuple!U
		{
		}
		))
		{
			static if (isTuple!T
			{
			}
			)
			{
				static assert(distinctFieldNames!(_Fields, T._Fields)
				{
				}
				, "Cannot concatenate tuples with duplicate fields: " ~ T.stringof ~ " - " ~ fieldNames.fieldNames.stringof);
				return Tuple!(T._Fields, _Fields)
				{
				}
				(t.expand, expand);
			}
			else
			{
				return Tuple!(T, _Fields)
				{
				}
				(t, expand);
			}
		}
		ref Tuple opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, "=")
		{
		}
		)
		{
			import std.algorithm.mutation : swap;
			static if (is(R : Tuple!Types
			{
			}
			) && !__traits(isRef, rhs) && isTuple!R
			{
			}
			)
			{
				if (__ctfe)
				{
					field[] = rhs.field[];
				}
				else
				{
					swap!(Tuple!Types
					{
					}
					)
					{
					}
					(this, rhs);
				}
			}
			else
			{
				field[] = rhs.field[];
			}
			return this;
		}
		inout ref rename(names...)() return if (names.length == 0 || allSatisfy!(isSomeString, typeof(names))
		{
		}
		)
		{
			import std.algorithm.comparison : equal;
			static if (names.length == 0 || equal([names], [fieldNames]))
			{
				return this;
			}
			else
			{
				enum nT = Types.length;
				enum nN = names.length;
				static assert(nN <= nT, "Cannot have more names than tuple members");
				alias allNames = AliasSeq!(names, fieldNames[nN .. __dollar])
				{
				}
				;
				import std.meta : Alias, aliasSeqOf;
				template GetItem(size_t idx)
				{
					import std.array : empty;
					static if (idx < nT)
					{
						alias GetItem = Alias!(Types[idx])
						{
						}
						;
					}
					else
					{
						static if (allNames[idx - nT].empty)
						{
							alias GetItem = AliasSeq!()
							{
							}
							;
						}
						else
						{
							alias GetItem = Alias!(allNames[idx - nT])
							{
							}
							;
						}
					}
				}
				import std.range : roundRobin, iota;
				alias NewTupleT = Tuple!(staticMap!(GetItem, aliasSeqOf!(roundRobin(iota(nT), iota(nT, 2 * nT)))
				{
				}
				)
				{
				}
				)
				{
				}
				;
				return *() @trusted => cast(NewTupleT*)&this();
			}
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		inout ref rename(alias translate)() if (is(typeof(translate) : V[K], V, K) && isSomeString!V
		{
		}
		 && (isSomeString!K
		{
		}
		 || is(K : size_t)))
		{
			import std.meta : aliasSeqOf;
			import std.range : ElementType;
			static if (isSomeString!(ElementType!(typeof(translate.keys))
			{
			}
			)
			{
			}
			)
			{
				{
					import std.conv : to;
					import std.algorithm.iteration : filter;
					import std.algorithm.searching : canFind;
					enum notFound = translate.keys.filter!((k) => fieldNames.canFind(k) == -1)
					{
					}
					;
					static assert(notFound.empty, "Cannot find members " ~ notFound.to!string
					{
					}
					 ~ " in type " ~ (typeof(this)).stringof);
				}
				return this.rename!(aliasSeqOf!(()
				{
					import std.array : empty;
					auto names = [fieldNames];
					foreach (ref n; names)
					{
						if (!n.empty)
							if (auto p = n in translate)
								n = *p;
					}
					return names;
				}
				())
				{
				}
				)
				{
				}
				;
			}
			else
			{
				{
					import std.algorithm.iteration : filter;
					import std.conv : to;
					enum invalid = translate.keys.filter!((k) => k < 0 || k >= this.length)
					{
					}
					;
					static assert(invalid.empty, "Indices " ~ invalid.to!string
					{
					}
					 ~ " are out of bounds for tuple with length " ~ this.length.to!string
					{
					}
					);
				}
				return this.rename!(aliasSeqOf!(()
				{
					auto names = [fieldNames];
					foreach (k, v; translate)
					{
						names[k] = v;
					}
					return names;
				}
				())
				{
				}
				)
				{
				}
				;
			}
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		static if (4LU == 0LU)
		{
			@system unittest;
		}
		static if (4LU == 0LU)
		{
			@system unittest;
		}
		inout @property ref @trusted inout(Tuple!(sliceSpecs!(from, to)
		{
		}
		)
		{
		}
		) slice(ulong from, ulong to)() if (from <= to && (to <= Types.length))
		{
			static assert((typeof(this)).alignof % (typeof(return)).alignof == 0 && (expand[from].offsetof % (typeof(return)).alignof == 0), "Slicing by reference is impossible because of an alignment mistmatch" ~ " (See https://issues.dlang.org/show_bug.cgi?id=15645).");
			return *cast(typeof(return)*)&field[from];
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		const pure nothrow @nogc @safe ulong toHash()
		{
			ulong h = 0LU;
			{
				const const(ulong) k = hashOf(this.__expand_field_0);
				h = k;
			}
			{
				const const(ulong) k = hashOf(this.__expand_field_1);
				h ^= k + 2654435769LU + (h << 6) + (h >>> 2);
			}
			return h;
		}
		const string toString()()
		{
			import std.array : appender;
			auto app = appender!string
			{
			}
			();
			this.toString((const(char)[] chunk) => app ~= chunk);
			return app.data;
		}
		import std.format.spec : FormatSpec;
		const void toString(DG)(scope DG sink)
		{
			auto f = FormatSpec!char
			{
			}
			();
			toString(sink, f);
		}
		const void toString(DG, Char)(scope DG sink, ref scope const FormatSpec!Char
		{
		}
		 fmt)
		{
			import std.format : format, FormatException;
			import std.format.write : formattedWrite;
			import std.range : only;
			if (fmt.nested)
			{
				if (fmt.sep)
				{
					foreach (i, Type; Types)
					{
						static if (i > 0)
						{
							sink(fmt.sep);
						}

						static if (is(Type == class) && is(Type == shared))
						{
							sink(Type.stringof);
						}
						else
						{
							formattedWrite(sink, fmt.nested, this.field[i]);
						}
					}
				}
				else
				{
					formattedWrite(sink, fmt.nested, staticMap!(sharedToString, this.expand)
					{
					}
					);
				}
			}
			else if (fmt.spec == 's')
			{
				enum header = Unqual!(typeof(this))
				{
				}
				.stringof ~ "(", footer = ")", separator = ", ";
				sink(header);
				foreach (i, Type; Types)
				{
					static if (i > 0)
					{
						sink(separator);
					}

					static if (is(Type == class) && is(Type == shared))
					{
						sink(Type.stringof);
					}
					else
					{
						sink(format!"%(%s%)"
						{
						}
						(only(field[i])));
					}
				}
				sink(footer);
			}
			else
			{
				const spec = fmt.spec;
				throw new FormatException("Expected '%s' or '%(...%)' or '%(...%|...%)' format specifier for type '" ~ Unqual!(typeof(this))
				{
				}
				.stringof ~ "', not '%" ~ spec ~ "'.");
			}
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
		static if (4LU == 0LU)
		{
			@safe unittest;
		}
	}

}
parseSpecs!(uint, "data", ulong, "count")
{
	TList
}
FieldSpec!(uint, "data")
{
	alias Type = uint;
	alias name = enum string s = "data";
	;
}
parseSpecs!(ulong, "count")
{
	TList
}
FieldSpec!(ulong, "count")
{
	alias Type = ulong;
	alias name = enum string s = "count";
	;
}
parseSpecs!()
{
	alias parseSpecs = ();

}
_d_arrayappendT!(string, immutable(char))
{
	pure nothrow ref @trusted string _d_arrayappendT(return ref scope string x, scope string y)
	{
		import core.stdc.string : memcpy;
		import core.internal.traits : hasElaborateCopyConstructor, Unqual;
		import core.lifetime : copyEmplace;
		enum bool hasPostblit = false;
		ulong length = x.length;
		_d_arrayappendcTX(x, y.length);
		if (y.length)
		{
			char* xptr = cast(char*)&x[length];
			immutable immutable(ulong) size = 1LU;
			memcpy(cast(void*)xptr, cast(const(void*))cast(char*)&y[0], y.length * 1LU);
		}
		return x;
	}

}
hasElaborateCopyConstructor!(immutable(char))
{
	enum bool hasElaborateCopyConstructor = false;

}
staticMap!(extractType, __T9FieldSpecTkVAyaa4_64617461Z, __T9FieldSpecTmVAyaa5_636f756e74Z)
{
	staticMap
}
fun!(__T9FieldSpecTkVAyaa4_64617461Z)
{
	alias extractType = uint;

}
fun!(__T9FieldSpecTmVAyaa5_636f756e74Z)
{
	alias extractType = ulong;

}
staticMap!(extractName, __T9FieldSpecTkVAyaa4_64617461Z, __T9FieldSpecTmVAyaa5_636f756e74Z)
{
	staticMap
}
fun!(__T9FieldSpecTkVAyaa4_64617461Z)
{
	enum string s = "data";

}
fun!(__T9FieldSpecTmVAyaa5_636f756e74Z)
{
	enum string s = "count";

}
Identity!(__expand_field_0)
{
	uint __expand_field_0;

}
Identity!(__expand_field_1)
{
	ulong __expand_field_1;

}
distinctFieldNames!(uint, ulong)
{
	enum bool distinctFieldNames = true;

}
Tuple!(uint, ulong)
{
	struct Tuple
	{
		alias Types = (uint, ulong);
		private alias _Fields = (uint, ulong);
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		alias fieldNames = staticMap;
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		(uint, ulong) expand;
		mixin((*function () pure nothrow @safe => decl)());
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		static if (is((uint, ulong)))
		{
			alias expand this;
}
		else
		{
			inout @property ref @trusted inout(Tuple!Types
			{
			}
			) _Tuple_super()
			{
				static foreach (i; 0LU .. Types.length)
				{
					static assert((typeof(return)).init.tupleof[i].offsetof == expand[i].offsetof);
				}
				return *cast(typeof(return)*)&field[0];
			}
			alias _Tuple_super this;
}
		alias field = expand;
		static if (2LU > 0LU)
		{
			pure nothrow @nogc @safe this(uint _param_0, ulong _param_1)
			{
				tuple(this.__expand_field_0 = _param_0, this.__expand_field_1 = _param_1);
				return this;
			}
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		this(U, ulong n)(U[n] values) if (n == Types.length && allSatisfy!(isBuildableFrom!U
		{
		}
		, Types)
		{
		}
		)
		{
			static foreach (i; 0 .. Types.length)
			{
				field[i] = values[i];
			}
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		this(U)(U another) if (areBuildCompatibleTuples!(typeof(this), U)
		{
		}
		)
		{
			field[] = another.field[];
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		bool opEquals(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "==")
		{
		}
		)
		{
			return field[] == rhs.field[];
		}
		const bool opEquals(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "==")
		{
		}
		)
		{
			return field[] == rhs.field[];
		}
		bool opEquals(R...)(auto ref R rhs) if (R.length > 1 && areCompatibleTuples!(typeof(this), Tuple!R
		{
		}
		, "==")
		{
		}
		)
		{
			static foreach (i; 0 .. Types.length)
			{
				if (field[i] != rhs[i])
					return false;
			}
			return true;
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		auto opCmp(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "<")
		{
		}
		)
		{
			static foreach (i; 0 .. Types.length)
			{
				if (field[i] != rhs.field[i])
				{
					import std.math.traits : isNaN;
					static if (isFloatingPoint!(Types[i])
					{
					}
					)
					{
						if (isNaN(field[i]))
							return (float).nan;
					}

					static if (isFloatingPoint!(typeof(rhs.field[i]))
					{
					}
					)
					{
						if (isNaN(rhs.field[i]))
							return (float).nan;
					}

					static if (is(typeof(field[i].opCmp(rhs.field[i]))) && isFloatingPoint!(typeof(field[i].opCmp(rhs.field[i])))
					{
					}
					)
					{
						if (isNaN(field[i].opCmp(rhs.field[i])))
							return (float).nan;
					}

					return field[i] < rhs.field[i] ? -1 : 1;
				}
			}
			return 0;
		}
		auto const opCmp(R)(R rhs) if (areCompatibleTuples!(typeof(this), R, "<")
		{
		}
		)
		{
			static foreach (i; 0LU .. Types.length)
			{
				if (field[i] != rhs.field[i])
				{
					import std.math.traits : isNaN;
					static if (isFloatingPoint!(Types[i])
					{
					}
					)
					{
						if (isNaN(field[i]))
							return (float).nan;
					}

					static if (isFloatingPoint!(typeof(rhs.field[i]))
					{
					}
					)
					{
						if (isNaN(rhs.field[i]))
							return (float).nan;
					}

					static if (is(typeof(field[i].opCmp(rhs.field[i]))) && isFloatingPoint!(typeof(field[i].opCmp(rhs.field[i])))
					{
					}
					)
					{
						if (isNaN(field[i].opCmp(rhs.field[i])))
							return (float).nan;
					}

					return field[i] < rhs.field[i] ? -1 : 1;
				}
			}
			return 0;
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		auto opBinary(string op, T)(auto ref T t) if (op == "~" && !(is(T : U[], U) && isTuple!U
		{
		}
		))
		{
			static if (isTuple!T
			{
			}
			)
			{
				static assert(distinctFieldNames!(_Fields, T._Fields)
				{
				}
				, "Cannot concatenate tuples with duplicate fields: " ~ fieldNames.stringof ~ " - " ~ T.fieldNames.stringof);
				return Tuple!(_Fields, T._Fields)
				{
				}
				(expand, t.expand);
			}
			else
			{
				return Tuple!(_Fields, T)
				{
				}
				(expand, t);
			}
		}
		auto opBinaryRight(string op, T)(auto ref T t) if (op == "~" && !(is(T : U[], U) && isTuple!U
		{
		}
		))
		{
			static if (isTuple!T
			{
			}
			)
			{
				static assert(distinctFieldNames!(_Fields, T._Fields)
				{
				}
				, "Cannot concatenate tuples with duplicate fields: " ~ T.stringof ~ " - " ~ fieldNames.fieldNames.stringof);
				return Tuple!(T._Fields, _Fields)
				{
				}
				(t.expand, expand);
			}
			else
			{
				return Tuple!(T, _Fields)
				{
				}
				(t, expand);
			}
		}
		ref Tuple opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this), R, "=")
		{
		}
		)
		{
			import std.algorithm.mutation : swap;
			static if (is(R : Tuple!Types
			{
			}
			) && !__traits(isRef, rhs) && isTuple!R
			{
			}
			)
			{
				if (__ctfe)
				{
					field[] = rhs.field[];
				}
				else
				{
					swap!(Tuple!Types
					{
					}
					)
					{
					}
					(this, rhs);
				}
			}
			else
			{
				field[] = rhs.field[];
			}
			return this;
		}
		inout ref rename(names...)() return if (names.length == 0 || allSatisfy!(isSomeString, typeof(names))
		{
		}
		)
		{
			import std.algorithm.comparison : equal;
			static if (names.length == 0 || equal([names], [fieldNames]))
			{
				return this;
			}
			else
			{
				enum nT = Types.length;
				enum nN = names.length;
				static assert(nN <= nT, "Cannot have more names than tuple members");
				alias allNames = AliasSeq!(names, fieldNames[nN .. __dollar])
				{
				}
				;
				import std.meta : Alias, aliasSeqOf;
				template GetItem(size_t idx)
				{
					import std.array : empty;
					static if (idx < nT)
					{
						alias GetItem = Alias!(Types[idx])
						{
						}
						;
					}
					else
					{
						static if (allNames[idx - nT].empty)
						{
							alias GetItem = AliasSeq!()
							{
							}
							;
						}
						else
						{
							alias GetItem = Alias!(allNames[idx - nT])
							{
							}
							;
						}
					}
				}
				import std.range : roundRobin, iota;
				alias NewTupleT = Tuple!(staticMap!(GetItem, aliasSeqOf!(roundRobin(iota(nT), iota(nT, 2 * nT)))
				{
				}
				)
				{
				}
				)
				{
				}
				;
				return *() @trusted => cast(NewTupleT*)&this();
			}
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		inout ref rename(alias translate)() if (is(typeof(translate) : V[K], V, K) && isSomeString!V
		{
		}
		 && (isSomeString!K
		{
		}
		 || is(K : size_t)))
		{
			import std.meta : aliasSeqOf;
			import std.range : ElementType;
			static if (isSomeString!(ElementType!(typeof(translate.keys))
			{
			}
			)
			{
			}
			)
			{
				{
					import std.conv : to;
					import std.algorithm.iteration : filter;
					import std.algorithm.searching : canFind;
					enum notFound = translate.keys.filter!((k) => fieldNames.canFind(k) == -1)
					{
					}
					;
					static assert(notFound.empty, "Cannot find members " ~ notFound.to!string
					{
					}
					 ~ " in type " ~ (typeof(this)).stringof);
				}
				return this.rename!(aliasSeqOf!(()
				{
					import std.array : empty;
					auto names = [fieldNames];
					foreach (ref n; names)
					{
						if (!n.empty)
							if (auto p = n in translate)
								n = *p;
					}
					return names;
				}
				())
				{
				}
				)
				{
				}
				;
			}
			else
			{
				{
					import std.algorithm.iteration : filter;
					import std.conv : to;
					enum invalid = translate.keys.filter!((k) => k < 0 || k >= this.length)
					{
					}
					;
					static assert(invalid.empty, "Indices " ~ invalid.to!string
					{
					}
					 ~ " are out of bounds for tuple with length " ~ this.length.to!string
					{
					}
					);
				}
				return this.rename!(aliasSeqOf!(()
				{
					auto names = [fieldNames];
					foreach (k, v; translate)
					{
						names[k] = v;
					}
					return names;
				}
				())
				{
				}
				)
				{
				}
				;
			}
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		static if (2LU == 0LU)
		{
			@system unittest;
		}
		static if (2LU == 0LU)
		{
			@system unittest;
		}
		inout @property ref @trusted inout(Tuple!(sliceSpecs!(from, to)
		{
		}
		)
		{
		}
		) slice(ulong from, ulong to)() if (from <= to && (to <= Types.length))
		{
			static assert((typeof(this)).alignof % (typeof(return)).alignof == 0 && (expand[from].offsetof % (typeof(return)).alignof == 0), "Slicing by reference is impossible because of an alignment mistmatch" ~ " (See https://issues.dlang.org/show_bug.cgi?id=15645).");
			return *cast(typeof(return)*)&field[from];
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		const pure nothrow @nogc @safe ulong toHash()
		{
			ulong h = 0LU;
			{
				const const(ulong) k = hashOf(this.__expand_field_0);
				h = k;
			}
			{
				const const(ulong) k = hashOf(this.__expand_field_1);
				h ^= k + 2654435769LU + (h << 6) + (h >>> 2);
			}
			return h;
		}
		const string toString()()
		{
			import std.array : appender;
			auto app = appender!string
			{
			}
			();
			this.toString((const(char)[] chunk) => app ~= chunk);
			return app.data;
		}
		import std.format.spec : FormatSpec;
		const void toString(DG)(scope DG sink)
		{
			auto f = FormatSpec!char
			{
			}
			();
			toString(sink, f);
		}
		const void toString(DG, Char)(scope DG sink, ref scope const FormatSpec!Char
		{
		}
		 fmt)
		{
			import std.format : format, FormatException;
			import std.format.write : formattedWrite;
			import std.range : only;
			if (fmt.nested)
			{
				if (fmt.sep)
				{
					foreach (i, Type; Types)
					{
						static if (i > 0)
						{
							sink(fmt.sep);
						}

						static if (is(Type == class) && is(Type == shared))
						{
							sink(Type.stringof);
						}
						else
						{
							formattedWrite(sink, fmt.nested, this.field[i]);
						}
					}
				}
				else
				{
					formattedWrite(sink, fmt.nested, staticMap!(sharedToString, this.expand)
					{
					}
					);
				}
			}
			else if (fmt.spec == 's')
			{
				enum header = Unqual!(typeof(this))
				{
				}
				.stringof ~ "(", footer = ")", separator = ", ";
				sink(header);
				foreach (i, Type; Types)
				{
					static if (i > 0)
					{
						sink(separator);
					}

					static if (is(Type == class) && is(Type == shared))
					{
						sink(Type.stringof);
					}
					else
					{
						sink(format!"%(%s%)"
						{
						}
						(only(field[i])));
					}
				}
				sink(footer);
			}
			else
			{
				const spec = fmt.spec;
				throw new FormatException("Expected '%s' or '%(...%)' or '%(...%|...%)' format specifier for type '" ~ Unqual!(typeof(this))
				{
				}
				.stringof ~ "', not '%" ~ spec ~ "'.");
			}
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
		static if (2LU == 0LU)
		{
			@safe unittest;
		}
	}

}
parseSpecs!(uint, ulong)
{
	TList
}
FieldSpec!(uint, "")
{
	alias Type = uint;
	alias name = enum string s = "";
	;
}
parseSpecs!ulong
{
	TList
}
FieldSpec!(ulong, "")
{
	alias Type = ulong;
	alias name = enum string s = "";
	;
}
staticMap!(extractType, __T9FieldSpecTkVAyaa0_Z, __T9FieldSpecTmVAyaa0_Z)
{
	staticMap
}
fun!(__T9FieldSpecTkVAyaa0_Z)
{
	alias extractType = uint;

}
fun!(__T9FieldSpecTmVAyaa0_Z)
{
	alias extractType = ulong;

}
staticMap!(extractName, __T9FieldSpecTkVAyaa0_Z, __T9FieldSpecTmVAyaa0_Z)
{
	staticMap
}
fun!(__T9FieldSpecTkVAyaa0_Z)
{
	enum string s = "";

}
fun!(__T9FieldSpecTmVAyaa0_Z)
{
	enum string s = "";

}
Identity!(__expand_field_0)
{
	uint __expand_field_0;

}
Identity!(__expand_field_1)
{
	ulong __expand_field_1;

}
areCompatibleTuples!(Tuple!(uint, ulong), Tuple!(uint, ulong), "=")
{
	enum bool areCompatibleTuples = true;

}
OriginalType!(Tuple!(uint, ulong))
{
	alias OriginalType = Tuple!(uint, ulong);

}
_OriginalType!(Tuple!(uint, ulong))
{
	alias OriginalType = Tuple!(uint, ulong);

}
ModifyTypePreservingTQ!(Impl, Tuple!(uint, ulong))
{
	alias ModifyTypePreservingTQ = Tuple!(uint, ulong);

}
Modifier!(Tuple!(uint, ulong))
{
	alias Impl = Tuple!(uint, ulong);

}
isTuple!(Tuple!(uint, ulong))
{
	enum bool isTuple = true;

}
f!(uint, ulong)
{
	pure nothrow @nogc @safe void f(Tuple!(uint, ulong) tup)
	{
	}

}
opAssign!(Tuple!(uint, ulong))
{
	pure nothrow @nogc ref @safe Tuple!(uint, ulong) opAssign(Tuple!(uint, ulong) rhs) return
	{
		import std.algorithm.mutation : swap;
		if (__ctfe)
		{
			tuple(this.__expand_field_0 = rhs.__expand_field_0, this.__expand_field_1 = rhs.__expand_field_1);
		}
		else
		{
			swap(this, rhs);
		}
		return this;
	}

}
areCompatibleTuples!(Tuple!(uint, ulong), Tuple!(uint, ulong), "==")
{
	enum bool areCompatibleTuples = true;

}
areCompatibleTuples!(const(Tuple!(uint, ulong)), Tuple!(uint, ulong), "==")
{
	enum bool areCompatibleTuples = true;

}
opEquals!(Tuple!(uint, ulong))
{
	pure nothrow @nogc @safe bool opEquals(Tuple!(uint, ulong) rhs)
	{
		return this.__expand_field_0 == rhs.__expand_field_0 && (this.__expand_field_1 == rhs.__expand_field_1);
	}

}
areCompatibleTuples!(Tuple!(uint, "data", ulong, "count"), Tuple!(uint, "data", ulong, "count"), "=")
{
	enum bool areCompatibleTuples = true;

}
OriginalType!(Tuple!(uint, "data", ulong, "count"))
{
	alias OriginalType = Tuple!(uint, "data", ulong, "count");

}
_OriginalType!(Tuple!(uint, "data", ulong, "count"))
{
	alias OriginalType = Tuple!(uint, "data", ulong, "count");

}
ModifyTypePreservingTQ!(Impl, Tuple!(uint, "data", ulong, "count"))
{
	alias ModifyTypePreservingTQ = Tuple!(uint, "data", ulong, "count");

}
Modifier!(Tuple!(uint, "data", ulong, "count"))
{
	alias Impl = Tuple!(uint, "data", ulong, "count");

}
isTuple!(Tuple!(uint, "data", ulong, "count"))
{
	enum bool isTuple = true;

}
f!(uint, "data", ulong, "count")
{
	pure nothrow @nogc @safe void f(Tuple!(uint, "data", ulong, "count") tup)
	{
	}

}
opAssign!(Tuple!(uint, "data", ulong, "count"))
{
	pure nothrow @nogc ref @safe Tuple!(uint, "data", ulong, "count") opAssign(Tuple!(uint, "data", ulong, "count") rhs) return
	{
		import std.algorithm.mutation : swap;
		if (__ctfe)
		{
			tuple(this.__expand_field_0 = rhs.__expand_field_0, this.__expand_field_1 = rhs.__expand_field_1);
		}
		else
		{
			swap(this._Tuple_super(), rhs._Tuple_super());
		}
		return this;
	}

}
areCompatibleTuples!(Tuple!(uint, "data", ulong, "count"), Tuple!(uint, "data", ulong, "count"), "==")
{
	enum bool areCompatibleTuples = true;

}
areCompatibleTuples!(const(Tuple!(uint, "data", ulong, "count")), Tuple!(uint, "data", ulong, "count"), "==")
{
	enum bool areCompatibleTuples = true;

}
opEquals!(Tuple!(uint, "data", ulong, "count"))
{
	pure nothrow @nogc @safe bool opEquals(Tuple!(uint, "data", ulong, "count") rhs)
	{
		return this.__expand_field_0 == rhs.__expand_field_0 && (this.__expand_field_1 == rhs.__expand_field_1);
	}

}
to!int
{
	T to(A...)(A args) if (A.length > 0)
	{
		return toImpl!T
		{
		}
		(args);
	}

}
to!(const(uint))
{
	pure @safe int to(const(uint) _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(const(uint), int)
{
	enum bool isImplicitlyConvertible = true;

}
isEnumStrToStr!(const(uint), int)
{
	enum bool isEnumStrToStr = false;

}
isNullToStr!(const(uint), int)
{
	enum bool isNullToStr = false;

}
isTuple!int
{
	enum bool isTuple = false;

}
toImpl!(int, const(uint))
{
	pure @safe int toImpl(const(uint) value)
	{
		enum isSignedInt(T) = isIntegral!T
		{
		}
		 && isSigned!T
		{
		}
		;
		alias isUnsignedInt = template isUnsigned(T)
		{
			static if (!__traits(isUnsigned, T))
			{
				enum isUnsigned = false;
			}
			else
			{
				static if (is(T U == enum))
				{
					enum isUnsigned = isUnsigned!U
					{
					}
					;
				}
				else
				{
					enum isUnsigned = __traits(isZeroInit, T) && !is(immutable(T) == immutable(bool)) && !is(T == __vector);
				}
			}
		}
		;
		import std.exception : enforce;
		enforce(value <= 2147483647u, delegate Throwable() pure nothrow @safe => new ConvOverflowException("Conversion positive overflow", "/usr/include/dmd/phobos/std/conv.d", 559LU));
		return cast(int)value;
	}

}
isUnsignedInt!(const(uint))
{
	enum bool isUnsigned = true;

}
isSignedInt!int
{
	enum bool isSignedInt = true;

}
enforce!()
{
	T enforce(T)(T value, lazy const(char)[] msg = null, string file = __FILE__, size_t line = __LINE__) if (is(typeof(()
	{
		if (!value)
		{
		}
	}
	)))
	{
		if (!value)
			bailOut!E
			{
			}
			(file, line, msg);
		return value;
	}

}
isSomeFunction!(ConvOverflowException)
{
	enum bool isSomeFunction = false;

}
enforce!bool
{
	pure @safe bool enforce(bool value, lazy Throwable ex)
	{
		if (!value)
			throw ex();
		return value;
	}

}
text!(string, char)
{
	pure nothrow @safe string text(string _param_0, char _param_1)
	{
		return textImpl(_param_0, _param_1);
	}

}
textImpl!(string, string, char)
{
	pure nothrow @safe string textImpl(string _param_0, char _param_1)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(40LU);
		app.put(_param_0);
		app.put(_param_1);
		return app.data();
	}

}
canPutItem!char
{
	enum bool canPutItem = true;

}
isImplicitlyConvertible!(char, char)
{
	enum bool isImplicitlyConvertible = true;

}
canPutConstRange!char
{
	enum bool canPutConstRange = false;

}
canPutRange!char
{
	enum bool canPutRange = false;

}
put!char
{
	pure nothrow @safe void put(char item)
	{
		import core.lifetime : emplace;
		this.ensureAddable(1LU);
		immutable immutable(ulong) len = (*this._data).arr.length;
		char[] bigData = delegate () pure nothrow @nogc @trusted => (cast(char*)(*this._data).arr)[0..len + 1LU]();
		char* itemUnqual = delegate () pure nothrow @nogc @trusted => & item();
		emplace(&bigData[len], *itemUnqual);
		(*this._data).arr = bigData;
	}

}
emplace!(char, char)
{
	pure nothrow @nogc @safe char* emplace(char* chunk, ref char _param_1)
	{
		import core.internal.lifetime : emplaceRef;
		emplaceRef(*chunk, _param_1);
		return chunk;
	}

}
forward!(_param_1)
{
	ref char _param_1;

}
fwd!(_param_1)
{
	ref char _param_1;

}
getNthInt!("integer width", int[])
{
	pure @safe int getNthInt(uint index, int[] _param_1)
	{
		return getNth(index, _param_1);
	}

}
getNth!("integer width", isIntegral, int, int[])
{
	pure @safe int getNth(uint index, int[] _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = int[];
					case 0u:
					{
						throw new FormatException(text("integer width", " expected, not ", "int[]", " for argument #", index + 1u), "/usr/include/dmd/phobos/std/format/internal/write.d", 3424LU, null);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "integer width", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
text!(string, string, string, string, uint)
{
	pure nothrow @safe string text(string _param_0, string _param_1, string _param_2, string _param_3, uint _param_4)
	{
		return textImpl(_param_0, _param_1, _param_2, _param_3, _param_4);
	}

}
textImpl!(string, string, string, string, string, uint)
{
	pure nothrow @safe string textImpl(string _param_0, string _param_1, string _param_2, string _param_3, uint _param_4)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(100LU);
		app.put(_param_0);
		app.put(_param_1);
		app.put(_param_2);
		app.put(_param_3);
		app.put(textImpl(_param_4));
		return app.data();
	}

}
isSomeString!uint
{
	enum bool isSomeString = false;

}
isInputRange!uint
{
	enum bool isInputRange = false;

}
textImpl!(string, uint)
{
	pure nothrow @safe string textImpl(uint _param_0)
	{
		return to(_param_0);
	}

}
isAggregateType!uint
{
	enum bool isAggregateType = false;

}
to!uint
{
	pure nothrow @safe string to(uint _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(uint, string)
{
	enum bool isImplicitlyConvertible = false;

}
isInfinite!uint
{
	enum bool isInfinite = false;

}
isCopyable!uint
{
	enum bool isCopyable = true;

}
isNumeric!uint
{
	enum bool isNumeric = true;

}
toImpl!(string, uint)
{
	pure nothrow @safe string toImpl(uint value)
	{
		return toImpl(value, 10u, LetterCase.upper);
	}

}
isExactSomeString!uint
{
	enum bool isExactSomeString = false;

}
isSomeFiniteCharInputRange!uint
{
	enum bool isSomeFiniteCharInputRange = false;

}
toImpl!(string, uint)
{
	pure nothrow @trusted string toImpl(uint value, uint radix, LetterCase letterCase = LetterCase.upper)
	in
	{
		assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
	}
	do
	{
		{
			{
				assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
			}
		}
		alias EEType = char;
		T toStringRadixConvert(ulong bufLen)(uint runtimeRadix = 0)
		{
			Unsigned!(Unqual!S
			{
			}
			)
			{
			}
			 div = void, mValue = unsigned(value);
			size_t index = bufLen;
			EEType[bufLen] buffer = void;
			char baseChar = letterCase == LetterCase.lower ? 'a' : 'A';
			char mod = void;
			do
			{
				div = cast(S)(mValue / runtimeRadix);
				mod = cast(ubyte)(mValue % runtimeRadix);
				mod += mod < 10 ? '0' : baseChar - 10;
				buffer[--index] = cast(char)mod;
				mValue = div;
			}
			while (mValue);
			return cast(T)buffer[index..__dollar].dup;
		}
		import std.array : array;
		switch (radix)
		{
			case 10u:
			{
				return array(toChars(value + 0u));
			}
			case 16u:
			{
				if (cast(int)letterCase == 0)
					return array(toChars(unsigned(unsigned(value) + 0u)));
				else
					return array(toChars(unsigned(unsigned(value) + 0u)));
			}
			case 2u:
			{
				return array(toChars(unsigned(unsigned(value) + 0u)));
			}
			case 8u:
			{
				return array(toChars(unsigned(unsigned(value) + 0u)));
			}
			default:
			{
				return toStringRadixConvert(radix);
			}
		}
	}

}
toChars!(10, char, LetterCase.lower, uint)
{
	auto pure nothrow @nogc @safe Result toChars(uint value)
	{
		alias UT = uint;
		static struct Result
		{
			pure nothrow @nogc @safe void initialize(uint value)
			{
				bool neg = false;
				if (value < 10u)
				{
					if (value >= 0u)
					{
						this.lwr = 0u;
						this.upr = 1u;
						this.buf[0] = cast(char)(value + 48u);
						return ;
					}
					value = -value;
					neg = true;
				}
				uint i = 9u;
				for (; value >= 10u;)
				{
					{
						this.buf[cast(ulong)i] = cast(char)cast(ubyte)(48u + value % 10u);
						value = unsigned(value) / 10u;
						i -= 1u;
					}
				}
				this.buf[cast(ulong)i] = cast(char)(value + 48u);
				if (neg)
				{
					this.buf[cast(ulong)(i - 1u)] = '-';
					i -= 1u;
				}
				this.lwr = i;
				this.upr = 10u;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)(this.upr - this.lwr);
			}
			alias opDollar = pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)(this.upr - this.lwr);
			}
			;
			pure nothrow @nogc @property @safe bool empty()
			{
				return this.upr == this.lwr;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.buf[cast(ulong)this.lwr];
			}
			pure nothrow @nogc @safe void popFront()
			{
				this.lwr += 1u;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.buf[cast(ulong)(this.upr - 1u)];
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.upr -= 1u;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				return this.buf[cast(ulong)this.lwr + i];
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.buf = this.buf;
				result.lwr = cast(uint)(cast(ulong)this.lwr + lwr);
				result.upr = cast(uint)(cast(ulong)this.lwr + upr);
				return result;
			}
			private
			{
				uint lwr = void;
				uint upr = void;
				char[10] buf = void;
			}
		}
		Result result = 0;
		result.initialize(value);
		return result;
	}

}
isSigned!uint
{
	enum bool isSigned = false;

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r221 = r;
				for (; !__r221.empty(); __r221.popFront())
				{
					char e = __r221.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r222 = r;
				for (; !__r222.empty(); __r222.popFront())
				{
					char e = __r222.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toStringRadixConvert!24LU
{
	pure nothrow @system string toStringRadixConvert(uint runtimeRadix = 0u)
	{
		uint div = void;
		uint mValue = unsigned(value);
		ulong index = 24LU;
		char[24] buffer = void;
		char baseChar = cast(int)letterCase == 1 ? 'a' : 'A';
		char mod = void;
		do
		{
			div = mValue / runtimeRadix;
			mod = cast(char)cast(ubyte)(mValue % runtimeRadix);
			cast(int)mod += cast(int)mod < 10 ? 48 : cast(int)baseChar - 10;
			buffer[index -= 1LU] = mod;
			mValue = div;
		}
		while (mValue);
		return cast(string)dup(buffer[index..24]);
	}

}
text!(string, string, string)
{
	pure nothrow @safe string text(string _param_0, string _param_1, string _param_2)
	{
		return textImpl(_param_0, _param_1, _param_2);
	}

}
textImpl!(string, string, string, string)
{
	pure nothrow @safe string textImpl(string _param_0, string _param_1, string _param_2)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(60LU);
		app.put(_param_0);
		app.put(_param_1);
		app.put(_param_2);
		return app.data();
	}

}
getNthInt!("integer precision", int[])
{
	pure @safe int getNthInt(uint index, int[] _param_1)
	{
		return getNth(index, _param_1);
	}

}
getNth!("integer precision", isIntegral, int, int[])
{
	pure @safe int getNth(uint index, int[] _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = int[];
					case 0u:
					{
						throw new FormatException(text("integer precision", " expected, not ", "int[]", " for argument #", index + 1u), "/usr/include/dmd/phobos/std/format/internal/write.d", 3424LU, null);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "integer precision", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
getNthInt!("separator digit width", int[])
{
	pure @safe int getNthInt(uint index, int[] _param_1)
	{
		return getNth(index, _param_1);
	}

}
getNth!("separator digit width", isIntegral, int, int[])
{
	pure @safe int getNth(uint index, int[] _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = int[];
					case 0u:
					{
						throw new FormatException(text("separator digit width", " expected, not ", "int[]", " for argument #", index + 1u), "/usr/include/dmd/phobos/std/format/internal/write.d", 3424LU, null);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "separator digit width", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
getNth!("separator character", isSomeChar, dchar, int[])
{
	pure @safe dchar getNth(uint index, int[] _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = int[];
					case 0u:
					{
						throw new FormatException(text("separator character", " expected, not ", "int[]", " for argument #", index + 1u), "/usr/include/dmd/phobos/std/format/internal/write.d", 3424LU, null);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "separator character", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
formatValue!(LockingTextWriter, int[], char)
{
	@safe void formatValue(ref LockingTextWriter w, ref int[] val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
OriginalType!(int[])
{
	alias OriginalType = int[];

}
_OriginalType!(int[])
{
	alias OriginalType = int[];

}
ModifyTypePreservingTQ!(Impl, int[])
{
	alias ModifyTypePreservingTQ = int[];

}
Modifier!(int[])
{
	alias Impl = int[];

}
DynamicArrayTypeOf!(int[])
{
	alias DynamicArrayTypeOf = int[];

}
_DynamicArrayTypeOf!(int[])
{
	alias DynamicArrayTypeOf = int[];

}
isAggregateType!(int[])
{
	enum bool isAggregateType = false;

}
Unqual!(int[], int[])
{
	alias Unqual = int[];

}
hasToString!(int[], char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!(int[])
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
isSIMDVector!(int[])
{
	enum bool isSIMDVector = false;

}
isDelegate!(int[])
{
	enum bool isDelegate = false;

}
formatValueImpl!(LockingTextWriter, int[], char)
{
	@safe void formatValueImpl(ref LockingTextWriter w, int[] obj, ref scope const(FormatSpec!char) f)
	{
		formatRange(w, obj, f);
	}

}
ArrayTypeOf!(int[])
{
	alias ArrayTypeOf = int[];

}
isInputRange!(int[])
{
	enum bool isInputRange = true;

}
empty!(int[])
{
	pure nothrow @nogc @property @safe bool empty(ref scope int[] a)
	{
		return !a.length;
	}

}
isCallable!(function (int[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (int[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (int[] r) pure nothrow @nogc @safe => empty(r))
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (int[] r) pure nothrow @nogc @safe => empty(r))
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(int[] r);

}
isAutodecodableString!(int[])
{
	enum bool isAutodecodableString = false;

}
front!int
{
	pure nothrow @nogc @property ref @safe inout(int) front(return scope inout(int)[] a)
	{
		assert(a.length, "Attempting to fetch the front of an empty array of int");
		return a[0];
	}

}
isCallable!(function (int[] r) pure nothrow @nogc @safe => front(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (int[] r) pure nothrow @nogc @safe => front(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (int[] r) pure nothrow @nogc @safe => front(r))
{
	alias ReturnType = int;

}
FunctionTypeOf!(function (int[] r) pure nothrow @nogc @safe => front(r))
{
	alias pure nothrow @nogc @safe int FunctionTypeOf(int[] r);

}
popFront!int
{
	pure nothrow @nogc @safe void popFront(ref scope inout(int)[] a)
	{
		assert(a.length, "Attempting to popFront() past the end of an array of int");
		a = a[1..__dollar];
	}

}
formatRange!(LockingTextWriter, int[], char)
{
	@safe void formatRange(ref LockingTextWriter w, ref int[] val, ref scope const(FormatSpec!char) f)
	{
		import std.conv : text;
		import std.format : FormatException, formatValue, NoOpSink;
		import std.range.primitives : ElementType, empty, front, hasLength, walkLength, isForwardRange, isInfinite, popFront, put;
		enum bool formatTestMode = false;
		if (cast(int)f.spec == 115)
		{
			alias E = int;
			put(w, "[");
			if (!empty(val))
			{
				formatElement(w, front(val), f);
				popFront(val);
				{
					ulong i = 0LU;
					for (; !empty(val); popFront(val) , i += 1LU)
					{
						{
							put(w, ", ");
							formatElement(w, front(val), f);
						}
					}
				}
			}
			put(w, "]");
		}
		else if (cast(int)f.spec == 114)
		{
			alias ARR = int[];
			scope int[] a = val;
			{
				scope int[] __r346 = a[];
				ulong __key347 = 0LU;
				for (; __key347 < __r346.length; __key347 += 1LU)
				{
					int e = __r346[__key347];
					formatValue(w, e, f);
				}
			}
		}
		else if (cast(int)f.spec == 40)
		{
			if (empty(val))
				return ;
			for (;;)
			{
				{
					FormatSpec!char fmt = fmt = FormatSpec , fmt.this(f.nested);
					w:
					for (; true;)
					{
						{
							immutable immutable(bool) r = fmt.writeUpToNextSpec(w);
							if (!r)
								break;
							if (f.flDash())
								formatValue(w, front(val), fmt);
							else
								formatElement(w, front(val), fmt);
							{
								ulong __key350 = 0LU;
								ulong __limit351 = fmt.trailing.length;
								for (; __key350 < __limit351; __key350 += 1LU)
								{
									ulong i = __key350;
									if (cast(int)fmt.trailing[i] == 37)
										continue w;
								}
							}
							break w;
						}
					}
					if (f.sep !is null)
					{
						put(w, fmt.trailing);
						popFront(val);
						if (empty(val))
							break;
						put(w, f.sep);
					}
					else
					{
						popFront(val);
						if (empty(val))
							break;
						put(w, fmt.trailing);
					}
				}
			}
		}
		else
			throw new FormatException(text("Incorrect format specifier for range: %", f.spec), "/usr/include/dmd/phobos/std/format/internal/write.d", 1725LU, null);
	}

}
ElementType!(int[])
{
	alias ElementType = int;

}
put!(LockingTextWriter, string)
{
	@safe void put(ref LockingTextWriter r, string e)
	{
		doPut(r, e);
	}

}
doPut!(LockingTextWriter, string)
{
	@safe void doPut(ref LockingTextWriter r, ref string e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
isInfinite!string
{
	enum bool isInfinite = false;

}
put!string
{
	@safe void put(scope string writeme)
	{
		import std.exception : errnoEnforce;
		alias C = immutable(char);
		if (this.orientation_ <= 0)
		{
			ulong result = trustedFwrite((*this.file_._p).handle, writeme);
			if (result != writeme.length)
				enforce(0, delegate const(char)[]() pure nothrow @nogc @safe => null, "/usr/include/dmd/phobos/std/stdio.d", 3174LU);
			return ;
		}
		{
			scope string __r232 = writeme[];
			ulong __key233 = 0LU;
			for (; __key233 < __r232.length; __key233 += 1LU)
			{
				immutable immutable(char) c = __r232[__key233];
				this.put(c);
			}
		}
	}

}
ElementType!(immutable(char))
{
	alias ElementType = void;

}
put!(immutable(char))
{
	@safe void put(immutable(char) c)
	{
		import std.utf : decodeFront, encode, stride;
		this.highSurrogateShouldBeEmpty();
		if (this.orientation_ <= 0)
			trustedFPUTC(cast(int)c, this.handle_());
		else if (cast(int)c <= 127)
			trustedFPUTWC(cast(dchar)c, this.handle_());
		else if (cast(int)c >= 192)
		{
			this.rbuf8[0] = c;
			this.rbuf8Filled = 1LU;
		}
		else
		{
			this.rbuf8[this.rbuf8Filled] = c;
			this.rbuf8Filled += 1LU;
			if (cast(ulong)stride(this.rbuf8[]) == this.rbuf8Filled)
			{
				char[] str = this.rbuf8[0..this.rbuf8Filled];
				immutable immutable(dchar) d = decodeFront(str);
				dchar[1] wbuf = '\uffff';
				immutable immutable(ulong) size = encode(wbuf, d);
				{
					ulong __key234 = 0LU;
					ulong __limit235 = size;
					for (; __key234 < __limit235; __key234 += 1LU)
					{
						ulong i = __key234;
						trustedFPUTWC(wbuf[i], this.handle_());
					}
				}
				this.rbuf8Filled = 0LU;
			}
		}
	}

}
formatElement!(LockingTextWriter, int, char)
{
	@safe void formatElement(ref LockingTextWriter w, ref int val, ref scope const(FormatSpec!char) f)
	{
		import std.format.write : formatValue;
		formatValue(w, val, f);
	}

}
formatValue!(LockingTextWriter, int, char)
{
	@safe void formatValue(ref LockingTextWriter w, ref int val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
IntegralTypeOf!int
{
	alias IntegralTypeOf = int;

}
hasToString!(int, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!int
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
isAggregateType!int
{
	enum bool isAggregateType = false;

}
isSIMDVector!int
{
	enum bool isSIMDVector = false;

}
isDelegate!int
{
	enum bool isDelegate = false;

}
formatValueImpl!(LockingTextWriter, int, char)
{
	@safe void formatValueImpl(ref LockingTextWriter w, const(int) obj, ref scope const(FormatSpec!char) f)
	{
		alias U = int;
		int val = obj;
		if (cast(int)f.spec == 114)
		{
			const(char)[] raw = (*function (ref int val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..4])(val);
			import std.range.primitives : put;
			if (needToSwapEndianess(f))
			{
				scope const(char)[] __r243 = raw[];
				ulong __key244 = __r243.length;
				for (; __key244--;)
				{
					const const(char) c = __r243[__key244];
					put(w, c);
				}
			}
			else
			{
				scope const(char)[] __r245 = raw[];
				ulong __key246 = 0LU;
				for (; __key246 < __r245.length; __key246 += 1LU)
				{
					const const(char) c = __r245[__key246];
					put(w, c);
				}
			}
			return ;
		}
		const const(bool) negative = val < 0 && (cast(int)f.spec != 120) && (cast(int)f.spec != 88) && (cast(int)f.spec != 98) && (cast(int)f.spec != 111) && (cast(int)f.spec != 117);
		ulong arg = negative ? -cast(ulong)val : cast(ulong)val;
		arg &= 4294967295LU;
		formatValueImplUlong(w, arg, negative, f);
	}

}
__lambda5!int
{
	function (ref int val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..4]
}
needToSwapEndianess!char
{
	pure nothrow @nogc @safe bool needToSwapEndianess(ref scope const(FormatSpec!char) f)
	{
		import std.system : endian, Endian;
		return f.flPlus() || false;
	}

}
put!(LockingTextWriter, const(char))
{
	@safe void put(ref LockingTextWriter r, const(char) e)
	{
		doPut(r, e);
	}

}
doPut!(LockingTextWriter, const(char))
{
	@safe void doPut(ref LockingTextWriter r, ref const(char) e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
formatValueImplUlong!(LockingTextWriter, char)
{
	@safe void formatValueImplUlong(ref LockingTextWriter w, ulong arg, in bool negative, ref scope const(FormatSpec!char) f)
	{
		immutable immutable(uint) base = baseOfSpec(f.spec);
		const const(bool) zero = arg == 0LU;
		char[64] digits = void;
		ulong pos = 63LU;
		do
		{
			digits[pos--] = cast(char)(48LU + arg % cast(ulong)base);
			if (base > 10u && (cast(int)digits[pos + 1LU] > 57))
				cast(int)digits[pos + 1LU] += (cast(int)f.spec == 120 || cast(int)f.spec == 97 ? 97 : 65) - 48 - 10;
			arg /= cast(ulong)base;
		}
		while (arg > 0LU);
		char[3] prefix = void;
		ulong left = 2LU;
		ulong right = 2LU;
		if (cast(int)f.spec != 120 && (cast(int)f.spec != 88) && (cast(int)f.spec != 98) && (cast(int)f.spec != 111) && (cast(int)f.spec != 117))
		{
			if (negative)
				prefix[right++] = '-';
			else if (f.flPlus())
				prefix[right++] = '+';
			else if (f.flSpace())
				prefix[right++] = ' ';
		}
		if (cast(int)f.spec == 120 || cast(int)f.spec == 88 || cast(int)f.spec == 98 || cast(int)f.spec == 111 || cast(int)f.spec == 117 || cast(int)f.spec == 100 || cast(int)f.spec == 115)
		{
			if (f.flHash() && (base == 16u) && !zero)
			{
				prefix[left -= 1LU] = f.spec;
				prefix[left -= 1LU] = '0';
			}
			if (f.flHash() && (base == 8u) && !zero && (64LU - (pos + 1LU) >= cast(ulong)f.precision || f.precision == 2147483646))
				prefix[left -= 1LU] = '0';
			writeAligned(w, prefix[left..right], digits[pos + 1LU..64], "", f, true);
			return ;
		}
		FormatSpec!char fs = f;
		if (f.precision == 2147483646)
			fs.precision = cast(int)(64LU - pos - 2LU);
		if (cast(int)f.spec == 102 || cast(int)f.spec == 70 || (cast(int)f.spec == 103 || cast(int)f.spec == 71) && (cast(ulong)fs.precision >= 64LU - pos - 2LU))
		{
			if (f.precision == 2147483646)
				fs.precision = 0;
			writeAligned(w, prefix[left..right], digits[pos + 1LU..64], ".", "", fs, cast(int)f.spec == 103 || cast(int)f.spec == 71 ? PrecisionType.allDigits : PrecisionType.fractionalDigits);
			return ;
		}
		import std.algorithm.searching : all;
		if ((cast(int)f.spec == 103 || cast(int)f.spec == 71) && (fs.precision == 0))
			fs.precision = 1;
		ulong digit_end = pos + cast(ulong)fs.precision + (cast(int)f.spec == 103 || cast(int)f.spec == 71 ? 1LU : 2LU);
		if (digit_end <= 64LU)
		{
			RoundingClass rt = RoundingClass.ZERO;
			if (digit_end < 64LU)
			{
				char tie = cast(int)f.spec == 97 || cast(int)f.spec == 65 ? '8' : '5';
				if (cast(int)digits[digit_end] >= cast(int)tie)
				{
					rt = RoundingClass.UPPER;
					if (cast(int)digits[digit_end] == cast(int)tie && all(digits[digit_end + 1LU..64]))
						rt = RoundingClass.FIVE;
				}
				else
				{
					rt = RoundingClass.LOWER;
					if (all(digits[digit_end..64]))
						rt = RoundingClass.ZERO;
				}
			}
			if (round(digits, pos + 1LU, digit_end, rt, negative, cast(int)f.spec == 97 ? 'f' : cast(int)f.spec == 65 ? 'F' : '9'))
			{
				pos--;
				digit_end--;
			}
		}
		char[1] int_digit = void;
		int_digit[0] = digits[pos + 1LU];
		digits[pos + 1LU] = '.';
		char[4] suffix = void;
		if (cast(int)f.spec == 101 || cast(int)f.spec == 69 || cast(int)f.spec == 103 || cast(int)f.spec == 71)
		{
			suffix[0] = cast(int)f.spec == 101 || cast(int)f.spec == 103 ? 'e' : 'E';
			suffix[1] = '+';
			suffix[2] = cast(char)(48LU + (64LU - pos - 2LU) / 10LU);
			suffix[3] = cast(char)(48LU + (64LU - pos - 2LU) % 10LU);
		}
		else
		{
			if (right == 3LU)
				prefix[0] = prefix[2];
			prefix[1] = '0';
			prefix[2] = cast(int)f.spec == 97 ? 'x' : 'X';
			left = right == 3LU ? 0LU : 1LU;
			right = 3LU;
			suffix[0] = cast(int)f.spec == 97 ? 'p' : 'P';
			suffix[1] = '+';
			suffix[2] = cast(char)(48LU + (64LU - pos - 2LU) * 4LU / 10LU);
			suffix[3] = cast(char)(48LU + (64LU - pos - 2LU) * 4LU % 10LU);
		}
		import std.algorithm.comparison : min;
		if ((cast(int)f.spec == 103 || cast(int)f.spec == 71) && !f.flHash())
		{
			digit_end = min(digit_end, 64LU);
			for (; digit_end > pos + 1LU && (cast(int)digits[digit_end - 1LU] == 48 || cast(int)digits[digit_end - 1LU] == 46);)
			{
				digit_end--;
			}
		}
		writeAligned(w, prefix[left..right], int_digit[0..1], digits[pos + 1LU..min(digit_end, 64LU)], suffix[0..4], fs, cast(int)f.spec == 103 || cast(int)f.spec == 71 ? PrecisionType.allDigits : PrecisionType.fractionalDigits);
	}

}
writeAligned!(LockingTextWriter, char[], char[], string, char)
{
	@safe void writeAligned(ref LockingTextWriter w, char[] prefix, char[] grouped, string suffix, ref scope const(FormatSpec!char) f, bool integer_precision = false)
	{
		writeAligned(w, prefix, grouped, "", suffix, f, integer_precision ? PrecisionType.integer : PrecisionType.none);
	}

}
writeAligned!(LockingTextWriter, char[], char[], string, string, char)
{
	@safe void writeAligned(ref LockingTextWriter w, char[] prefix, char[] grouped, string fracts, string suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key295 = 0LU;
					ulong __limit296 = fracts.length;
					for (; __key295 < __limit296; __key295 += 1LU)
					{
						ulong i = __key295;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key297 = 0L;
					long __limit298 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key297 < __limit298; __key297 += 1L)
					{
						long i = __key297;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key301 = 0L;
					long __limit302 = delta;
					for (; __key301 < __limit302; __key301 += 1L)
					{
						long i = __key301;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key305 = 0L;
					long __limit306 = delta;
					for (; __key305 < __limit306; __key305 += 1L)
					{
						long i = __key305;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key309 = 0L;
				long __limit310 = delta;
				for (; __key309 < __limit310; __key309 += 1L)
				{
					long i = __key309;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key311 = 0LU;
				ulong __limit312 = cast(ulong)pregrouped + grouped.length;
				for (; __key311 < __limit312; __key311 += 1LU)
				{
					ulong i = __key311;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key313 = 0L;
				long __limit314 = pregrouped;
				for (; __key313 < __limit314; __key313 += 1L)
				{
					long i = __key313;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key315 = 0L;
			long __limit316 = trailingZeros;
			for (; __key315 < __limit316; __key315 += 1L)
			{
				long i = __key315;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key317 = 0L;
					long __limit318 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key317 < __limit318; __key317 += 1L)
					{
						long i = __key317;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key319 = 0L;
					long __limit320 = delta;
					for (; __key319 < __limit320; __key319 += 1L)
					{
						long i = __key319;
						put(w, ' ');
					}
				}
			}
		}
	}

}
getWidth!(char[])
{
	pure @safe long getWidth(char[] s)
	{
		import std.algorithm.searching : all;
		import std.uni : graphemeStride;
		if (all(s))
			return cast(long)s.length;
		long width = 0L;
		{
			ulong i = 0LU;
			for (; i < s.length; i += graphemeStride(s, i))
			{
				width += 1L;
			}
		}
		return width;
	}

}
all!((a) => a <= 127)
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
all!(char[])
{
	pure @safe bool all(char[] range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda2, "a")
{
	__lambda2(__T12)(a)
	{
		return a <= 127;
	}

}
needOpCallAlias!(__lambda2)
{
	enum bool needOpCallAlias = false;

}
__lambda2!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a <= 127u
}
not!(__lambda2)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, char[])
{
	pure @safe char[] find(char[] haystack)
	{
		alias R = char[];
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		import std.utf : decode;
		immutable immutable(ulong) len = haystack.length;
		ulong i = 0LU;
		ulong next = 0LU;
		for (; next < len;)
		{
			{
				if (not(decode(haystack, next)))
					return haystack[i..__dollar];
				i = next;
			}
		}
		return haystack[__dollar..__dollar];
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
isNarrowString!(char[])
{
	enum bool isNarrowString = true;

}
decode!(Flag.no, char[])
{
	pure @trusted dchar decode(ref scope char[] str, ref ulong index)
	in
	{
		assert(index < str.length, "Attempted to decode past the end of a string");
	}
	out(result)
	{
		assert(isValidDchar(result));
	}
	do
	{
		{
			{
				assert(index < str.length, "Attempted to decode past the end of a string");
			}
		}
		if (cast(int)str[index] < 128)
			__result = cast(dchar)str[index++];
			goto __returnLabel;
		else
		{
			__result = decodeImpl(cast(const(char)[])str, index);
			goto __returnLabel;
		}
		__returnLabel:
		{
			const ref const(dchar) result = __result;
			{
				assert(isValidDchar(result));
			}
		}
		return __result;
	}

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(dchar _param_0)
	{
		return !__lambda2(_param_0);
	}

}
empty!(char[])
{
	pure nothrow @nogc @property @safe bool empty(scope char[] a)
	{
		return !a.length;
	}

}
graphemeStride!char
{
	pure @safe ulong graphemeStride(scope const(char[]) input, ulong index)
	{
		const(char)[] src = input[index..__dollar];
		ulong n = src.length;
		genericDecodeGrapheme(src);
		return n - src.length;
	}

}
genericDecodeGrapheme!false
{
	Value genericDecodeGrapheme(Input)(ref Input range)
	{
		import std.internal.unicode_tables : isHangL, isHangT, isHangV;
		enum GraphemeState
		{
			Start,
			CR,
			RI,
			L,
			V,
			LVT,
		}
		static if (getValue)
		{
			Grapheme grapheme;
		}

		auto state = GraphemeState.Start;
		enum eat = "\n            static if (getValue)\n                grapheme ~= ch;\n            range.popFront();\n        ";
		dchar ch;
		assert(!range.empty, "Attempting to decode grapheme from an empty " ~ Input.stringof);
		while (!range.empty)
		{
			ch = range.front;
			final switch (state)
			{
				with (GraphemeState)
				{
					case Start:
					{
						mixin(eat);
						if (ch == '\r')
							state = CR;
						else if (isRegionalIndicator(ch))
							state = RI;
						else if (isHangL(ch))
							state = L;
						else if (hangLV[ch] || isHangV(ch))
							state = V;
						else if (hangLVT[ch])
							state = LVT;
						else if (isHangT(ch))
							state = LVT;
						else
						{
							switch (ch)
							{
								mixin(controlSwitch);
								goto L_End;
								default:
								{
									goto L_End_Extend;
								}
							}
						}
						break;
					}
					case CR:
					{
						if (ch == '\n')
							mixin(eat);
						goto L_End_Extend;
					}
					case RI:
					{
						if (isRegionalIndicator(ch))
							mixin(eat);
						goto L_End_Extend;
					}
					case L:
					{
						if (isHangL(ch))
							mixin(eat);
						else if (isHangV(ch) || hangLV[ch])
						{
							state = V;
							mixin(eat);
						}
						else if (hangLVT[ch])
						{
							state = LVT;
							mixin(eat);
						}
						else
							goto L_End_Extend;
						break;
					}
					case V:
					{
						if (isHangV(ch))
							mixin(eat);
						else if (isHangT(ch))
						{
							state = LVT;
							mixin(eat);
						}
						else
							goto L_End_Extend;
						break;
					}
					case LVT:
					{
						if (isHangT(ch))
						{
							mixin(eat);
						}
						else
							goto L_End_Extend;
						break;
					}
				}
			}
		}
		L_End_Extend:
		while (!range.empty)
		{
			ch = range.front;
			if (!graphemeExtend[ch] && !spacingMark[ch])
				break;
			mixin(eat);
		}
		L_End:
		static if (getValue)
		{
			return grapheme;
		}

	}

}
genericDecodeGrapheme!(const(char)[])
{
	pure @safe void genericDecodeGrapheme(ref const(char)[] range)
	{
		import std.internal.unicode_tables : isHangL, isHangT, isHangV;
		enum GraphemeState : int
		{
			GraphemeState Start = cast(GraphemeState)0,
			GraphemeState CR = cast(GraphemeState)1,
			GraphemeState RI = cast(GraphemeState)2,
			GraphemeState L = cast(GraphemeState)3,
			GraphemeState V = cast(GraphemeState)4,
			GraphemeState LVT = cast(GraphemeState)5,
		}
		GraphemeState state = GraphemeState.Start;
		enum string eat = "\n            static if (getValue)\n                grapheme ~= ch;\n            range.popFront();\n        ";
		dchar ch = '\uffff';
		assert(!empty(range), "Attempting to decode grapheme from an empty const(char)[]");
		for (; !empty(range);)
		{
			{
				ch = front(range);
				final switch (state)
				{
					with (GraphemeState)
					{
						case GraphemeState.Start:
						{
							popFront(range);
							if (cast(uint)ch == 13u)
								state = GraphemeState.CR;
							else if (isRegionalIndicator(ch))
								state = GraphemeState.RI;
							else if (isHangL(ch))
								state = GraphemeState.L;
							else if (((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop284 = hangLV();) , __dop284.opIndex(ch)) || isHangV(ch))
								state = GraphemeState.V;
							else if ((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop288 = hangLVT();) , __dop288.opIndex(ch))
								state = GraphemeState.LVT;
							else if (isHangT(ch))
								state = GraphemeState.LVT;
							else
							{
								switch (cast(uint)ch)
								{
									case 0u:
									;
									case 1u:
									;
									case 2u:
									;
									case 3u:
									;
									case 4u:
									;
									case 5u:
									;
									case 6u:
									;
									case 7u:
									;
									case 8u:
									{
									}
									case 14u:
									;
									case 15u:
									;
									case 16u:
									;
									case 17u:
									;
									case 18u:
									;
									case 19u:
									;
									case 20u:
									;
									case 21u:
									;
									case 22u:
									;
									case 23u:
									;
									case 24u:
									;
									case 25u:
									;
									case 26u:
									;
									case 27u:
									;
									case 28u:
									;
									case 29u:
									;
									case 30u:
									;
									case 31u:
									{
									}
									case 127u:
									;
									case 128u:
									;
									case 129u:
									;
									case 130u:
									;
									case 131u:
									;
									case 132u:
									{
									}
									case 134u:
									;
									case 135u:
									;
									case 136u:
									;
									case 137u:
									;
									case 138u:
									;
									case 139u:
									;
									case 140u:
									;
									case 141u:
									;
									case 142u:
									;
									case 143u:
									;
									case 144u:
									;
									case 145u:
									;
									case 146u:
									;
									case 147u:
									;
									case 148u:
									;
									case 149u:
									;
									case 150u:
									;
									case 151u:
									;
									case 152u:
									;
									case 153u:
									;
									case 154u:
									;
									case 155u:
									;
									case 156u:
									;
									case 157u:
									;
									case 158u:
									;
									case 159u:
									{
									}
									case 9u:
									;
									case 10u:
									;
									case 11u:
									;
									case 12u:
									{
									}
									case 133u:
									{
									}
									goto L_End;
									default:
									{
										goto L_End_Extend;
									}
								}
							}
							break;
						}
						case GraphemeState.CR:
						{
							if (cast(uint)ch == 10u)
								popFront(range);
							goto L_End_Extend;
						}
						case GraphemeState.RI:
						{
							if (isRegionalIndicator(ch))
								popFront(range);
							goto L_End_Extend;
						}
						case GraphemeState.L:
						{
							if (isHangL(ch))
								popFront(range);
							else if (isHangV(ch) || ((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop289 = hangLV();) , __dop289.opIndex(ch)))
							{
								state = GraphemeState.V;
								popFront(range);
							}
							else if ((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop290 = hangLVT();) , __dop290.opIndex(ch))
							{
								state = GraphemeState.LVT;
								popFront(range);
							}
							else
								goto L_End_Extend;
							break;
						}
						case GraphemeState.V:
						{
							if (isHangV(ch))
								popFront(range);
							else if (isHangT(ch))
							{
								state = GraphemeState.LVT;
								popFront(range);
							}
							else
								goto L_End_Extend;
							break;
						}
						case GraphemeState.LVT:
						{
							if (isHangT(ch))
							{
								popFront(range);
							}
							else
								goto L_End_Extend;
							break;
						}
					}
					default:
					SwitchErrorStatement::toCBuffer()
				}
			}
		}
		L_End_Extend:
		for (; !empty(range);)
		{
			{
				ch = front(range);
				if (!((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop291 = graphemeExtendTrie();) , __dop291.opIndex(ch)) && !((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop292 = mcTrie();) , __dop292.opIndex(ch)))
					break;
				popFront(range);
			}
		}
		L_End:
	}

}
asTrie!(bool, 8, 5, 8)
{
	auto pure nothrow @nogc @safe const(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) asTrie(scope const(TrieEntry!(bool, 8, 5, 8)) e)
	{
		return Trie(MultiArray([0LU, 0LU, 0LU], [0LU, 0LU, 0LU], null)).this(e.offsets, e.sizes, e.data);
	}

}
sumOfIntegerTuple!(8, 5, 8)
{
	pure nothrow @nogc @property @safe ulong sumOfIntegerTuple()
	{
		ulong count = 0LU;
		/*unrolled*/ {
			{
				enum int v = 8;
				count += 8LU;
			}
			{
				enum int v = 5;
				count += 5LU;
			}
			{
				enum int v = 8;
				count += 8LU;
			}
		}
		return count;
	}

}
CodepointTrie!(bool, 8, 5, 8)
{
	alias CodepointTrie = Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU));

}
GetBitSlicing!(21LU, 8, 5, 8)
{
	alias GetBitSlicing = (sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU));

}
sliceBits!(13LU, 21LU)
{
	struct sliceBits
	{
		enum ulong bitSize = 8LU;
		static auto opCall(T)(T x)
		out(result)
		{
			assert(result < 1 << to - from);
		}
		do
		{
			static assert(from < to);
			static if (from == 0)
			{
				return x & (1 << to) - 1;
			}
			else
			{
				return x >> from & (1 << to - from) - 1;
			}
		}
	}

}
GetBitSlicing!(13LU, 5, 8)
{
	alias GetBitSlicing = (sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU));

}
sliceBits!(8LU, 13LU)
{
	struct sliceBits
	{
		enum ulong bitSize = 5LU;
		static auto opCall(T)(T x)
		out(result)
		{
			assert(result < 1 << to - from);
		}
		do
		{
			static assert(from < to);
			static if (from == 0)
			{
				return x & (1 << to) - 1;
			}
			else
			{
				return x >> from & (1 << to - from) - 1;
			}
		}
	}

}
GetBitSlicing!(8LU, 8)
{
	alias GetBitSlicing = (sliceBits!(0LU, 8LU));

}
sliceBits!(0LU, 8LU)
{
	struct sliceBits
	{
		enum ulong bitSize = 8LU;
		static auto opCall(T)(T x)
		out(result)
		{
			assert(result < 1 << to - from);
		}
		do
		{
			static assert(from < to);
			static if (from == 0)
			{
				return x & (1 << to) - 1;
			}
			else
			{
				return x >> from & (1 << to - from) - 1;
			}
		}
	}

}
GetBitSlicing!0LU
{
	alias GetBitSlicing = ();

}
isBitPackableType!bool
{
	enum bool isBitPackableType = true;

}
isBitPacked!bool
{
	enum bool isBitPacked = false;

}
isIntegral!bool
{
	enum bool isIntegral = false;

}
isValidArgsForTrie!(dchar, 1114112, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool isValidArgsForTrie = true;

}
isValidPrefixForTrie!(dchar, 1114112, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool isValidPrefixForTrie = false;

}
callableWith!dchar
{
	template callableWith(alias Pred)
	{
		static if (!is(typeof(Pred(T.init))))
		{
			enum callableWith = false;
		}
		else
		{
			alias Result = typeof(Pred(T.init));
			enum callableWith = isBitPackableType!(TypeOfBitPacked!Result
			{
			}
			)
			{
			}
			;
		}
	}

}
allSatisfy!(callableWith, 1114112, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool allSatisfy = false;

}
F!(1114112)
{
	enum bool callableWith = false;

}
isValidPrefixForTrie!(dchar, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool isValidPrefixForTrie = true;

}
allSatisfy!(callableWith, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool allSatisfy = true;

}
F!(sliceBits!(13LU, 21LU))
{
	enum bool callableWith = true;

}
opCall!dchar
{
	auto static pure nothrow @nogc @safe uint opCall(dchar x)
	out(result)
	{
		assert(result < 256u);
	}
	do
	{
		__result = cast(uint)x >> 13 & 255u;
		goto __returnLabel;
		__returnLabel:
		{
			const ref const(uint) result = __result;
			{
				assert(result < 256u);
			}
		}
		return __result;
	}

}
TypeOfBitPacked!uint
{
	alias TypeOfBitPacked = uint;

}
isBitPackableType!uint
{
	enum bool isBitPackableType = true;

}
isBitPacked!uint
{
	enum bool isBitPacked = false;

}
F!(sliceBits!(8LU, 13LU))
{
	enum bool callableWith = true;

}
opCall!dchar
{
	auto static pure nothrow @nogc @safe uint opCall(dchar x)
	out(result)
	{
		assert(result < 32u);
	}
	do
	{
		__result = cast(uint)x >> 8 & 31u;
		goto __returnLabel;
		__returnLabel:
		{
			const ref const(uint) result = __result;
			{
				assert(result < 32u);
			}
		}
		return __result;
	}

}
F!(sliceBits!(0LU, 8LU))
{
	enum bool callableWith = true;

}
opCall!dchar
{
	auto static pure nothrow @nogc @safe uint opCall(dchar x)
	out(result)
	{
		assert(result < 256u);
	}
	do
	{
		__result = cast(uint)x & 255u;
		goto __returnLabel;
		__returnLabel:
		{
			const ref const(uint) result = __result;
			{
				assert(result < 256u);
			}
		}
		return __result;
	}

}
TrieBuilder!(bool, dchar, 1114112, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	struct TrieBuilder
	{
		import std.exception : enforce;
		private
		{
			static if (is(bool == bool))
			{
				alias V = BitPacked!(bool, 1LU);
			}
			else
			{
				alias V = Value;
			}
			static auto deduceMaxIndex(Preds...)()
			{
				size_t idx = 1;
				foreach (v; Preds)
				{
					idx *= 2 ^^ v.bitSize;
				}
				return idx;
			}
			static if (is(int : dchar))
			{
				alias Prefix = Args;
				enum @trusted ulong lastPageSize = 256LU;
				enum @trusted ulong translatedMaxIndex = 1114112LU;
				enum @trusted ulong roughedMaxIndex = 1114112LU;
				enum @trusted ulong maxIndex = 1114112LU;
			}
			else
			{
				alias Prefix = Args;
				enum maxIndex = deduceMaxIndex!Prefix
				{
				}
				();
			}
			alias getIndex = size_t mapTrieIndex(Key)(Key key) if (isValidPrefixForTrie!(Key, Prefix)
			{
			}
			)
			{
				alias p = Prefix;
				size_t idx;
				foreach (i, v; p[0..__dollar - 1])
				{
					idx |= p[i](key);
					idx <<= p[i + 1].bitSize;
				}
				idx |= p[__dollar - 1](key);
				return idx;
			}
			;
			enum @trusted ulong lastLevel = 2LU;
			struct ConstructState
			{
				@trusted ulong idx_zeros;
				@trusted ulong idx_ones;
			}
			@trusted ulong[3] indices;
			@trusted bool defValue;
			@trusted ulong curIndex;
			@trusted ConstructState[3] state;
			@trusted MultiArray!(BitPacked!(uint, 8LU), BitPacked!(uint, 13LU), BitPacked!(bool, 1LU)) table;
			@disable @trusted this();
			@property ref idx(ulong level)()
			{
				return indices[level];
			}
			void addValue(ulong level, T)(T val, size_t numVals)
			{
				alias j = idx!level
				{
				}
				;
				enum pageSize = 1 << Prefix[level].bitSize;
				if (numVals == 0)
					return ;
				auto ptr = table.slice!level
				{
				}
				;
				if (numVals == 1)
				{
					static if (level == Prefix.length - 1)
					{
						ptr[j] = val;
					}
					else
					{
						assert(j < ptr.length);
						ptr[j] = force!(typeof(ptr[j]))
						{
						}
						(val);
					}
					j++;
					if (j % pageSize == 0)
						spillToNextPage!level
						{
						}
						(ptr);
					return ;
				}
				immutable nextPB = j + pageSize & ~(pageSize - 1);
				immutable n = nextPB - j;
				if (numVals < n)
				{
					ptr[j..j + numVals] = val;
					j += numVals;
					return ;
				}
				static if (level != 0)
				{
					numVals -= n;
					ptr[j..j + n] = val;
					j += n;
					spillToNextPage!level
					{
					}
					(ptr);
					if (state[level].idx_zeros != size_t.max && (val == T.init))
					{
						alias NextIdx = typeof(table.slice!(level - 1)
						{
						}
						[0]);
						addValue!(level - 1)
						{
						}
						(force!NextIdx
						{
						}
						(state[level].idx_zeros), numVals / pageSize);
						ptr = table.slice!level
						{
						}
						;
						numVals %= pageSize;
					}
					else
					{
						while (numVals >= pageSize)
						{
							numVals -= pageSize;
							ptr[j..j + pageSize] = val;
							j += pageSize;
							spillToNextPage!level
							{
							}
							(ptr);
						}
					}
					if (numVals)
					{
						ptr[j..j + numVals] = val;
						j += numVals;
					}
				}

			}
			void spillToNextPage(ulong level, Slice)(ref Slice ptr)
			{
				static if (level != 0)
				{
					spillToNextPageImpl!level
					{
					}
					(ptr);
				}

			}
			void spillToNextPageImpl(ulong level, Slice)(ref Slice ptr)
			{
				alias NextIdx = typeof(table.slice!(level - 1)
				{
				}
				[0]);
				NextIdx next_lvl_index;
				enum pageSize = 1 << Prefix[level].bitSize;
				assert(idx!level
				{
				}
				 % pageSize == 0);
				immutable last = idx!level
				{
				}
				 - pageSize;
				const slice = ptr[idx!level
				{
				}
				 - pageSize..idx!level
				{
				}
				];
				size_t j;
				for (j = 0; j < last; j += pageSize)
				{
					{
						if (ptr[j..j + pageSize] == slice)
						{
							next_lvl_index = force!NextIdx
							{
							}
							(j / pageSize);
							version (none)
							{
								import std.stdio : writefln, writeln;
								writefln("LEVEL(%s) page mapped idx: %s: 0..%s  ---> [%s..%s]", level, indices[level - 1], pageSize, j, j + pageSize);
								writeln("LEVEL(", level, ") mapped page is: ", slice, ": ", arrayRepr(ptr[j..j + pageSize]));
								writeln("LEVEL(", level, ") src page is :", ptr, ": ", arrayRepr(slice[0..pageSize]));
							}

							idx!level
							{
							}
							 -= pageSize;
							break;
						}
					}
				}
				if (j == last)
				{
					L_allocate_page:
					next_lvl_index = force!NextIdx
					{
					}
					(idx!level
					{
					}
					 / pageSize - 1);
					if (state[level].idx_zeros == size_t.max && ptr.zeros(j, j + pageSize))
					{
						state[level].idx_zeros = next_lvl_index;
					}
					version (none)
					{
						import std.stdio : writefln;
						writefln("LEVEL(%s) page allocated: %s", level, arrayRepr(slice[0..pageSize]));
						writefln("LEVEL(%s) index: %s ; page at this index %s", level, next_lvl_index, arrayRepr(table.slice!level
						{
						}
						[pageSize * next_lvl_index..(next_lvl_index + 1) * pageSize]));
					}

					table.length!level
					{
					}
					 = table.length!level
					{
					}
					 + pageSize;
				}
				L_know_index:
				addValue!(level - 1)
				{
				}
				(next_lvl_index, 1);
				ptr = table.slice!level
				{
				}
				;
			}
			pure nothrow @trusted void putAt(ulong idx, bool v)
			{
				assert(idx >= this.curIndex);
				immutable immutable(ulong) numFillers = idx - this.curIndex;
				this.addValue(this.defValue, numFillers);
				this.addValue(v, 1LU);
				this.curIndex = idx + 1LU;
			}
			pure nothrow @trusted void putRangeAt(ulong idxA, ulong idxB, bool v)
			{
				assert(idxA >= this.curIndex);
				assert(idxB >= idxA);
				ulong numFillers = idxA - this.curIndex;
				this.addValue(this.defValue, numFillers);
				this.addValue(v, idxB - idxA);
				this.curIndex = idxB;
			}
			enum @trusted string errMsg = "non-monotonic prefix function(s), an unsorted range or duplicate key->value mapping";
			public
			{
				pure nothrow @trusted this(bool filler)
				{
					this.curIndex = 0LU;
					this.defValue = filler;
					{
						ConstructState[] __r249 = this.state[];
						ulong __key250 = 0LU;
						for (; __key250 < __r249.length; __key250 += 1LU)
						{
							ref ConstructState v = __r249[__key250];
							v = ConstructState(18446744073709551615LU, 18446744073709551615LU);
						}
					}
					this.table = 0 , this.table.this(cast(ulong[])this.indices);
					/*unrolled*/ {
						{
							enum ulong i = 0LU;
							alias Pred = sliceBits!(13LU, 21LU);
							this.table.length(256LU);
						}
						{
							enum ulong i = 1LU;
							alias Pred = sliceBits!(8LU, 13LU);
							this.table.length(32LU);
						}
						{
							enum ulong i = 2LU;
							alias Pred = sliceBits!(0LU, 8LU);
							this.table.length(256LU);
						}
					}
					return this;
				}
				pure @trusted void putRange(dchar a, dchar b, bool v)
				{
					ulong idxA = mapTrieIndex(a);
					ulong idxB = mapTrieIndex(b);
					enforce(idxB >= idxA && (idxA >= this.curIndex), delegate const(char)[]() pure nothrow @nogc @safe => "non-monotonic prefix function(s), an unsorted range or duplicate key->value mapping", "/usr/include/dmd/phobos/std/uni/package.d", 4065LU);
					this.putRangeAt(idxA, idxB, v);
				}
				pure @trusted void putValue(dchar key, bool v)
				{
					ulong idx = mapTrieIndex(key);
					enforce(idx >= this.curIndex, delegate const(char)[]() pure nothrow @nogc @safe => "non-monotonic prefix function(s), an unsorted range or duplicate key->value mapping", "/usr/include/dmd/phobos/std/uni/package.d", 4077LU);
					this.putAt(idx, v);
				}
				auto pure nothrow @trusted Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU)) build()
				{
					assert(this.curIndex <= 1114112LU);
					this.addValue(this.defValue, 1114112LU - this.curIndex);
					return Trie(MultiArray([0LU, 0LU, 0LU], [0LU, 0LU, 0LU], null)).this(this.table);
				}
			}
		}
	}

}
BitPacked!(bool, 1LU)
{
	struct BitPacked
	{
		enum ulong bitSize = 1LU;
		bool _value;
		alias _value this;
}

}
mapTrieIndex!(sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	size_t mapTrieIndex(Key)(Key key) if (isValidPrefixForTrie!(Key, Prefix)
	{
	}
	)
	{
		alias p = Prefix;
		size_t idx;
		foreach (i, v; p[0..__dollar - 1])
		{
			idx |= p[i](key);
			idx <<= p[i + 1].bitSize;
		}
		idx |= p[__dollar - 1](key);
		return idx;
	}

}
isValidPrefixForTrie!(int, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool isValidPrefixForTrie = true;

}
callableWith!int
{
	template callableWith(alias Pred)
	{
		static if (!is(typeof(Pred(T.init))))
		{
			enum callableWith = false;
		}
		else
		{
			alias Result = typeof(Pred(T.init));
			enum callableWith = isBitPackableType!(TypeOfBitPacked!Result
			{
			}
			)
			{
			}
			;
		}
	}

}
allSatisfy!(callableWith, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool allSatisfy = true;

}
F!(sliceBits!(13LU, 21LU))
{
	enum bool callableWith = true;

}
opCall!int
{
	auto static pure nothrow @nogc @safe int opCall(int x)
	out(result)
	{
		assert(result < 256);
	}
	do
	{
		__result = x >> 13 & 255;
		goto __returnLabel;
		__returnLabel:
		{
			const ref const(int) result = __result;
			{
				assert(result < 256);
			}
		}
		return __result;
	}

}
TypeOfBitPacked!int
{
	alias TypeOfBitPacked = int;

}
isBitPackableType!int
{
	enum bool isBitPackableType = true;

}
isBitPacked!int
{
	enum bool isBitPacked = false;

}
F!(sliceBits!(8LU, 13LU))
{
	enum bool callableWith = true;

}
opCall!int
{
	auto static pure nothrow @nogc @safe int opCall(int x)
	out(result)
	{
		assert(result < 32);
	}
	do
	{
		__result = x >> 8 & 31;
		goto __returnLabel;
		__returnLabel:
		{
			const ref const(int) result = __result;
			{
				assert(result < 32);
			}
		}
		return __result;
	}

}
F!(sliceBits!(0LU, 8LU))
{
	enum bool callableWith = true;

}
opCall!int
{
	auto static pure nothrow @nogc @safe int opCall(int x)
	out(result)
	{
		assert(result < 256);
	}
	do
	{
		__result = x & 255;
		goto __returnLabel;
		__returnLabel:
		{
			const ref const(int) result = __result;
			{
				assert(result < 256);
			}
		}
		return __result;
	}

}
mapTrieIndex!int
{
	pure nothrow @nogc @safe ulong mapTrieIndex(int key)
	{
		alias p = (sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU));
		ulong idx = 0LU;
		/*unrolled*/ {
			{
				enum ulong i = 0LU;
				alias v = sliceBits!(13LU, 21LU);
				idx |= cast(ulong)opCall(key);
				idx <<= 5;
			}
			{
				enum ulong i = 1LU;
				alias v = sliceBits!(8LU, 13LU);
				idx |= cast(ulong)opCall(key);
				idx <<= 8;
			}
		}
		idx |= cast(ulong)opCall(key);
		return idx;
	}

}
deduceMaxIndex!(sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	auto static pure nothrow @nogc @trusted ulong deduceMaxIndex()
	{
		ulong idx = 1LU;
		/*unrolled*/ {
			{
				alias v = sliceBits!(13LU, 21LU);
				idx *= 256LU;
			}
			{
				alias v = sliceBits!(8LU, 13LU);
				idx *= 32LU;
			}
			{
				alias v = sliceBits!(0LU, 8LU);
				idx *= 256LU;
			}
		}
		return idx;
	}

}
fullBitSize!(sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum ulong fullBitSize = 21LU;

}
bitSizeOf!(sliceBits!(13LU, 21LU))
{
	enum ulong bitSizeOf = 8LU;

}
fullBitSize!(sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum ulong fullBitSize = 13LU;

}
bitSizeOf!(sliceBits!(8LU, 13LU))
{
	enum ulong bitSizeOf = 5LU;

}
fullBitSize!(sliceBits!(0LU, 8LU))
{
	enum ulong fullBitSize = 8LU;

}
bitSizeOf!(sliceBits!(0LU, 8LU))
{
	enum ulong bitSizeOf = 8LU;

}
fullBitSize!()
{
	enum int fullBitSize = 0;

}
idxTypes!(dchar, 21LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	alias idxTypes = (BitPacked!(uint, 8LU), BitPacked!(uint, 13LU));

}
idxTypes!(dchar, 13LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU))
{
	alias idxTypes = (BitPacked!(uint, 8LU));

}
idxTypes!(dchar, 8LU, sliceBits!(13LU, 21LU))
{
	alias idxTypes = ();

}
BitPacked!(uint, 8LU)
{
	struct BitPacked
	{
		enum ulong bitSize = 8LU;
		uint _value;
		alias _value this;
}

}
BitPacked!(uint, 13LU)
{
	struct BitPacked
	{
		enum ulong bitSize = 13LU;
		uint _value;
		alias _value this;
}

}
MultiArray!(BitPacked!(uint, 8LU), BitPacked!(uint, 13LU), BitPacked!(bool, 1LU))
{
	struct MultiArray
	{
		import std.range.primitives : isOutputRange;
		pure nothrow @safe this(ulong[] sizes...)
		{
			assert(3LU == sizes.length);
			ulong full_size = 0LU;
			/*unrolled*/ {
				{
					enum ulong i = 0LU;
					alias v = BitPacked!(uint, 8LU);
					full_size += spaceFor(sizes[0]);
					this.sz[0] = sizes[0];
				}
				{
					enum ulong i = 1LU;
					alias v = BitPacked!(uint, 13LU);
					full_size += spaceFor(sizes[1]);
					this.sz[1] = sizes[1];
					this.offsets[1] = this.offsets[0] + spaceFor(sizes[0]);
				}
				{
					enum ulong i = 2LU;
					alias v = BitPacked!(bool, 1LU);
					full_size += spaceFor(sizes[2]);
					this.sz[2] = sizes[2];
					this.offsets[2] = this.offsets[1] + spaceFor(sizes[1]);
				}
			}
			this.storage = new ulong[](full_size);
			return this;
		}
		return scope const pure nothrow @nogc scope @safe this(const(ulong)[] raw_offsets, const(ulong)[] raw_sizes, return scope const(ulong)[] data) return
		{
			this.offsets[] = raw_offsets[];
			this.sz[] = raw_sizes[];
			this.storage = data;
			return this;
		}
		auto inout pure nothrow @nogc @property slice(ulong n)()
		{
			auto ptr = raw_ptr!n
			{
			}
			;
			return packedArrayView!(Types[n])
			{
			}
			(ptr, sz[n]);
		}
		auto inout pure nothrow @nogc @property ptr(ulong n)()
		{
			auto ptr = raw_ptr!n
			{
			}
			;
			return inout(PackedPtr!(Types[n])
			{
			}
			)(ptr);
		}
		template length(ulong n)
		{
			const pure nothrow @nogc @property @safe size_t length()
			{
				return sz[n];
			}
			@property void length(size_t new_size)
			{
				if (new_size > sz[n])
				{
					size_t delta = new_size - sz[n];
					sz[n] += delta;
					delta = spaceFor!(bitSizeOf!(Types[n])
					{
					}
					)
					{
					}
					(delta);
					storage.length += delta;
					static if (n != dim - 1)
					{
						auto start = raw_ptr!(n + 1)
						{
						}
						;
						size_t len = storage.ptr + storage.length - start;
						copyBackwards(start[0..len - delta], start[delta..len]);
						start[0..delta] = 0;
						foreach (i; n + 1 .. dim)
						{
							offsets[i] += delta;
						}
					}

				}
				else if (new_size < sz[n])
				{
					size_t delta = sz[n] - new_size;
					sz[n] -= delta;
					delta = spaceFor!(bitSizeOf!(Types[n])
					{
					}
					)
					{
					}
					(delta);
					static if (n != dim - 1)
					{
						auto start = raw_ptr!(n + 1)
						{
						}
						;
						size_t len = storage.ptr + storage.length - start;
						copyForward(start[0..len - delta], start[delta..len]);
						foreach (i; n + 1 .. dim)
						{
							offsets[i] -= delta;
						}
					}

					storage.length -= delta;
				}
			}
		}
		const @property @safe size_t bytes(ulong n = size_t.max)()
		{
			static if (n == size_t.max)
			{
				return storage.length * size_t.sizeof;
			}
			else
			{
				static if (n != Types.length - 1)
				{
					return (raw_ptr!(n + 1)
					{
					}
					 - raw_ptr!n
					{
					}
					) * size_t.sizeof;
				}
				else
				{
					return (storage.ptr + storage.length - raw_ptr!n
					{
					}
					) * size_t.sizeof;
				}
			}
		}
		const void store(OutRange)(scope OutRange sink) if (isOutputRange!(OutRange, char)
		{
		}
		)
		{
			import std.format.write : formattedWrite;
			formattedWrite(sink, "[%( 0x%x, %)]", offsets[]);
			formattedWrite(sink, ", [%( 0x%x, %)]", sz[]);
			formattedWrite(sink, ", [%( 0x%x, %)]", storage);
		}
		private
		{
			import std.meta : staticMap;
			auto inout pure nothrow @nogc @property raw_ptr(ulong n)()
			{
				static if (n == 0)
				{
					return storage.ptr;
				}
				else
				{
					return storage.ptr + offsets[n];
				}
			}
			enum ulong dim = 3LU;
			ulong[3] offsets;
			ulong[3] sz;
			alias bitWidth = staticMap;
			ulong[] storage;
		}
	}

}
staticMap!(bitSizeOf, BitPacked!(uint, 8LU), BitPacked!(uint, 13LU), BitPacked!(bool, 1LU))
{
	staticMap
}
fun!(BitPacked!(uint, 8LU))
{
	enum ulong bitSizeOf = 8LU;

}
fun!(BitPacked!(uint, 13LU))
{
	enum ulong bitSizeOf = 13LU;

}
fun!(BitPacked!(bool, 1LU))
{
	enum ulong bitSizeOf = 1LU;

}
spaceFor!8LU
{
	pure nothrow @nogc @safe ulong spaceFor(ulong new_len)
	{
		import std.math.algebraic : nextPow2;
		enum ulong bits = 8LU;
		enum ulong factor = 8LU;
		return (new_len + 8LU - 1LU) / 8LU;
	}

}
isFloatingPoint!ulong
{
	enum bool isFloatingPoint = false;

}
nextPow2!ulong
{
	pure nothrow @nogc @safe ulong nextPow2(const(ulong) val)
	{
		return powIntegralImpl(val);
	}

}
powIntegralImpl!(PowType.ceil, const(ulong))
{
	pure nothrow @nogc @safe const(ulong) powIntegralImpl(const(ulong) val)
	{
		import core.bitop : bsr;
		if (val == 0LU || (val > 9223372036854775807LU || val == 0LU))
			return 0LU;
		else
		{
			return 1LU << bsr(val) + PowType.ceil;
		}
	}

}
isSigned!(const(ulong))
{
	enum bool isSigned = false;

}
Unqual!(const(ulong), ulong)
{
	alias Unqual = ulong;

}
spaceFor!13LU
{
	pure nothrow @nogc @safe ulong spaceFor(ulong new_len)
	{
		import std.math.algebraic : nextPow2;
		enum ulong bits = 16LU;
		enum ulong factor = 4LU;
		return (new_len + 4LU - 1LU) / 4LU;
	}

}
spaceFor!1LU
{
	pure nothrow @nogc @safe ulong spaceFor(ulong new_len)
	{
		import std.math.algebraic : nextPow2;
		enum ulong bits = 1LU;
		enum ulong factor = 64LU;
		return (new_len + 64LU - 1LU) / 64LU;
	}

}
length!0LU
{
	const pure nothrow @nogc @property @safe ulong length()
	{
		return this.sz[0];
	}

}
_d_arraysetlengthTImpl!(ulong[], ulong)
{
	import core.internal.array.utils : _d_HookTraceImpl;
	private enum string errorMessage = "Cannot resize arrays if compiling without support for runtime type information!";
	pure nothrow @trusted ulong _d_arraysetlengthT(ref return scope ulong[] arr, ulong newlength)
	{
		TypeInfo_Array ti = typeid(ulong[]);
		_d_arraysetlengthT(ti, newlength, cast(void[]*)&arr);
		return arr.length;
	}
	alias _d_arraysetlengthTTrace = auto pure nothrow @trusted ulong _d_HookTraceImpl(string file, int line, string funcname, ref return scope ulong[] _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "ulong[]";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arraysetlengthT(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}
	;
}
_d_HookTraceImpl!(ulong[], _d_arraysetlengthT, "Cannot resize arrays if compiling without support for runtime type information!")
{
	auto pure nothrow @trusted ulong _d_HookTraceImpl(string file, int line, string funcname, ref return scope ulong[] _param_3, ulong _param_4)
	{
		import core.internal.array.utils : gcStatsPure, accumulatePure;
		string name = "ulong[]";
		ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;
		try
		{
			return _d_arraysetlengthT(_param_3, _param_4);
		}
		finally
		{
			ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;
			if (size > 0LU)
				if (!accumulatePure(file, line, funcname, name, size))
				{
					assert(0);
				}
		}
	}

}
Parameters!(_d_arraysetlengthT)
{
	alias Parameters = (ref return scope ulong[], ulong);

}
FunctionTypeOf!(_d_arraysetlengthT)
{
	alias pure nothrow @trusted ulong FunctionTypeOf(ref return scope ulong[] arr, ulong newlength);

}
raw_ptr!1LU
{
	auto inout pure nothrow @nogc @property @system inout(ulong)* raw_ptr() return
	{
		return cast(inout(ulong)*)this.storage + cast(long)this.offsets[1] * 8L;
	}

}
copyBackwards!(ulong, ulong)
{
	pure nothrow @nogc @safe void copyBackwards(ulong[] src, ulong[] dest)
	{
		assert(src.length == dest.length);
		{
			ulong i = src.length;
			for (; i-- > 0LU;)
			{
				dest[i] = src[i];
			}
		}
	}

}
copyForward!(ulong, ulong)
{
	pure nothrow @nogc @safe void copyForward(ulong[] src, ulong[] dest)
	{
		assert(src.length == dest.length);
		{
			ulong i = 0LU;
			for (; i < src.length; i++)
			{
				dest[i] = src[i];
			}
		}
	}

}
length!1LU
{
	const pure nothrow @nogc @property @safe ulong length()
	{
		return this.sz[1];
	}

}
raw_ptr!2LU
{
	auto inout pure nothrow @nogc @property @system inout(ulong)* raw_ptr() return
	{
		return cast(inout(ulong)*)this.storage + cast(long)this.offsets[2] * 8L;
	}

}
length!2LU
{
	const pure nothrow @nogc @property @safe ulong length()
	{
		return this.sz[2];
	}

}
addValue!(2LU, bool)
{
	pure nothrow @trusted void addValue(bool val, ulong numVals)
	{
		alias j = pure nothrow @nogc @property ref @trusted ulong idx() return
		{
			return this.indices[2];
		}
		;
		enum int pageSize = 256;
		if (numVals == 0LU)
			return ;
		PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU) ptr = this.table.slice();
		if (numVals == 1LU)
		{
			ptr.opIndexAssign(val, this.idx());
			this.idx()++;
			if (this.idx() % 256LU == 0LU)
				this.spillToNextPage(ptr);
			return ;
		}
		immutable immutable(ulong) nextPB = this.idx() + 256LU & 18446744073709551360LU;
		immutable immutable(ulong) n = nextPB - this.idx();
		if (numVals < n)
		{
			ptr.opSliceAssign(val, this.idx(), this.idx() + numVals);
			this.idx() += numVals;
			return ;
		}
		numVals -= n;
		ptr.opSliceAssign(val, this.idx(), this.idx() + n);
		this.idx() += n;
		this.spillToNextPage(ptr);
		if (this.state[2].idx_zeros != 18446744073709551615LU && (cast(int)val == 0))
		{
			alias NextIdx = BitPacked!(uint, 13LU);
			this.addValue(force(this.state[2].idx_zeros), numVals / 256LU);
			ptr = this.table.slice();
			numVals %= 256LU;
		}
		else
		{
			for (; numVals >= 256LU;)
			{
				{
					numVals -= 256LU;
					ptr.opSliceAssign(val, this.idx(), this.idx() + 256LU);
					this.idx() += 256LU;
					this.spillToNextPage(ptr);
				}
			}
		}
		if (numVals)
		{
			ptr.opSliceAssign(val, this.idx(), this.idx() + numVals);
			this.idx() += numVals;
		}
	}

}
idx!2LU
{
	pure nothrow @nogc @property ref @trusted ulong idx() return
	{
		return this.indices[2];
	}

}
slice!2LU
{
	auto inout pure nothrow @nogc @property @system inout(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU)) slice()
	{
		inout(ulong)* ptr = this.raw_ptr();
		return packedArrayView(ptr, this.sz[2]);
	}

}
packedArrayView!(BitPacked!(bool, 1LU))
{
	pure nothrow @nogc @safe inout(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU)) packedArrayView(inout(ulong)* ptr, ulong items)
	{
		return PackedArrayViewImpl(PackedPtrImpl(null), 0LU, 0LU).this(ptr, 0LU, items);
	}

}
PackedArrayView!(BitPacked!(bool, 1LU))
{
	alias PackedArrayView = PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU);

}
PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU)
{
	struct PackedArrayViewImpl
	{
		nothrow pure
		{
			inout pure nothrow @nogc @safe this(inout(ulong)* origin, ulong offset, ulong items)
			{
				this.ptr = 0 , this.ptr.this(origin);
				this.ofs = offset;
				this.limit = items;
				return this;
			}
			pure nothrow @nogc @system bool zeros(ulong s, ulong e)
			in
			{
				assert(s <= e);
			}
			do
			{
				{
					{
						assert(s <= e);
					}
				}
				s += this.ofs;
				e += this.ofs;
				immutable immutable(ulong) pad_s = this.roundUp(s);
				if (s >= e)
				{
					{
						ulong __key269 = s;
						ulong __limit270 = e;
						for (; __key269 < __limit270; __key269 += 1LU)
						{
							ulong i = __key269;
							if (this.ptr.opIndex(i)._value)
								return false;
						}
					}
					return true;
				}
				immutable immutable(ulong) pad_e = this.roundDown(e);
				ulong i = 0LU;
				{
					i = s;
					for (; i < pad_s; i++)
					{
						if (this.ptr.opIndex(i)._value)
							return false;
					}
				}
				{
					ulong j = i / 64LU;
					for (; i < pad_e; i += 64LU , j++)
					{
						if (this.ptr.origin[j])
							return false;
					}
				}
				for (; i < e; i++)
				{
					if (this.ptr.opIndex(i)._value)
						return false;
				}
				return true;
			}
			inout pure nothrow @nogc @system BitPacked!(bool, 1LU) opIndex(ulong idx)
			in
			{
				assert(idx < this.limit);
			}
			do
			{
				{
					{
						assert(idx < this.limit);
					}
				}
				return this.ptr.opIndex(this.ofs + idx);
			}
			static if (isBitPacked!(BitPacked!(bool, 1LU))
			{
				enum bool isBitPacked = true;

			}
			)
			{
				pure nothrow @nogc @system void opIndexAssign(BitPacked!(bool, 1LU) val, ulong idx)
				{
					this.opIndexAssign(val._value, idx);
					return ;
				}
			}
			pure nothrow @nogc @system void opIndexAssign(bool val, ulong idx)
			in
			{
				assert(idx < this.limit);
			}
			do
			{
				{
					{
						assert(idx < this.limit);
					}
				}
				this.ptr.opIndexAssign(val, this.ofs + idx);
			}
			static if (isBitPacked!(BitPacked!(bool, 1LU))
			{
			}
			)
			{
				pure nothrow @nogc @system void opSliceAssign(BitPacked!(bool, 1LU) val, ulong start, ulong end)
				{
					this.opSliceAssign(val._value, start, end);
				}
			}
			pure nothrow @nogc @system void opSliceAssign(bool val, ulong start, ulong end)
			in
			{
				assert(start <= end);
				assert(end <= this.limit);
			}
			do
			{
				{
					{
						assert(start <= end);
						assert(end <= this.limit);
					}
				}
				start += this.ofs;
				end += this.ofs;
				immutable immutable(ulong) pad_start = this.roundUp(start);
				if (pad_start >= end)
				{
					{
						ulong __key279 = start;
						ulong __limit280 = end;
						for (; __key279 < __limit280; __key279 += 1LU)
						{
							ulong i = __key279;
							this.ptr.opIndexAssign(val, i);
						}
					}
					return ;
				}
				immutable immutable(ulong) pad_end = this.roundDown(end);
				ulong i = 0LU;
				{
					i = start;
					for (; i < pad_start; i++)
					{
						this.ptr.opIndexAssign(val, i);
					}
				}
				if (pad_start != pad_end)
				{
					immutable immutable(ulong) repval = replicateBits(cast(ulong)val);
					{
						ulong j = i / 64LU;
						for (; i < pad_end; i += 64LU , j++)
						{
							this.ptr.origin[j] = repval;
						}
					}
				}
				for (; i < end; i++)
				{
					this.ptr.opIndexAssign(val, i);
				}
			}
			auto inout pure nothrow @nogc @safe inout(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU)) opSlice(ulong from, ulong to) return
			in
			{
				assert(from <= to);
				assert(this.ofs + to <= this.limit);
			}
			do
			{
				{
					{
						assert(from <= to);
						assert(this.ofs + to <= this.limit);
					}
				}
				return PackedArrayViewImpl(PackedPtrImpl(null), 0LU, 0LU).this(this.ptr.origin, this.ofs + from, to - from);
			}
			auto pure nothrow @nogc @safe PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU) opSlice() return
			{
				return this.opSlice(0LU, this.length());
			}
			const bool opEquals(T)(auto ref T arr)
			{
				if (limit != arr.limit)
					return false;
				size_t s1 = ofs, s2 = arr.ofs;
				size_t e1 = s1 + limit, e2 = s2 + limit;
				if (s1 % factor == 0 && (s2 % factor == 0) && (length % factor == 0))
				{
					return ptr.origin[s1 / factor..e1 / factor] == arr.ptr.origin[s2 / factor..e2 / factor];
				}
				for (size_t i = 0;
				 i < limit; i++)
				{
					if (this[i] != arr[i])
						return false;
				}
				return true;
			}
			const pure nothrow @nogc @property @safe ulong length()
			{
				return this.limit;
			}
			private
			{
				auto roundUp()(size_t val)
				{
					return (val + factor - 1) / factor * factor;
				}
				auto roundDown()(size_t val)
				{
					return val / factor * factor;
				}
				enum nothrow pure ulong factor = 64LU;
				nothrow pure PackedPtrImpl!(BitPacked!(bool, 1LU), 1LU) ptr;
				nothrow pure ulong ofs;
				nothrow pure ulong limit;
			}
		}
	}

}
isBitPacked!(BitPacked!(bool, 1LU))
{
	enum bool isBitPacked = true;

}
TypeOfBitPacked!(BitPacked!(bool, 1LU))
{
	alias TypeOfBitPacked = bool;

}
PackedPtr!(BitPacked!(bool, 1LU))
{
	alias PackedPtr = PackedPtrImpl!(BitPacked!(bool, 1LU), 1LU);

}
PackedPtrImpl!(BitPacked!(bool, 1LU), 1LU)
{
	struct PackedPtrImpl
	{
		nothrow pure
		{
			static assert(isPow2OrZero(1LU));
			inout pure nothrow @nogc @safe this(inout(ulong)* ptr)
			{
				this.origin = ptr;
				return this;
			}
			private inout pure nothrow @nogc @system BitPacked!(bool, 1LU) simpleIndex(ulong n)
			{
				immutable immutable(ulong) q = n / 64LU;
				immutable immutable(ulong) r = n % 64LU;
				return BitPacked(cast(bool)(this.origin[q] >> cast(int)(1LU * r) & 1LU));
			}
			private pure nothrow @nogc @system void simpleWrite(bool val, ulong n)
			in
			{
			}
			do
			{
				{
					{
					}
				}
				immutable immutable(ulong) q = n / 64LU;
				immutable immutable(ulong) r = n % 64LU;
				immutable immutable(ulong) tgt_shift = 1LU * r;
				immutable immutable(ulong) word = this.origin[q];
				this.origin[q] = word & ~(1LU << cast(int)tgt_shift) | cast(ulong)val << cast(int)tgt_shift;
			}
			static if (64LU == 8LU || 64LU == 1LU || (64LU == 4LU || 64LU == 2LU) && hasUnalignedReads)
			{
				static if (factor == bytesPerWord)
				{
					alias U = ubyte;
				}
				else
				{
					static if (factor == bytesPerWord / 2)
					{
						alias U = ushort;
					}
					else
					{
						static if (factor == bytesPerWord / 4)
						{
							alias U = uint;
						}
						else
						{
							static if (size_t.sizeof == 8 && (factor == bytesPerWord / 8))
							{
								alias U = ulong;
							}
						}
					}
				}
				inout T opIndex(size_t idx)
				{
					T ret;
					version (LittleEndian)
					{
						ret = __ctfe ? simpleIndex(idx) : cast(inout(T))(cast(U*)origin)[idx];
					}
					else
					{
						ret = simpleIndex(idx);
					}
					return ret;
				}
				static if (isBitPacked!T
				{
				}
				)
				{
					void opIndexAssign(T val, size_t idx)
					{
						return opIndexAssign(cast(TypeOfBitPacked!T
						{
						}
						)val, idx);
					}
				}
				void opIndexAssign(TypeOfBitPacked!T
				{
				}
				 val, size_t idx)
				{
					version (LittleEndian)
					{
						if (__ctfe)
							simpleWrite(val, idx);
						else
							(cast(U*)origin)[idx] = cast(U)val;
					}
					else
					{
						simpleWrite(val, idx);
					}
				}
			}
			else
			{
				inout pure nothrow @nogc @system BitPacked!(bool, 1LU) opIndex(ulong n)
				{
					return this.simpleIndex(n);
				}
				static if (isBitPacked!(BitPacked!(bool, 1LU))
				{
				}
				)
				{
					pure nothrow @nogc @system void opIndexAssign(BitPacked!(bool, 1LU) val, ulong idx)
					{
						this.opIndexAssign(val._value, idx);
						return ;
					}
				}
				pure nothrow @nogc @system void opIndexAssign(bool val, ulong n)
				{
					this.simpleWrite(val, n);
					return ;
				}
			}
			private
			{
				enum nothrow pure ulong factor = 64LU;
				enum nothrow pure ulong mask = 1LU;
				enum nothrow pure ulong bytesPerWord = 8LU;
				nothrow pure ulong* origin;
			}
		}
	}

}
opEquals!(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU))
{
	const pure nothrow @nogc @system bool opEquals(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU) arr)
	{
		if (this.limit != arr.limit)
			return false;
		ulong s1 = this.ofs;
		ulong s2 = arr.ofs;
		ulong e1 = s1 + this.limit;
		ulong e2 = s2 + this.limit;
		if (s1 % 64LU == 0LU && (s2 % 64LU == 0LU) && (this.length() % 64LU == 0LU))
		{
			return __equals(this.ptr.origin[s1 / 64LU..e1 / 64LU], arr.ptr.origin[s2 / 64LU..e2 / 64LU]);
		}
		{
			ulong i = 0LU;
			for (; i < this.limit; i++)
			{
				if (this.opIndex(i) !is arr.opIndex(i))
					return false;
			}
		}
		return true;
	}

}
isIntegral!(BitPacked!(bool, 1LU))
{
	enum bool isIntegral = false;

}
spillToNextPage!(2LU, PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU))
{
	pure nothrow @trusted void spillToNextPage(ref PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU) ptr)
	{
		this.spillToNextPageImpl(ptr);
	}

}
spillToNextPageImpl!(2LU, PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU))
{
	pure nothrow @trusted void spillToNextPageImpl(ref PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU) ptr)
	{
		alias NextIdx = BitPacked!(uint, 13LU);
		BitPacked!(uint, 13LU) next_lvl_index = 0;
		enum int pageSize = 256;
		assert(this.idx() % 256LU == 0LU);
		immutable immutable(ulong) last = this.idx() - 256LU;
		const const(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU)) slice = ptr.opSlice(this.idx() - 256LU, this.idx());
		ulong j = 0LU;
		{
			j = 0LU;
			for (; j < last; j += 256LU)
			{
				{
					if (ptr.opSlice(j, j + 256LU).opEquals(slice))
					{
						next_lvl_index = force(j / 256LU);
						this.idx() -= 256LU;
						break;
					}
				}
			}
		}
		if (j == last)
		{
			L_allocate_page:
			next_lvl_index = force(this.idx() / 256LU - 1LU);
			if (this.state[2].idx_zeros == 18446744073709551615LU && ptr.zeros(j, j + 256LU))
			{
				this.state[2].idx_zeros = cast(ulong)next_lvl_index._value;
			}
			this.table.length(this.table.length() + 256LU);
		}
		L_know_index:
		this.addValue(next_lvl_index, 1LU);
		ptr = this.table.slice();
	}

}
slice!1LU
{
	auto inout pure nothrow @nogc @property @system inout(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU)) slice()
	{
		inout(ulong)* ptr = this.raw_ptr();
		return packedArrayView(ptr, this.sz[1]);
	}

}
packedArrayView!(BitPacked!(uint, 13LU))
{
	pure nothrow @nogc @safe inout(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU)) packedArrayView(inout(ulong)* ptr, ulong items)
	{
		return PackedArrayViewImpl(PackedPtrImpl(null), 0LU, 0LU).this(ptr, 0LU, items);
	}

}
PackedArrayView!(BitPacked!(uint, 13LU))
{
	alias PackedArrayView = PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU);

}
PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU)
{
	struct PackedArrayViewImpl
	{
		nothrow pure
		{
			inout pure nothrow @nogc @safe this(inout(ulong)* origin, ulong offset, ulong items)
			{
				this.ptr = 0 , this.ptr.this(origin);
				this.ofs = offset;
				this.limit = items;
				return this;
			}
			pure nothrow @nogc @system bool zeros(ulong s, ulong e)
			in
			{
				assert(s <= e);
			}
			do
			{
				{
					{
						assert(s <= e);
					}
				}
				s += this.ofs;
				e += this.ofs;
				immutable immutable(ulong) pad_s = this.roundUp(s);
				if (s >= e)
				{
					{
						ulong __key272 = s;
						ulong __limit273 = e;
						for (; __key272 < __limit273; __key272 += 1LU)
						{
							ulong i = __key272;
							if (this.ptr.opIndex(i)._value)
								return false;
						}
					}
					return true;
				}
				immutable immutable(ulong) pad_e = this.roundDown(e);
				ulong i = 0LU;
				{
					i = s;
					for (; i < pad_s; i++)
					{
						if (this.ptr.opIndex(i)._value)
							return false;
					}
				}
				{
					ulong j = i / 4LU;
					for (; i < pad_e; i += 4LU , j++)
					{
						if (this.ptr.origin[j])
							return false;
					}
				}
				for (; i < e; i++)
				{
					if (this.ptr.opIndex(i)._value)
						return false;
				}
				return true;
			}
			inout pure nothrow @nogc @system BitPacked!(uint, 13LU) opIndex(ulong idx)
			in
			{
				assert(idx < this.limit);
			}
			do
			{
				{
					{
						assert(idx < this.limit);
					}
				}
				return this.ptr.opIndex(this.ofs + idx);
			}
			static if (isBitPacked!(BitPacked!(uint, 13LU))
			{
				enum bool isBitPacked = true;

			}
			)
			{
				pure nothrow @nogc @system void opIndexAssign(BitPacked!(uint, 13LU) val, ulong idx)
				{
					this.opIndexAssign(val._value, idx);
					return ;
				}
			}
			pure nothrow @nogc @system void opIndexAssign(uint val, ulong idx)
			in
			{
				assert(idx < this.limit);
			}
			do
			{
				{
					{
						assert(idx < this.limit);
					}
				}
				this.ptr.opIndexAssign(val, this.ofs + idx);
			}
			static if (isBitPacked!(BitPacked!(uint, 13LU))
			{
			}
			)
			{
				pure nothrow @nogc @system void opSliceAssign(BitPacked!(uint, 13LU) val, ulong start, ulong end)
				{
					this.opSliceAssign(val._value, start, end);
				}
			}
			pure nothrow @nogc @system void opSliceAssign(uint val, ulong start, ulong end)
			in
			{
				assert(start <= end);
				assert(end <= this.limit);
			}
			do
			{
				{
					{
						assert(start <= end);
						assert(end <= this.limit);
					}
				}
				start += this.ofs;
				end += this.ofs;
				immutable immutable(ulong) pad_start = this.roundUp(start);
				if (pad_start >= end)
				{
					{
						ulong __key276 = start;
						ulong __limit277 = end;
						for (; __key276 < __limit277; __key276 += 1LU)
						{
							ulong i = __key276;
							this.ptr.opIndexAssign(val, i);
						}
					}
					return ;
				}
				immutable immutable(ulong) pad_end = this.roundDown(end);
				ulong i = 0LU;
				{
					i = start;
					for (; i < pad_start; i++)
					{
						this.ptr.opIndexAssign(val, i);
					}
				}
				if (pad_start != pad_end)
				{
					immutable immutable(ulong) repval = replicateBits(cast(ulong)val);
					{
						ulong j = i / 4LU;
						for (; i < pad_end; i += 4LU , j++)
						{
							this.ptr.origin[j] = repval;
						}
					}
				}
				for (; i < end; i++)
				{
					this.ptr.opIndexAssign(val, i);
				}
			}
			auto inout pure nothrow @nogc @safe inout(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU)) opSlice(ulong from, ulong to) return
			in
			{
				assert(from <= to);
				assert(this.ofs + to <= this.limit);
			}
			do
			{
				{
					{
						assert(from <= to);
						assert(this.ofs + to <= this.limit);
					}
				}
				return PackedArrayViewImpl(PackedPtrImpl(null), 0LU, 0LU).this(this.ptr.origin, this.ofs + from, to - from);
			}
			auto pure nothrow @nogc @safe PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU) opSlice() return
			{
				return this.opSlice(0LU, this.length());
			}
			const bool opEquals(T)(auto ref T arr)
			{
				if (limit != arr.limit)
					return false;
				size_t s1 = ofs, s2 = arr.ofs;
				size_t e1 = s1 + limit, e2 = s2 + limit;
				if (s1 % factor == 0 && (s2 % factor == 0) && (length % factor == 0))
				{
					return ptr.origin[s1 / factor..e1 / factor] == arr.ptr.origin[s2 / factor..e2 / factor];
				}
				for (size_t i = 0;
				 i < limit; i++)
				{
					if (this[i] != arr[i])
						return false;
				}
				return true;
			}
			const pure nothrow @nogc @property @safe ulong length()
			{
				return this.limit;
			}
			private
			{
				auto roundUp()(size_t val)
				{
					return (val + factor - 1) / factor * factor;
				}
				auto roundDown()(size_t val)
				{
					return val / factor * factor;
				}
				enum nothrow pure ulong factor = 4LU;
				nothrow pure PackedPtrImpl!(BitPacked!(uint, 13LU), 16LU) ptr;
				nothrow pure ulong ofs;
				nothrow pure ulong limit;
			}
		}
	}

}
isBitPacked!(BitPacked!(uint, 13LU))
{
	enum bool isBitPacked = true;

}
TypeOfBitPacked!(BitPacked!(uint, 13LU))
{
	alias TypeOfBitPacked = uint;

}
PackedPtr!(BitPacked!(uint, 13LU))
{
	alias PackedPtr = PackedPtrImpl!(BitPacked!(uint, 13LU), 16LU);

}
PackedPtrImpl!(BitPacked!(uint, 13LU), 16LU)
{
	struct PackedPtrImpl
	{
		nothrow pure
		{
			static assert(isPow2OrZero(16LU));
			inout pure nothrow @nogc @safe this(inout(ulong)* ptr)
			{
				this.origin = ptr;
				return this;
			}
			private inout pure nothrow @nogc @system BitPacked!(uint, 13LU) simpleIndex(ulong n)
			{
				immutable immutable(ulong) q = n / 4LU;
				immutable immutable(ulong) r = n % 4LU;
				return BitPacked(cast(uint)(this.origin[q] >> cast(int)(16LU * r) & 65535LU));
			}
			private pure nothrow @nogc @system void simpleWrite(uint val, ulong n)
			in
			{
			}
			do
			{
				{
					{
					}
				}
				immutable immutable(ulong) q = n / 4LU;
				immutable immutable(ulong) r = n % 4LU;
				immutable immutable(ulong) tgt_shift = 16LU * r;
				immutable immutable(ulong) word = this.origin[q];
				this.origin[q] = word & ~(65535LU << cast(int)tgt_shift) | cast(ulong)val << cast(int)tgt_shift;
			}
			static if (4LU == 8LU || 4LU == 1LU || (4LU == 4LU || factor == bytesPerWord / 4) && hasUnalignedReads)
			{
				static if (4LU == 8LU)
				{
					alias U = ubyte;
				}
				else
				{
					static if (4LU == 4LU)
					{
						alias U = ushort;
					}
					else
					{
						static if (factor == bytesPerWord / 4)
						{
							alias U = uint;
						}
						else
						{
							static if (size_t.sizeof == 8 && (factor == bytesPerWord / 8))
							{
								alias U = ulong;
							}
						}
					}
				}
				inout pure nothrow @nogc @system BitPacked!(uint, 13LU) opIndex(ulong idx)
				{
					BitPacked!(uint, 13LU) ret = 0;
					ret = __ctfe ? this.simpleIndex(idx) : BitPacked(cast(inout(uint))(cast(ushort*)this.origin)[idx]);
					return ret;
				}
				static if (isBitPacked!(BitPacked!(uint, 13LU))
				{
				}
				)
				{
					pure nothrow @nogc @system void opIndexAssign(BitPacked!(uint, 13LU) val, ulong idx)
					{
						this.opIndexAssign(val._value, idx);
						return ;
					}
				}
				pure nothrow @nogc @system void opIndexAssign(uint val, ulong idx)
				{
					if (__ctfe)
						this.simpleWrite(val, idx);
					else
						(cast(ushort*)this.origin)[idx] = cast(ushort)val;
				}
			}
			else
			{
				inout T opIndex(size_t n)
				{
					return simpleIndex(n);
				}
				static if (isBitPacked!T
				{
				}
				)
				{
					void opIndexAssign(T val, size_t idx)
					{
						return opIndexAssign(cast(TypeOfBitPacked!T
						{
						}
						)val, idx);
					}
				}
				void opIndexAssign(TypeOfBitPacked!T
				{
				}
				 val, size_t n)
				{
					return simpleWrite(val, n);
				}
			}
			private
			{
				enum nothrow pure ulong factor = 4LU;
				enum nothrow pure ulong mask = 65535LU;
				enum nothrow pure ulong bytesPerWord = 8LU;
				nothrow pure ulong* origin;
			}
		}
	}

}
opEquals!(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU))
{
	const pure nothrow @nogc @system bool opEquals(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU) arr)
	{
		if (this.limit != arr.limit)
			return false;
		ulong s1 = this.ofs;
		ulong s2 = arr.ofs;
		ulong e1 = s1 + this.limit;
		ulong e2 = s2 + this.limit;
		if (s1 % 4LU == 0LU && (s2 % 4LU == 0LU) && (this.length() % 4LU == 0LU))
		{
			return __equals(this.ptr.origin[s1 / 4LU..e1 / 4LU], arr.ptr.origin[s2 / 4LU..e2 / 4LU]);
		}
		{
			ulong i = 0LU;
			for (; i < this.limit; i++)
			{
				if (this.opIndex(i) !is arr.opIndex(i))
					return false;
			}
		}
		return true;
	}

}
opEquals!(const(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU)))
{
	const pure nothrow @nogc @system bool opEquals(ref const(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU)) arr)
	{
		if (this.limit != arr.limit)
			return false;
		ulong s1 = this.ofs;
		ulong s2 = arr.ofs;
		ulong e1 = s1 + this.limit;
		ulong e2 = s2 + this.limit;
		if (s1 % 64LU == 0LU && (s2 % 64LU == 0LU) && (this.length() % 64LU == 0LU))
		{
			return __equals(this.ptr.origin[s1 / 64LU..e1 / 64LU], arr.ptr.origin[s2 / 64LU..e2 / 64LU]);
		}
		{
			ulong i = 0LU;
			for (; i < this.limit; i++)
			{
				if (this.opIndex(i) !is arr.opIndex(i))
					return false;
			}
		}
		return true;
	}

}
__equals!(ulong, ulong)
{
	pure nothrow @nogc @trusted bool __equals(scope const(ulong[]) lhs, scope const(ulong[]) rhs)
	{
		const const(ulong) length = lhs.length;
		if (__ctfe)
			return length == rhs.length && isEqual(cast(const(ulong)*)lhs, cast(const(ulong)*)rhs, length);
		else
		{
			import core.stdc.string : memcmp;
			return length == rhs.length && (!length || 0 == memcmp(cast(const(void*))cast(const(ulong)*)lhs, cast(const(void*))cast(const(ulong)*)rhs, length * 8LU));
		}
	}

}
isEqual!(ulong, ulong)
{
	pure nothrow @nogc @system bool isEqual(scope const(ulong*) t1, scope const(ulong*) t2, ulong length)
	{
		{
			ulong __key267 = 0LU;
			ulong __limit268 = length;
			for (; __key267 < __limit268; __key267 += 1LU)
			{
				const const(ulong) i = __key267;
				if (t1[i] != t2[i])
					return false;
			}
		}
		return true;
	}

}
isIntegral!(BitPacked!(uint, 13LU))
{
	enum bool isIntegral = false;

}
force!(BitPacked!(uint, 13LU), ulong)
{
	auto pure nothrow @nogc @safe BitPacked!(uint, 13LU) force(ulong from)
	{
		assert(from <= 8191LU);
		return BitPacked(cast(uint)from);
	}

}
roundUp!()
{
	auto pure nothrow @nogc @safe ulong roundUp(ulong val)
	{
		return (val + 64LU - 1LU) / 64LU * 64LU;
	}

}
roundDown!()
{
	auto pure nothrow @nogc @safe ulong roundDown(ulong val)
	{
		return val / 64LU * 64LU;
	}

}
addValue!(1LU, BitPacked!(uint, 13LU))
{
	pure nothrow @trusted void addValue(BitPacked!(uint, 13LU) val, ulong numVals)
	{
		alias j = pure nothrow @nogc @property ref @trusted ulong idx() return
		{
			return this.indices[1];
		}
		;
		enum int pageSize = 32;
		if (numVals == 0LU)
			return ;
		PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU) ptr = this.table.slice();
		if (numVals == 1LU)
		{
			assert(this.idx() < ptr.length());
			ptr.opIndexAssign(force(val), this.idx());
			this.idx()++;
			if (this.idx() % 32LU == 0LU)
				this.spillToNextPage(ptr);
			return ;
		}
		immutable immutable(ulong) nextPB = this.idx() + 32LU & 18446744073709551584LU;
		immutable immutable(ulong) n = nextPB - this.idx();
		if (numVals < n)
		{
			ptr.opSliceAssign(val, this.idx(), this.idx() + numVals);
			this.idx() += numVals;
			return ;
		}
		numVals -= n;
		ptr.opSliceAssign(val, this.idx(), this.idx() + n);
		this.idx() += n;
		this.spillToNextPage(ptr);
		if (this.state[1].idx_zeros != 18446744073709551615LU && (val is BitPacked(0u)))
		{
			alias NextIdx = BitPacked!(uint, 8LU);
			this.addValue(force(this.state[1].idx_zeros), numVals / 32LU);
			ptr = this.table.slice();
			numVals %= 32LU;
		}
		else
		{
			for (; numVals >= 32LU;)
			{
				{
					numVals -= 32LU;
					ptr.opSliceAssign(val, this.idx(), this.idx() + 32LU);
					this.idx() += 32LU;
					this.spillToNextPage(ptr);
				}
			}
		}
		if (numVals)
		{
			ptr.opSliceAssign(val, this.idx(), this.idx() + numVals);
			this.idx() += numVals;
		}
	}

}
idx!1LU
{
	pure nothrow @nogc @property ref @trusted ulong idx() return
	{
		return this.indices[1];
	}

}
force!(BitPacked!(uint, 13LU), BitPacked!(uint, 13LU))
{
	auto pure nothrow @nogc @safe BitPacked!(uint, 13LU) force(BitPacked!(uint, 13LU) from)
	{
		return from;
	}

}
spillToNextPage!(1LU, PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU))
{
	pure nothrow @trusted void spillToNextPage(ref PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU) ptr)
	{
		this.spillToNextPageImpl(ptr);
	}

}
spillToNextPageImpl!(1LU, PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU))
{
	pure nothrow @trusted void spillToNextPageImpl(ref PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU) ptr)
	{
		alias NextIdx = BitPacked!(uint, 8LU);
		BitPacked!(uint, 8LU) next_lvl_index = 0;
		enum int pageSize = 32;
		assert(this.idx() % 32LU == 0LU);
		immutable immutable(ulong) last = this.idx() - 32LU;
		const const(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU)) slice = ptr.opSlice(this.idx() - 32LU, this.idx());
		ulong j = 0LU;
		{
			j = 0LU;
			for (; j < last; j += 32LU)
			{
				{
					if (ptr.opSlice(j, j + 32LU).opEquals(slice))
					{
						next_lvl_index = force(j / 32LU);
						this.idx() -= 32LU;
						break;
					}
				}
			}
		}
		if (j == last)
		{
			L_allocate_page:
			next_lvl_index = force(this.idx() / 32LU - 1LU);
			if (this.state[1].idx_zeros == 18446744073709551615LU && ptr.zeros(j, j + 32LU))
			{
				this.state[1].idx_zeros = cast(ulong)next_lvl_index._value;
			}
			this.table.length(this.table.length() + 32LU);
		}
		L_know_index:
		this.addValue(next_lvl_index, 1LU);
		ptr = this.table.slice();
	}

}
slice!0LU
{
	auto inout pure nothrow @nogc @property @system inout(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU)) slice()
	{
		inout(ulong)* ptr = this.raw_ptr();
		return packedArrayView(ptr, this.sz[0]);
	}

}
raw_ptr!0LU
{
	auto inout pure nothrow @nogc @property @system inout(ulong)* raw_ptr() return
	{
		return cast(inout(ulong)*)this.storage;
	}

}
packedArrayView!(BitPacked!(uint, 8LU))
{
	pure nothrow @nogc @safe inout(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU)) packedArrayView(inout(ulong)* ptr, ulong items)
	{
		return PackedArrayViewImpl(PackedPtrImpl(null), 0LU, 0LU).this(ptr, 0LU, items);
	}

}
PackedArrayView!(BitPacked!(uint, 8LU))
{
	alias PackedArrayView = PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU);

}
PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU)
{
	struct PackedArrayViewImpl
	{
		nothrow pure
		{
			inout pure nothrow @nogc @safe this(inout(ulong)* origin, ulong offset, ulong items)
			{
				this.ptr = 0 , this.ptr.this(origin);
				this.ofs = offset;
				this.limit = items;
				return this;
			}
			pure nothrow @nogc @system bool zeros(ulong s, ulong e)
			in
			{
				assert(s <= e);
			}
			do
			{
				{
					{
						assert(s <= e);
					}
				}
				s += this.ofs;
				e += this.ofs;
				immutable immutable(ulong) pad_s = this.roundUp(s);
				if (s >= e)
				{
					{
						ulong __key282 = s;
						ulong __limit283 = e;
						for (; __key282 < __limit283; __key282 += 1LU)
						{
							ulong i = __key282;
							if (this.ptr.opIndex(i)._value)
								return false;
						}
					}
					return true;
				}
				immutable immutable(ulong) pad_e = this.roundDown(e);
				ulong i = 0LU;
				{
					i = s;
					for (; i < pad_s; i++)
					{
						if (this.ptr.opIndex(i)._value)
							return false;
					}
				}
				{
					ulong j = i / 8LU;
					for (; i < pad_e; i += 8LU , j++)
					{
						if (this.ptr.origin[j])
							return false;
					}
				}
				for (; i < e; i++)
				{
					if (this.ptr.opIndex(i)._value)
						return false;
				}
				return true;
			}
			inout pure nothrow @nogc @system BitPacked!(uint, 8LU) opIndex(ulong idx)
			in
			{
				assert(idx < this.limit);
			}
			do
			{
				{
					{
						assert(idx < this.limit);
					}
				}
				return this.ptr.opIndex(this.ofs + idx);
			}
			static if (isBitPacked!(BitPacked!(uint, 8LU))
			{
				enum bool isBitPacked = true;

			}
			)
			{
				pure nothrow @nogc @system void opIndexAssign(BitPacked!(uint, 8LU) val, ulong idx)
				{
					this.opIndexAssign(val._value, idx);
					return ;
				}
			}
			pure nothrow @nogc @system void opIndexAssign(uint val, ulong idx)
			in
			{
				assert(idx < this.limit);
			}
			do
			{
				{
					{
						assert(idx < this.limit);
					}
				}
				this.ptr.opIndexAssign(val, this.ofs + idx);
			}
			static if (isBitPacked!(BitPacked!(uint, 8LU))
			{
			}
			)
			{
				pure nothrow @nogc @system void opSliceAssign(BitPacked!(uint, 8LU) val, ulong start, ulong end)
				{
					this.opSliceAssign(val._value, start, end);
				}
			}
			pure nothrow @nogc @system void opSliceAssign(uint val, ulong start, ulong end)
			in
			{
				assert(start <= end);
				assert(end <= this.limit);
			}
			do
			{
				{
					{
						assert(start <= end);
						assert(end <= this.limit);
					}
				}
				start += this.ofs;
				end += this.ofs;
				immutable immutable(ulong) pad_start = this.roundUp(start);
				if (pad_start >= end)
				{
					{
						ulong __key274 = start;
						ulong __limit275 = end;
						for (; __key274 < __limit275; __key274 += 1LU)
						{
							ulong i = __key274;
							this.ptr.opIndexAssign(val, i);
						}
					}
					return ;
				}
				immutable immutable(ulong) pad_end = this.roundDown(end);
				ulong i = 0LU;
				{
					i = start;
					for (; i < pad_start; i++)
					{
						this.ptr.opIndexAssign(val, i);
					}
				}
				if (pad_start != pad_end)
				{
					immutable immutable(ulong) repval = replicateBits(cast(ulong)val);
					{
						ulong j = i / 8LU;
						for (; i < pad_end; i += 8LU , j++)
						{
							this.ptr.origin[j] = repval;
						}
					}
				}
				for (; i < end; i++)
				{
					this.ptr.opIndexAssign(val, i);
				}
			}
			auto inout pure nothrow @nogc @safe inout(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU)) opSlice(ulong from, ulong to) return
			in
			{
				assert(from <= to);
				assert(this.ofs + to <= this.limit);
			}
			do
			{
				{
					{
						assert(from <= to);
						assert(this.ofs + to <= this.limit);
					}
				}
				return PackedArrayViewImpl(PackedPtrImpl(null), 0LU, 0LU).this(this.ptr.origin, this.ofs + from, to - from);
			}
			auto pure nothrow @nogc @safe PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU) opSlice() return
			{
				return this.opSlice(0LU, this.length());
			}
			const bool opEquals(T)(auto ref T arr)
			{
				if (limit != arr.limit)
					return false;
				size_t s1 = ofs, s2 = arr.ofs;
				size_t e1 = s1 + limit, e2 = s2 + limit;
				if (s1 % factor == 0 && (s2 % factor == 0) && (length % factor == 0))
				{
					return ptr.origin[s1 / factor..e1 / factor] == arr.ptr.origin[s2 / factor..e2 / factor];
				}
				for (size_t i = 0;
				 i < limit; i++)
				{
					if (this[i] != arr[i])
						return false;
				}
				return true;
			}
			const pure nothrow @nogc @property @safe ulong length()
			{
				return this.limit;
			}
			private
			{
				auto roundUp()(size_t val)
				{
					return (val + factor - 1) / factor * factor;
				}
				auto roundDown()(size_t val)
				{
					return val / factor * factor;
				}
				enum nothrow pure ulong factor = 8LU;
				nothrow pure PackedPtrImpl!(BitPacked!(uint, 8LU), 8LU) ptr;
				nothrow pure ulong ofs;
				nothrow pure ulong limit;
			}
		}
	}

}
isBitPacked!(BitPacked!(uint, 8LU))
{
	enum bool isBitPacked = true;

}
TypeOfBitPacked!(BitPacked!(uint, 8LU))
{
	alias TypeOfBitPacked = uint;

}
PackedPtr!(BitPacked!(uint, 8LU))
{
	alias PackedPtr = PackedPtrImpl!(BitPacked!(uint, 8LU), 8LU);

}
PackedPtrImpl!(BitPacked!(uint, 8LU), 8LU)
{
	struct PackedPtrImpl
	{
		nothrow pure
		{
			static assert(isPow2OrZero(8LU));
			inout pure nothrow @nogc @safe this(inout(ulong)* ptr)
			{
				this.origin = ptr;
				return this;
			}
			private inout pure nothrow @nogc @system BitPacked!(uint, 8LU) simpleIndex(ulong n)
			{
				immutable immutable(ulong) q = n / 8LU;
				immutable immutable(ulong) r = n % 8LU;
				return BitPacked(cast(uint)(this.origin[q] >> cast(int)(8LU * r) & 255LU));
			}
			private pure nothrow @nogc @system void simpleWrite(uint val, ulong n)
			in
			{
			}
			do
			{
				{
					{
					}
				}
				immutable immutable(ulong) q = n / 8LU;
				immutable immutable(ulong) r = n % 8LU;
				immutable immutable(ulong) tgt_shift = 8LU * r;
				immutable immutable(ulong) word = this.origin[q];
				this.origin[q] = word & ~(255LU << cast(int)tgt_shift) | cast(ulong)val << cast(int)tgt_shift;
			}
			static if (8LU == 8LU || factor == 1 || (factor == bytesPerWord / 2 || factor == bytesPerWord / 4) && hasUnalignedReads)
			{
				static if (8LU == 8LU)
				{
					alias U = ubyte;
				}
				else
				{
					static if (factor == bytesPerWord / 2)
					{
						alias U = ushort;
					}
					else
					{
						static if (factor == bytesPerWord / 4)
						{
							alias U = uint;
						}
						else
						{
							static if (size_t.sizeof == 8 && (factor == bytesPerWord / 8))
							{
								alias U = ulong;
							}
						}
					}
				}
				inout pure nothrow @nogc @system BitPacked!(uint, 8LU) opIndex(ulong idx)
				{
					BitPacked!(uint, 8LU) ret = 0;
					ret = __ctfe ? this.simpleIndex(idx) : BitPacked(cast(inout(uint))(cast(ubyte*)this.origin)[idx]);
					return ret;
				}
				static if (isBitPacked!(BitPacked!(uint, 8LU))
				{
				}
				)
				{
					pure nothrow @nogc @system void opIndexAssign(BitPacked!(uint, 8LU) val, ulong idx)
					{
						this.opIndexAssign(val._value, idx);
						return ;
					}
				}
				pure nothrow @nogc @system void opIndexAssign(uint val, ulong idx)
				{
					if (__ctfe)
						this.simpleWrite(val, idx);
					else
						(cast(ubyte*)this.origin)[idx] = cast(ubyte)val;
				}
			}
			else
			{
				inout T opIndex(size_t n)
				{
					return simpleIndex(n);
				}
				static if (isBitPacked!T
				{
				}
				)
				{
					void opIndexAssign(T val, size_t idx)
					{
						return opIndexAssign(cast(TypeOfBitPacked!T
						{
						}
						)val, idx);
					}
				}
				void opIndexAssign(TypeOfBitPacked!T
				{
				}
				 val, size_t n)
				{
					return simpleWrite(val, n);
				}
			}
			private
			{
				enum nothrow pure ulong factor = 8LU;
				enum nothrow pure ulong mask = 255LU;
				enum nothrow pure ulong bytesPerWord = 8LU;
				nothrow pure ulong* origin;
			}
		}
	}

}
opEquals!(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU))
{
	const pure nothrow @nogc @system bool opEquals(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU) arr)
	{
		if (this.limit != arr.limit)
			return false;
		ulong s1 = this.ofs;
		ulong s2 = arr.ofs;
		ulong e1 = s1 + this.limit;
		ulong e2 = s2 + this.limit;
		if (s1 % 8LU == 0LU && (s2 % 8LU == 0LU) && (this.length() % 8LU == 0LU))
		{
			return __equals(this.ptr.origin[s1 / 8LU..e1 / 8LU], arr.ptr.origin[s2 / 8LU..e2 / 8LU]);
		}
		{
			ulong i = 0LU;
			for (; i < this.limit; i++)
			{
				if (this.opIndex(i) !is arr.opIndex(i))
					return false;
			}
		}
		return true;
	}

}
opEquals!(const(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU)))
{
	const pure nothrow @nogc @system bool opEquals(ref const(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU)) arr)
	{
		if (this.limit != arr.limit)
			return false;
		ulong s1 = this.ofs;
		ulong s2 = arr.ofs;
		ulong e1 = s1 + this.limit;
		ulong e2 = s2 + this.limit;
		if (s1 % 4LU == 0LU && (s2 % 4LU == 0LU) && (this.length() % 4LU == 0LU))
		{
			return __equals(this.ptr.origin[s1 / 4LU..e1 / 4LU], arr.ptr.origin[s2 / 4LU..e2 / 4LU]);
		}
		{
			ulong i = 0LU;
			for (; i < this.limit; i++)
			{
				if (this.opIndex(i) !is arr.opIndex(i))
					return false;
			}
		}
		return true;
	}

}
isIntegral!(BitPacked!(uint, 8LU))
{
	enum bool isIntegral = false;

}
force!(BitPacked!(uint, 8LU), ulong)
{
	auto pure nothrow @nogc @safe BitPacked!(uint, 8LU) force(ulong from)
	{
		assert(from <= 255LU);
		return BitPacked(cast(uint)from);
	}

}
roundUp!()
{
	auto pure nothrow @nogc @safe ulong roundUp(ulong val)
	{
		return (val + 4LU - 1LU) / 4LU * 4LU;
	}

}
roundDown!()
{
	auto pure nothrow @nogc @safe ulong roundDown(ulong val)
	{
		return val / 4LU * 4LU;
	}

}
addValue!(0LU, BitPacked!(uint, 8LU))
{
	pure nothrow @nogc @trusted void addValue(BitPacked!(uint, 8LU) val, ulong numVals)
	{
		alias j = pure nothrow @nogc @property ref @trusted ulong idx() return
		{
			return this.indices[0];
		}
		;
		enum int pageSize = 256;
		if (numVals == 0LU)
			return ;
		PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU) ptr = this.table.slice();
		if (numVals == 1LU)
		{
			assert(this.idx() < ptr.length());
			ptr.opIndexAssign(force(val), this.idx());
			this.idx()++;
			if (this.idx() % 256LU == 0LU)
				this.spillToNextPage(ptr);
			return ;
		}
		immutable immutable(ulong) nextPB = this.idx() + 256LU & 18446744073709551360LU;
		immutable immutable(ulong) n = nextPB - this.idx();
		if (numVals < n)
		{
			ptr.opSliceAssign(val, this.idx(), this.idx() + numVals);
			this.idx() += numVals;
			return ;
		}
	}

}
idx!0LU
{
	pure nothrow @nogc @property ref @trusted ulong idx() return
	{
		return this.indices[0];
	}

}
force!(BitPacked!(uint, 8LU), BitPacked!(uint, 8LU))
{
	auto pure nothrow @nogc @safe BitPacked!(uint, 8LU) force(BitPacked!(uint, 8LU) from)
	{
		return from;
	}

}
spillToNextPage!(0LU, PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU))
{
	pure nothrow @nogc @trusted void spillToNextPage(ref PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU) ptr)
	{
	}

}
roundUp!()
{
	auto pure nothrow @nogc @safe ulong roundUp(ulong val)
	{
		return (val + 8LU - 1LU) / 8LU * 8LU;
	}

}
roundDown!()
{
	auto pure nothrow @nogc @safe ulong roundDown(ulong val)
	{
		return val / 8LU * 8LU;
	}

}
replicateBits!(8LU, 8LU)
{
	pure nothrow @nogc @safe ulong replicateBits(ulong val)
	{
		return replicateBits(val << 8 | val);
	}

}
replicateBits!(4LU, 16LU)
{
	pure nothrow @nogc @safe ulong replicateBits(ulong val)
	{
		return replicateBits(val << 16 | val);
	}

}
replicateBits!(2LU, 32LU)
{
	pure nothrow @nogc @safe ulong replicateBits(ulong val)
	{
		return replicateBits(val << 32 | val);
	}

}
replicateBits!(1LU, 64LU)
{
	pure nothrow @nogc @safe ulong replicateBits(ulong val)
	{
		return val;
	}

}
replicateBits!(64LU, 1LU)
{
	pure nothrow @nogc @safe ulong replicateBits(ulong val)
	{
		return val ? 18446744073709551615LU : 0LU;
	}

}
isValidPrefixForTrie!(dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool isValidPrefixForTrie = false;

}
allSatisfy!(callableWith, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	enum bool allSatisfy = false;

}
F!(1114112LU)
{
	enum bool callableWith = false;

}
Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))
{
	struct Trie
	{
		import std.range.primitives : isOutputRange;
		static if (is(ulong : ulong))
		{
			private enum @trusted ulong maxIndex = 1114112LU;
			private enum @trusted bool hasBoundsCheck = true;
			private alias Prefix = Args;
		}
		else
		{
			private enum hasBoundsCheck = false;
			private alias Prefix = Args;
		}
		private this()(typeof(_table) table)
		{
			_table = table;
		}
		private const this()(const(size_t)[] offsets, const(size_t)[] sizes, const(size_t)[] data)
		{
			_table = typeof(_table)(offsets, sizes, data);
		}
		const TypeOfBitPacked!Value
		{
		}
		 opIndex()(Key key)
		{
			static if (hasBoundsCheck)
			{
				assert(mapTrieIndex!Prefix
				{
				}
				(key) < maxIndex);
			}

			size_t idx;
			alias p = Prefix;
			idx = cast(size_t)p[0](key);
			foreach (i, v; p[0..__dollar - 1])
			{
				idx = cast(size_t)((_table.ptr!i
				{
				}
				[idx] << p[i + 1].bitSize) + p[i + 1](key));
			}
			return _table.ptr!(p.length - 1)
			{
			}
			[idx];
		}
		const @property size_t bytes(ulong n = size_t.max)()
		{
			return _table.bytes!n
			{
			}
			;
		}
		const @property size_t pages(ulong n)()
		{
			return (bytes!n
			{
			}
			 + 2 ^^ (Prefix[n].bitSize - 1)) / 2 ^^ Prefix[n].bitSize;
		}
		const void store(OutRange)(scope OutRange sink) if (isOutputRange!(OutRange, char)
		{
		}
		)
		{
			_table.store(sink);
		}
		private @trusted MultiArray!(BitPacked!(uint, 8LU), BitPacked!(uint, 13LU), BitPacked!(bool, 1LU)) _table;
	}

}
__ctor!()
{
	pure nothrow @nogc @trusted this(MultiArray!(BitPacked!(uint, 8LU), BitPacked!(uint, 13LU), BitPacked!(bool, 1LU)) table)
	{
		this._table = table;
		return this;
	}

}
__ctor!()
{
	const pure nothrow @nogc @trusted this(const(ulong)[] offsets, const(ulong)[] sizes, const(ulong)[] data)
	{
		this._table = 0 , this._table.this(offsets, sizes, data);
		return this;
	}

}
RTInfo!(sliceBits!(13LU, 21LU))
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(sliceBits!(8LU, 13LU))
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(sliceBits!(0LU, 8LU))
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(BitPacked!(bool, 1LU))
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(BitPacked!(uint, 8LU))
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(BitPacked!(uint, 13LU))
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(MultiArray!(BitPacked!(uint, 8LU), BitPacked!(uint, 13LU), BitPacked!(bool, 1LU)))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([64LU, 128LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [64LU, 128LU];

}
static __gshared TypeInfo_Const _D13TypeInfo_xG3m6__initZ;
static __gshared TypeInfo_Const _D12TypeInfo_xAm6__initZ;
RTInfo!(ConstructState)
{
	enum immutable(void)* RTInfo = null;

}
mapTrieIndex!dchar
{
	pure nothrow @nogc @safe ulong mapTrieIndex(dchar key)
	{
		alias p = (sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU));
		ulong idx = 0LU;
		/*unrolled*/ {
			{
				enum ulong i = 0LU;
				alias v = sliceBits!(13LU, 21LU);
				idx |= cast(ulong)opCall(key);
				idx <<= 5;
			}
			{
				enum ulong i = 1LU;
				alias v = sliceBits!(8LU, 13LU);
				idx |= cast(ulong)opCall(key);
				idx <<= 8;
			}
		}
		idx |= cast(ulong)opCall(key);
		return idx;
	}

}
enforce!bool
{
	pure @safe bool enforce(bool value, lazy const(char)[] msg = null, string file = __FILE__, ulong line = cast(ulong)__LINE__)
	{
		if (!value)
			bailOut(file, line, msg());
		return value;
	}

}
bailOut!(Exception)
{
	pure @safe noreturn bailOut(string file, ulong line, scope const(char)[] msg)
	{
		throw new Exception(msg ? idup(msg) : "Enforcement failed", file, line, null);
	}

}
isSomeFunction!string
{
	enum bool isSomeFunction = false;

}
RTInfo!(TrieBuilder!(bool, dchar, 1114112, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU)))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([152LU, 262144LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [152LU, 262144LU];

}
static __gshared TypeInfo_Const _D11TypeInfo_xb6__initZ;
static __gshared TypeInfo_Const _D11TypeInfo_xm6__initZ;
static __gshared TypeInfo_Const _D158TypeInfo_xG3S3std3uni__T11TrieBuilderTbTwVii1114112TSQBoQBn__T9sliceBitsVmi13Vmi21ZQvTSQCwQCv__TQBiVmi8Vmi13ZQBvTSQDxQDw__TQCjVmi0Vmi8ZQCvZQEl14ConstructState6__initZ;
static __gshared TypeInfo_Const _D115TypeInfo_xS3std3uni__T10MultiArrayTSQzQx__T9BitPackedTkVmi8ZQrTSQCbQCa__TQBeTkVmi13ZQBpTSQDaQCz__TQCdTbVmi1ZQCnZQDm6__initZ;
TraceHook!("ulong[]", "_d_arraysetlengthT")
{
	const const(char[]) TraceHook = "\n        import core.internal.array.utils : gcStatsPure, accumulatePure;\n\n        pragma(inline, false);\n        string name = `ulong[]`;\n\n        // FIXME: use rt.tracegc.accumulator when it is accessable in the future.\n        version (tracegc)\n    {\n\n            import core.stdc.stdio;\n\n            printf(\"%sTrace file = '%.*s' line = %d function = '%.*s' type = %.*s\\n\",\n            \"_d_arraysetlengthT\".ptr,\n                file.length, file.ptr,\n                line,\n                funcname.length, funcname.ptr,\n                name.length, name.ptr\n            );\n        }\n\n        ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;\n\n        scope(exit)\n        {\n            ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;\n            if (size > 0)\n                if (!accumulatePure(file, line, funcname, name, size)) {\n                    // This 'if' and 'assert' is needed to force the compiler to not remove the call to\n                    // `accumulatePure`. It really want to do that while optimizing as the function is\n                    // `pure` and it does not influence the result of this hook.\n\n                    // `accumulatePure` returns the value of `size`, which can never be zero due to the\n                    // previous 'if'. So this assert will never be triggered.\n                    assert(0);\n                }\n        }\n    ";

}
RTInfo!(PackedPtrImpl!(BitPacked!(bool, 1LU), 1LU))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([8LU, 1LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [8LU, 1LU];

}
RTInfo!(PackedArrayViewImpl!(BitPacked!(bool, 1LU), 1LU))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([24LU, 1LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [24LU, 1LU];

}
RTInfo!(PackedPtrImpl!(BitPacked!(uint, 13LU), 16LU))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfo!(PackedArrayViewImpl!(BitPacked!(uint, 13LU), 16LU))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfo!(PackedPtrImpl!(BitPacked!(uint, 8LU), 8LU))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfo!(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
opEquals!(const(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU)))
{
	const pure nothrow @nogc @system bool opEquals(ref const(PackedArrayViewImpl!(BitPacked!(uint, 8LU), 8LU)) arr)
	{
		if (this.limit != arr.limit)
			return false;
		ulong s1 = this.ofs;
		ulong s2 = arr.ofs;
		ulong e1 = s1 + this.limit;
		ulong e2 = s2 + this.limit;
		if (s1 % 8LU == 0LU && (s2 % 8LU == 0LU) && (this.length() % 8LU == 0LU))
		{
			return __equals(this.ptr.origin[s1 / 8LU..e1 / 8LU], arr.ptr.origin[s2 / 8LU..e2 / 8LU]);
		}
		{
			ulong i = 0LU;
			for (; i < this.limit; i++)
			{
				if (this.opIndex(i) !is arr.opIndex(i))
					return false;
			}
		}
		return true;
	}

}
RTInfo!(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU)))
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
opIndex!()
{
	const pure nothrow @nogc @trusted bool opIndex(dchar key)
	{
		assert(mapTrieIndex(key) < 1114112LU);
		ulong idx = 0LU;
		alias p = (sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU));
		idx = cast(ulong)opCall(key);
		/*unrolled*/ {
			{
				enum ulong i = 0LU;
				alias v = sliceBits!(13LU, 21LU);
				idx = cast(ulong)((((const const(PackedPtrImpl!(BitPacked!(uint, 8LU), 8LU)) __dop285 = this._table.ptr();) , __dop285.opIndex(idx))._value << 5) + opCall(key));
			}
			{
				enum ulong i = 1LU;
				alias v = sliceBits!(8LU, 13LU);
				idx = cast(ulong)((((const const(PackedPtrImpl!(BitPacked!(uint, 13LU), 16LU)) __dop286 = this._table.ptr();) , __dop286.opIndex(idx))._value << 8) + opCall(key));
			}
		}
		return ((const const(PackedPtrImpl!(BitPacked!(bool, 1LU), 1LU)) __dop287 = this._table.ptr();) , __dop287.opIndex(idx))._value;
	}

}
ptr!0LU
{
	auto inout pure nothrow @nogc @property @system inout(PackedPtrImpl!(BitPacked!(uint, 8LU), 8LU)) ptr()
	{
		inout(ulong)* ptr = this.raw_ptr();
		return PackedPtrImpl(null).this(ptr);
	}

}
ptr!1LU
{
	auto inout pure nothrow @nogc @property @system inout(PackedPtrImpl!(BitPacked!(uint, 13LU), 16LU)) ptr()
	{
		inout(ulong)* ptr = this.raw_ptr();
		return PackedPtrImpl(null).this(ptr);
	}

}
ptr!2LU
{
	auto inout pure nothrow @nogc @property @system inout(PackedPtrImpl!(BitPacked!(bool, 1LU), 1LU)) ptr()
	{
		inout(ulong)* ptr = this.raw_ptr();
		return PackedPtrImpl(null).this(ptr);
	}

}
__switch_error!()
{
	pure nothrow @nogc @safe void __switch_error(string file = __FILE__, ulong line = cast(ulong)__LINE__)
	{
		import core.exception : __switch_errorT;
		__switch_errorT(file, line);
	}

}
__switch_errorT!()
{
	pure nothrow @nogc @trusted void __switch_errorT(string file = __FILE__, ulong line = cast(ulong)__LINE__)
	{
		throw staticError("No appropriate switch clause found", file, line, null);
	}

}
staticError!(SwitchError, string, string, ulong, typeof(null))
{
	pure nothrow @nogc @system SwitchError staticError(string _param_0, ref string _param_1, ref ulong _param_2, typeof(null) _param_3)
	{
		static nothrow @nogc @system SwitchError get()
		{
			return & _store;
		}
		SwitchError res = (*& get)();
		import core.lifetime : emplace;
		emplace(res, _param_0, _param_1, _param_2, _param_3);
		return res;
	}

}
emplace!(SwitchError, string, string, ulong, typeof(null))
{
	pure nothrow @nogc @safe SwitchError emplace(SwitchError chunk, ref string _param_1, ref string _param_2, ref ulong _param_3, ref typeof(null) _param_4)
	{
		import core.internal.traits : isInnerClass;
		const const(void[]) initializer = SwitchError;
		delegate () pure nothrow @nogc @trusted
		{
			(cast(void*)chunk)[0..initializer.length] = initializer[];
		}
		();
		alias args1 = args;
		chunk.this(_param_1, _param_2, _param_3, cast(Throwable)_param_4);
		return chunk;
	}

}
isInnerClass!(SwitchError)
{
	enum bool isInnerClass = false;

}
forward!(_param_1, _param_2, _param_3, _param_4)
{
	Result
}
fwd!(_param_1)
{
	ref string _param_1;

}
fwd!(_param_2)
{
	ref string _param_2;

}
fwd!(_param_3)
{
	ref ulong _param_3;

}
fwd!(_param_4)
{
	ref typeof(null) _param_4;

}
getWidth!string
{
	pure @safe long getWidth(string s)
	{
		import std.algorithm.searching : all;
		import std.uni : graphemeStride;
		if (all(s))
			return cast(long)s.length;
		long width = 0L;
		{
			ulong i = 0LU;
			for (; i < s.length; i += graphemeStride(s, i))
			{
				width += 1L;
			}
		}
		return width;
	}

}
all!((a) => a <= 127)
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
all!string
{
	pure @safe bool all(string range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda2, "a")
{
	__lambda2(__T12)(a)
	{
		return a <= 127;
	}

}
needOpCallAlias!(__lambda2)
{
	enum bool needOpCallAlias = false;

}
__lambda2!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a <= 127u
}
not!(__lambda2)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, string)
{
	pure @safe string find(string haystack)
	{
		alias R = string;
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		import std.utf : decode;
		immutable immutable(ulong) len = haystack.length;
		ulong i = 0LU;
		ulong next = 0LU;
		for (; next < len;)
		{
			{
				if (not(decode(haystack, next)))
					return haystack[i..__dollar];
				i = next;
			}
		}
		return haystack[__dollar..__dollar];
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
isNarrowString!string
{
	enum bool isNarrowString = true;

}
decode!(Flag.no, string)
{
	pure @trusted dchar decode(ref scope string str, ref ulong index)
	in
	{
		assert(index < str.length, "Attempted to decode past the end of a string");
	}
	out(result)
	{
		assert(isValidDchar(result));
	}
	do
	{
		{
			{
				assert(index < str.length, "Attempted to decode past the end of a string");
			}
		}
		if (cast(int)str[index] < 128)
			__result = cast(dchar)str[index++];
			goto __returnLabel;
		else
		{
			__result = decodeImpl(cast(const(char)[])str, index);
			goto __returnLabel;
		}
		__returnLabel:
		{
			const ref const(dchar) result = __result;
			{
				assert(isValidDchar(result));
			}
		}
		return __result;
	}

}
codeUnitLimit!string
{
	enum char codeUnitLimit = '\x80';

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(dchar _param_0)
	{
		return !__lambda2(_param_0);
	}

}
empty!string
{
	pure nothrow @nogc @property @safe bool empty(scope string a)
	{
		return !a.length;
	}

}
put!(LockingTextWriter, char)
{
	@safe void put(ref LockingTextWriter r, char e)
	{
		doPut(r, e);
	}

}
doPut!(LockingTextWriter, char)
{
	@safe void doPut(ref LockingTextWriter r, ref char e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
ElementType!char
{
	alias ElementType = void;

}
put!char
{
	@safe void put(char c)
	{
		import std.utf : decodeFront, encode, stride;
		this.highSurrogateShouldBeEmpty();
		if (this.orientation_ <= 0)
			trustedFPUTC(cast(int)c, this.handle_());
		else if (cast(int)c <= 127)
			trustedFPUTWC(cast(dchar)c, this.handle_());
		else if (cast(int)c >= 192)
		{
			this.rbuf8[0] = c;
			this.rbuf8Filled = 1LU;
		}
		else
		{
			this.rbuf8[this.rbuf8Filled] = c;
			this.rbuf8Filled += 1LU;
			if (cast(ulong)stride(this.rbuf8[]) == this.rbuf8Filled)
			{
				char[] str = this.rbuf8[0..this.rbuf8Filled];
				immutable immutable(dchar) d = decodeFront(str);
				dchar[1] wbuf = '\uffff';
				immutable immutable(ulong) size = encode(wbuf, d);
				{
					ulong __key299 = 0LU;
					ulong __limit300 = size;
					for (; __key299 < __limit300; __key299 += 1LU)
					{
						ulong i = __key299;
						trustedFPUTWC(wbuf[i], this.handle_());
					}
				}
				this.rbuf8Filled = 0LU;
			}
		}
	}

}
put!(LockingTextWriter, char[])
{
	@safe void put(ref LockingTextWriter r, char[] e)
	{
		doPut(r, e);
	}

}
doPut!(LockingTextWriter, char[])
{
	@safe void doPut(ref LockingTextWriter r, ref char[] e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
isInfinite!(char[])
{
	enum bool isInfinite = false;

}
put!(char[])
{
	@safe void put(scope char[] writeme)
	{
		import std.exception : errnoEnforce;
		alias C = char;
		if (this.orientation_ <= 0)
		{
			ulong result = trustedFwrite((*this.file_._p).handle, writeme);
			if (result != writeme.length)
				enforce(0, delegate const(char)[]() pure nothrow @nogc @safe => null, "/usr/include/dmd/phobos/std/stdio.d", 3174LU);
			return ;
		}
		{
			scope char[] __r303 = writeme[];
			ulong __key304 = 0LU;
			for (; __key304 < __r303.length; __key304 += 1LU)
			{
				char c = __r303[__key304];
				this.put(c);
			}
		}
	}

}
put!(LockingTextWriter, const(dchar))
{
	@safe void put(ref LockingTextWriter r, const(dchar) e)
	{
		doPut(r, e);
	}

}
doPut!(LockingTextWriter, const(dchar))
{
	@safe void doPut(ref LockingTextWriter r, ref const(dchar) e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
ElementType!(const(dchar))
{
	alias ElementType = void;

}
isSomeChar!(const(dchar))
{
	enum bool isSomeChar = true;

}
put!(const(dchar))
{
	@safe void put(const(dchar) c)
	{
		import std.utf : decodeFront, encode, stride;
		import std.utf : encode;
		this.highSurrogateShouldBeEmpty();
		if (this.orientation_ <= 0)
		{
			if (cast(uint)c <= 127u)
			{
				trustedFPUTC(cast(int)c, this.handle_());
			}
			else
			{
				char[4] buf = void;
				immutable immutable(ulong) len = encode(buf, c);
				{
					ulong __key307 = 0LU;
					ulong __limit308 = len;
					for (; __key307 < __limit308; __key307 += 1LU)
					{
						ulong i = __key307;
						trustedFPUTC(cast(int)buf[i], this.handle_());
					}
				}
			}
		}
		else
		{
			trustedFPUTWC(c, this.handle_());
		}
	}

}
all!((a) => a == '0')
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
all!(char[])
{
	pure @safe bool all(char[] range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda16, "a")
{
	__lambda16(__T9)(a)
	{
		return a == '0';
	}

}
needOpCallAlias!(__lambda16)
{
	enum bool needOpCallAlias = false;

}
__lambda16!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a == 48u
}
not!(__lambda16)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, char[])
{
	pure @safe char[] find(char[] haystack)
	{
		alias R = char[];
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		import std.utf : decode;
		immutable immutable(ulong) len = haystack.length;
		ulong i = 0LU;
		ulong next = 0LU;
		for (; next < len;)
		{
			{
				if (not(decode(haystack, next)))
					return haystack[i..__dollar];
				i = next;
			}
		}
		return haystack[__dollar..__dollar];
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(dchar _param_0)
	{
		return !__lambda16(_param_0);
	}

}
all!((a) => a == '0')
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
all!(char[])
{
	pure @safe bool all(char[] range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda17, "a")
{
	__lambda17(__T10)(a)
	{
		return a == '0';
	}

}
needOpCallAlias!(__lambda17)
{
	enum bool needOpCallAlias = false;

}
__lambda17!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a == 48u
}
not!(__lambda17)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, char[])
{
	pure @safe char[] find(char[] haystack)
	{
		alias R = char[];
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		import std.utf : decode;
		immutable immutable(ulong) len = haystack.length;
		ulong i = 0LU;
		ulong next = 0LU;
		for (; next < len;)
		{
			{
				if (not(decode(haystack, next)))
					return haystack[i..__dollar];
				i = next;
			}
		}
		return haystack[__dollar..__dollar];
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(dchar _param_0)
	{
		return !__lambda17(_param_0);
	}

}
round!(char[64])
{
	pure nothrow @nogc @safe bool round(ref char[64] sequence, ulong left, ulong right, RoundingClass type, bool negative, char max = '9')
	in (left >= 0LU)
	in (left < 64LU)
	in (right >= 0LU)
	in (right <= 64LU)
	in (right >= left)
	in (cast(int)max == 57 || cast(int)max == 102 || cast(int)max == 70)
	{
		{
			assert(left >= 0LU);
		}
		{
			assert(left < 64LU);
		}
		{
			assert(right >= 0LU);
		}
		{
			assert(right <= 64LU);
		}
		{
			assert(right >= left);
		}
		{
			assert(cast(int)max == 57 || cast(int)max == 102 || cast(int)max == 70);
		}
		import std.math.hardware;
		RoundingMode mode = RoundingMode.toNearestTiesToEven;
		if (!__ctfe)
		{
			switch (rounding())
			{
				case 2048u:
				{
					mode = RoundingMode.up;
					break;
				}
				case 1024u:
				{
					mode = RoundingMode.down;
					break;
				}
				case 3072u:
				{
					mode = RoundingMode.toZero;
					break;
				}
				case 0u:
				{
					mode = RoundingMode.toNearestTiesToEven;
					break;
				}
				default:
				{
					assert(false, "Unknown floating point rounding mode");
				}
			}
		}
		bool roundUp = false;
		if (mode == RoundingMode.up)
			roundUp = type != RoundingClass.ZERO && !negative;
		else if (mode == RoundingMode.down)
			roundUp = type != RoundingClass.ZERO && negative;
		else if (mode == RoundingMode.toZero)
			roundUp = false;
		else
		{
			roundUp = type == RoundingClass.UPPER;
			if (type == RoundingClass.FIVE)
			{
				if (mode == RoundingMode.toNearestTiesAwayFromZero)
					roundUp = true;
				else
				{
					char last = sequence[right - 1LU];
					if (cast(int)last == 46)
						last = sequence[right - 2LU];
					roundUp = cast(int)last <= 57 && (cast(int)last % 2 != 0) || cast(int)last > 57 && (cast(int)last % 2 == 0);
				}
			}
		}
		if (!roundUp)
			return false;
		{
			ulong __limit323 = left;
			ulong __key322 = right;
			for (; __key322-- > __limit323;)
			{
				ulong i = __key322;
				if (cast(int)sequence[i] == 46)
					continue;
				if (cast(int)sequence[i] == cast(int)max)
					sequence[i] = '0';
				else
				{
					if (cast(int)max != 57 && (cast(int)sequence[i] == 57))
						sequence[i] = cast(int)max == 102 ? 'a' : 'A';
					else
						sequence[i]++;
					return false;
				}
			}
		}
		sequence[left - 1LU] = '1';
		return true;
	}

}
min!(ulong, ulong)
{
	pure nothrow @nogc @safe ulong min(ulong a, ulong b)
	{
		return b < a ? b : a;
	}

}
writeAligned!(LockingTextWriter, char[], char[], char[], char[], char)
{
	@safe void writeAligned(ref LockingTextWriter w, char[] prefix, char[] grouped, char[] fracts, char[] suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key324 = 0LU;
					ulong __limit325 = fracts.length;
					for (; __key324 < __limit325; __key324 += 1LU)
					{
						ulong i = __key324;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key326 = 0L;
					long __limit327 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key326 < __limit327; __key326 += 1L)
					{
						long i = __key326;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key328 = 0L;
					long __limit329 = delta;
					for (; __key328 < __limit329; __key328 += 1L)
					{
						long i = __key328;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key330 = 0L;
					long __limit331 = delta;
					for (; __key330 < __limit331; __key330 += 1L)
					{
						long i = __key330;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key332 = 0L;
				long __limit333 = delta;
				for (; __key332 < __limit333; __key332 += 1L)
				{
					long i = __key332;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key334 = 0LU;
				ulong __limit335 = cast(ulong)pregrouped + grouped.length;
				for (; __key334 < __limit335; __key334 += 1LU)
				{
					ulong i = __key334;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key336 = 0L;
				long __limit337 = pregrouped;
				for (; __key336 < __limit337; __key336 += 1L)
				{
					long i = __key336;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key338 = 0L;
			long __limit339 = trailingZeros;
			for (; __key338 < __limit339; __key338 += 1L)
			{
				long i = __key338;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key340 = 0L;
					long __limit341 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key340 < __limit341; __key340 += 1L)
					{
						long i = __key340;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key342 = 0L;
					long __limit343 = delta;
					for (; __key342 < __limit343; __key342 += 1L)
					{
						long i = __key342;
						put(w, ' ');
					}
				}
			}
		}
	}

}
isInfinite!(int[])
{
	enum bool isInfinite = false;

}
text!(string, const(char))
{
	pure nothrow @safe string text(string _param_0, const(char) _param_1)
	{
		return textImpl(_param_0, _param_1);
	}

}
textImpl!(string, string, const(char))
{
	pure nothrow @safe string textImpl(string _param_0, const(char) _param_1)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(40LU);
		app.put(_param_0);
		app.put(_param_1);
		return app.data();
	}

}
canPutItem!(const(char))
{
	enum bool canPutItem = true;

}
Unqual!(const(char), char)
{
	alias Unqual = char;

}
canPutConstRange!(const(char))
{
	enum bool canPutConstRange = false;

}
isInputRange!(const(char))
{
	enum bool isInputRange = false;

}
canPutRange!(const(char))
{
	enum bool canPutRange = false;

}
put!(const(char))
{
	pure nothrow @safe void put(const(char) item)
	{
		import core.lifetime : emplace;
		this.ensureAddable(1LU);
		immutable immutable(ulong) len = (*this._data).arr.length;
		char[] bigData = delegate () pure nothrow @nogc @trusted => (cast(char*)(*this._data).arr)[0..len + 1LU]();
		char* itemUnqual = delegate () pure nothrow @nogc @trusted => & item();
		emplace(&bigData[len], *itemUnqual);
		(*this._data).arr = bigData;
	}

}
text!(string, ubyte, char, char, string, ulong)
{
	pure nothrow @safe string text(string _param_0, ubyte _param_1, char _param_2, char _param_3, string _param_4, ulong _param_5)
	{
		return textImpl(_param_0, _param_1, _param_2, _param_3, _param_4, _param_5);
	}

}
textImpl!(string, string, ubyte, char, char, string, ulong)
{
	pure nothrow @safe string textImpl(string _param_0, ubyte _param_1, char _param_2, char _param_3, string _param_4, ulong _param_5)
	{
		import std.array : appender;
		import std.traits : isSomeChar, isSomeString;
		Appender!string app = appender();
		app.reserve(120LU);
		app.put(_param_0);
		app.put(to(_param_1));
		app.put(_param_2);
		app.put(_param_3);
		app.put(_param_4);
		app.put(textImpl(_param_5));
		return app.data();
	}

}
isInputRange!ubyte
{
	enum bool isInputRange = false;

}
isAggregateType!ubyte
{
	enum bool isAggregateType = false;

}
to!ubyte
{
	pure nothrow @safe string to(ubyte _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(ubyte, string)
{
	enum bool isImplicitlyConvertible = false;

}
isInfinite!ubyte
{
	enum bool isInfinite = false;

}
isCopyable!ubyte
{
	enum bool isCopyable = true;

}
toImpl!(string, ubyte)
{
	pure nothrow @safe string toImpl(ubyte value)
	{
		return toImpl(value, 10u, LetterCase.upper);
	}

}
isSomeFiniteCharInputRange!ubyte
{
	enum bool isSomeFiniteCharInputRange = false;

}
toImpl!(string, ubyte)
{
	pure nothrow @trusted string toImpl(ubyte value, uint radix, LetterCase letterCase = LetterCase.upper)
	in
	{
		assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
	}
	do
	{
		{
			{
				assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
			}
		}
		alias EEType = char;
		T toStringRadixConvert(ulong bufLen)(uint runtimeRadix = 0)
		{
			Unsigned!(Unqual!S
			{
			}
			)
			{
			}
			 div = void, mValue = unsigned(value);
			size_t index = bufLen;
			EEType[bufLen] buffer = void;
			char baseChar = letterCase == LetterCase.lower ? 'a' : 'A';
			char mod = void;
			do
			{
				div = cast(S)(mValue / runtimeRadix);
				mod = cast(ubyte)(mValue % runtimeRadix);
				mod += mod < 10 ? '0' : baseChar - 10;
				buffer[--index] = cast(char)mod;
				mValue = div;
			}
			while (mValue);
			return cast(T)buffer[index..__dollar].dup;
		}
		import std.array : array;
		switch (radix)
		{
			case 10u:
			{
				return array(toChars(cast(int)value + 0));
			}
			case 16u:
			{
				if (cast(int)letterCase == 0)
					return array(toChars(unsigned(cast(int)unsigned(value) + 0)));
				else
					return array(toChars(unsigned(cast(int)unsigned(value) + 0)));
			}
			case 2u:
			{
				return array(toChars(unsigned(cast(int)unsigned(value) + 0)));
			}
			case 8u:
			{
				return array(toChars(unsigned(cast(int)unsigned(value) + 0)));
			}
			default:
			{
				return toStringRadixConvert(radix);
			}
		}
	}

}
unsigned!ubyte
{
	auto pure nothrow @nogc @safe ubyte unsigned(ubyte x)
	{
		return x;
	}

}
Unsigned!ubyte
{
	alias Unsigned = ubyte;

}
OriginalType!ubyte
{
	alias OriginalType = ubyte;

}
_OriginalType!ubyte
{
	alias OriginalType = ubyte;

}
ModifyTypePreservingTQ!(Impl, ubyte)
{
	alias ModifyTypePreservingTQ = ubyte;

}
Modifier!ubyte
{
	alias Impl = ubyte;

}
ModifyTypePreservingTQ!(Impl, ubyte)
{
	alias ModifyTypePreservingTQ = ubyte;

}
_ModifyTypePreservingTQ!(Impl, ubyte)
{
	alias ModifyTypePreservingTQ = ubyte;

}
Modifier!ubyte
{
	alias Impl = ubyte;

}
isUnsigned!ubyte
{
	enum bool isUnsigned = true;

}
Unqual!(ubyte, ubyte)
{
	alias Unqual = ubyte;

}
toStringRadixConvert!6LU
{
	pure nothrow @system string toStringRadixConvert(uint runtimeRadix = 0u)
	{
		ubyte div = void;
		ubyte mValue = unsigned(value);
		ulong index = 6LU;
		char[6] buffer = void;
		char baseChar = cast(int)letterCase == 1 ? 'a' : 'A';
		char mod = void;
		do
		{
			div = cast(ubyte)(cast(uint)cast(int)mValue / runtimeRadix);
			mod = cast(char)cast(ubyte)(cast(uint)cast(int)mValue % runtimeRadix);
			cast(int)mod += cast(int)mod < 10 ? 48 : cast(int)baseChar - 10;
			buffer[index -= 1LU] = mod;
			mValue = div;
		}
		while (mValue);
		return cast(string)dup(buffer[index..6]);
	}

}
isSomeChar!ulong
{
	enum bool isSomeChar = false;

}
isSomeString!ulong
{
	enum bool isSomeString = false;

}
isInputRange!ulong
{
	enum bool isInputRange = false;

}
textImpl!(string, ulong)
{
	pure nothrow @safe string textImpl(ulong _param_0)
	{
		return to(_param_0);
	}

}
isStaticArray!ulong
{
	enum bool isStaticArray = false;

}
isAggregateType!ulong
{
	enum bool isAggregateType = false;

}
to!ulong
{
	pure nothrow @safe string to(ulong _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(ulong, string)
{
	enum bool isImplicitlyConvertible = false;

}
isInfinite!ulong
{
	enum bool isInfinite = false;

}
isCopyable!ulong
{
	enum bool isCopyable = true;

}
isDynamicArray!ulong
{
	enum bool isDynamicArray = false;

}
isAssociativeArray!ulong
{
	enum bool isAssociativeArray = false;

}
toImpl!(string, ulong)
{
	pure nothrow @safe string toImpl(ulong value)
	{
		return toImpl(value, 10u, LetterCase.upper);
	}

}
isExactSomeString!ulong
{
	enum bool isExactSomeString = false;

}
isSomeFiniteCharInputRange!ulong
{
	enum bool isSomeFiniteCharInputRange = false;

}
toImpl!(string, ulong)
{
	pure nothrow @trusted string toImpl(ulong value, uint radix, LetterCase letterCase = LetterCase.upper)
	in
	{
		assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
	}
	do
	{
		{
			{
				assert(radix >= 2u && (radix <= 36u), "radix must be in range [2,36]");
			}
		}
		alias EEType = char;
		T toStringRadixConvert(ulong bufLen)(uint runtimeRadix = 0)
		{
			Unsigned!(Unqual!S
			{
			}
			)
			{
			}
			 div = void, mValue = unsigned(value);
			size_t index = bufLen;
			EEType[bufLen] buffer = void;
			char baseChar = letterCase == LetterCase.lower ? 'a' : 'A';
			char mod = void;
			do
			{
				div = cast(S)(mValue / runtimeRadix);
				mod = cast(ubyte)(mValue % runtimeRadix);
				mod += mod < 10 ? '0' : baseChar - 10;
				buffer[--index] = cast(char)mod;
				mValue = div;
			}
			while (mValue);
			return cast(T)buffer[index..__dollar].dup;
		}
		import std.array : array;
		switch (radix)
		{
			case 10u:
			{
				return array(toChars(value + 0LU));
			}
			case 16u:
			{
				if (cast(int)letterCase == 0)
					return array(toChars(unsigned(unsigned(value) + 0LU)));
				else
					return array(toChars(unsigned(unsigned(value) + 0LU)));
			}
			case 2u:
			{
				return array(toChars(unsigned(unsigned(value) + 0LU)));
			}
			case 8u:
			{
				return array(toChars(unsigned(unsigned(value) + 0LU)));
			}
			default:
			{
				return toStringRadixConvert(radix);
			}
		}
	}

}
toChars!(10, char, LetterCase.lower, ulong)
{
	auto pure nothrow @nogc @safe Result toChars(ulong value)
	{
		alias UT = ulong;
		static struct Result
		{
			pure nothrow @nogc @safe void initialize(ulong value)
			{
				bool neg = false;
				if (value < 10LU)
				{
					if (value >= 0LU)
					{
						this.lwr = 0u;
						this.upr = 1u;
						this.buf[0] = cast(char)(cast(uint)value + 48u);
						return ;
					}
					value = -value;
					neg = true;
				}
				uint i = 19u;
				for (; value >= 10LU;)
				{
					{
						this.buf[cast(ulong)i] = cast(char)cast(ubyte)(48LU + value % 10LU);
						value = unsigned(value) / 10LU;
						i -= 1u;
					}
				}
				this.buf[cast(ulong)i] = cast(char)(cast(uint)value + 48u);
				if (neg)
				{
					this.buf[cast(ulong)(i - 1u)] = '-';
					i -= 1u;
				}
				this.lwr = i;
				this.upr = 20u;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)(this.upr - this.lwr);
			}
			alias opDollar = pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)(this.upr - this.lwr);
			}
			;
			pure nothrow @nogc @property @safe bool empty()
			{
				return this.upr == this.lwr;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.buf[cast(ulong)this.lwr];
			}
			pure nothrow @nogc @safe void popFront()
			{
				this.lwr += 1u;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.buf[cast(ulong)(this.upr - 1u)];
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.upr -= 1u;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				return this.buf[cast(ulong)this.lwr + i];
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.buf = this.buf;
				result.lwr = cast(uint)(cast(ulong)this.lwr + lwr);
				result.upr = cast(uint)(cast(ulong)this.lwr + upr);
				return result;
			}
			private
			{
				uint lwr = void;
				uint upr = void;
				char[20] buf = void;
			}
		}
		Result result = 0;
		result.initialize(value);
		return result;
	}

}
Unqual!(ulong, ulong)
{
	alias Unqual = ulong;

}
isSigned!ulong
{
	enum bool isSigned = false;

}
Unsigned!ulong
{
	alias Unsigned = ulong;

}
OriginalType!ulong
{
	alias OriginalType = ulong;

}
_OriginalType!ulong
{
	alias OriginalType = ulong;

}
ModifyTypePreservingTQ!(Impl, ulong)
{
	alias ModifyTypePreservingTQ = ulong;

}
Modifier!ulong
{
	alias Impl = ulong;

}
ModifyTypePreservingTQ!(Impl, ulong)
{
	alias ModifyTypePreservingTQ = ulong;

}
_ModifyTypePreservingTQ!(Impl, ulong)
{
	alias ModifyTypePreservingTQ = ulong;

}
Modifier!ulong
{
	alias Impl = ulong;

}
isUnsigned!ulong
{
	enum bool isUnsigned = true;

}
unsigned!ulong
{
	auto pure nothrow @nogc @safe ulong unsigned(ulong x)
	{
		return x;
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r362 = r;
				for (; !__r362.empty(); __r362.popFront())
				{
					char e = __r362.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r363 = r;
				for (; !__r363.empty(); __r363.popFront())
				{
					char e = __r363.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toChars!(16, char, LetterCase.upper, ulong)
{
	auto pure nothrow @nogc @safe Result toChars(ulong value)
	{
		alias UT = ulong;
		enum int SHIFT = 4;
		static struct Result
		{
			pure nothrow @nogc @safe this(ulong value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 4;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 4;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 4LU) & 15LU);
				return cast(int)c < 10 ? cast(char)(cast(int)c + 48) : cast(char)(cast(int)c + 65 - 10);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 4LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				ulong value;
				ubyte len;
			}
		}
		return Result(0LU, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r369 = r;
				for (; !__r369.empty(); __r369.popFront())
				{
					char e = __r369.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r370 = r;
				for (; !__r370.empty(); __r370.popFront())
				{
					char e = __r370.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toChars!(16, char, LetterCase.lower, ulong)
{
	auto pure nothrow @nogc @safe Result toChars(ulong value)
	{
		alias UT = ulong;
		enum int SHIFT = 4;
		static struct Result
		{
			pure nothrow @nogc @safe this(ulong value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 4;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 4;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 4LU) & 15LU);
				return cast(int)c < 10 ? cast(char)(cast(int)c + 48) : cast(char)(cast(int)c + 97 - 10);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 4LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				ulong value;
				ubyte len;
			}
		}
		return Result(0LU, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r376 = r;
				for (; !__r376.empty(); __r376.popFront())
				{
					char e = __r376.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r377 = r;
				for (; !__r377.empty(); __r377.popFront())
				{
					char e = __r377.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toChars!(2, char, LetterCase.lower, ulong)
{
	auto pure nothrow @nogc @safe Result toChars(ulong value)
	{
		alias UT = ulong;
		enum int SHIFT = 1;
		static struct Result
		{
			pure nothrow @nogc @safe this(ulong value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 1;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 1;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 1LU) & 1LU);
				return cast(char)(cast(int)c + 48);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 1LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				ulong value;
				ubyte len;
			}
		}
		return Result(0LU, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r383 = r;
				for (; !__r383.empty(); __r383.popFront())
				{
					char e = __r383.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r384 = r;
				for (; !__r384.empty(); __r384.popFront())
				{
					char e = __r384.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toChars!(8, char, LetterCase.lower, ulong)
{
	auto pure nothrow @nogc @safe Result toChars(ulong value)
	{
		alias UT = ulong;
		enum int SHIFT = 3;
		static struct Result
		{
			pure nothrow @nogc @safe this(ulong value)
			{
				this.value = value;
				ubyte len = cast(ubyte)1u;
				for (; value >>>= 3;)
				{
					cast(int)len += 1;
				}
				this.len = len;
				return this;
			}
			pure nothrow @nogc @property @safe ulong length()
			{
				return cast(ulong)this.len;
			}
			pure nothrow @nogc @property @safe bool empty()
			{
				return cast(int)this.len == 0;
			}
			pure nothrow @nogc @property @safe char front()
			{
				return this.opIndex(0LU);
			}
			pure nothrow @nogc @safe void popFront()
			{
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe char back()
			{
				return this.opIndex(cast(ulong)(cast(int)this.len - 1));
			}
			pure nothrow @nogc @safe void popBack()
			{
				this.value >>>= 3;
				cast(int)this.len -= 1;
			}
			pure nothrow @nogc @property @safe Result save()
			{
				return this;
			}
			pure nothrow @nogc @safe char opIndex(ulong i)
			{
				char c = cast(char)(this.value >>> cast(int)((cast(ulong)cast(int)this.len - i - 1LU) * 3LU) & 7LU);
				return cast(char)(cast(int)c + 48);
			}
			pure nothrow @nogc @safe Result opSlice(ulong lwr, ulong upr)
			{
				Result result = void;
				result.value = this.value >>> cast(int)((cast(ulong)cast(int)this.len - upr) * 3LU);
				result.len = cast(ubyte)(upr - lwr);
				return result;
			}
			private
			{
				ulong value;
				ubyte len;
			}
		}
		return Result(0LU, cast(ubyte)0u).this(value);
	}

}
RTInfo!(Result)
{
	enum immutable(void)* RTInfo = null;

}
isIterable!(Result)
{
	enum bool isIterable = true;

}
isAutodecodableString!(Result)
{
	enum bool isAutodecodableString = false;

}
isInfinite!(Result)
{
	enum bool isInfinite = false;

}
isInputRange!(Result)
{
	enum bool isInputRange = true;

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.empty())
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(Result r);

}
isCallable!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isCallable = true;

}
isSomeFunction!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias ReturnType = char;

}
FunctionTypeOf!(function (Result r) pure nothrow @nogc @safe => r.front())
{
	alias pure nothrow @nogc @safe char FunctionTypeOf(Result r);

}
isPointer!(Result)
{
	enum bool isPointer = false;

}
array!(Result)
{
	pure nothrow @safe char[] array(Result r)
	{
		if (__ctfe)
		{
			char[] result = null;
			{
				Result __r390 = r;
				for (; !__r390.empty(); __r390.popFront())
				{
					char e = __r390.front();
					_d_arrayappendcTX(result, 1LU) , result[result.length - 1LU] = e , result;
				}
			}
			return result;
		}
		alias E = char;
		const const(ulong) length = r.length();
		if (length == 0LU)
			return null;
		import core.internal.lifetime : emplaceRef;
		char[] result = delegate () pure nothrow @trusted => uninitializedArray(length)();
		ulong cnt = 0LU;
		{
			{
				Result __r391 = r;
				for (; !__r391.empty(); __r391.popFront())
				{
					char e = __r391.front();
					emplaceRef(result[cnt], e);
					cnt += 1LU;
				}
			}
		}
		assert(length == cnt, "Range .length property was not equal to the length yielded by the range before becoming empty");
		return delegate () pure nothrow @nogc @trusted => result();
	}

}
ForeachType!(Result)
{
	alias ForeachType = char;

}
hasLength!(Result)
{
	enum bool hasLength = true;

}
isAggregateType!(Result)
{
	enum bool isAggregateType = true;

}
toStringRadixConvert!48LU
{
	pure nothrow @system string toStringRadixConvert(uint runtimeRadix = 0u)
	{
		ulong div = void;
		ulong mValue = unsigned(value);
		ulong index = 48LU;
		char[48] buffer = void;
		char baseChar = cast(int)letterCase == 1 ? 'a' : 'A';
		char mod = void;
		do
		{
			div = mValue / cast(ulong)runtimeRadix;
			mod = cast(char)cast(ubyte)(mValue % cast(ulong)runtimeRadix);
			cast(int)mod += cast(int)mod < 10 ? 48 : cast(int)baseChar - 10;
			buffer[index -= 1LU] = mod;
			mValue = div;
		}
		while (mValue);
		return cast(string)dup(buffer[index..48]);
	}

}
isAggregateType!char
{
	enum bool isAggregateType = false;

}
isSomeString!char
{
	enum bool isSomeString = false;

}
isIntegral!char
{
	enum bool isIntegral = false;

}
isBoolean!char
{
	enum bool isBoolean = false;

}
put!(Appender!string, char)
{
	pure nothrow @safe void put(ref Appender!string r, char e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, char)
{
	pure nothrow @safe void doPut(ref Appender!string r, ref char e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
hasMember!(Appender!string, "put")
{
	enum bool hasMember = true;

}
formatValue!(Appender!string, const(ubyte), char)
{
	pure @safe void formatValue(ref Appender!string w, ref const(ubyte) val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
IntegralTypeOf!ubyte
{
	alias IntegralTypeOf = ubyte;

}
hasToString!(ubyte, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!ubyte
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
OriginalType!(const(ubyte))
{
	alias OriginalType = const(ubyte);

}
_OriginalType!(const(ubyte))
{
	alias OriginalType = const(ubyte);

}
ModifyTypePreservingTQ!(Impl, const(ubyte))
{
	alias ModifyTypePreservingTQ = const const(ubyte);

}
Modifier!ubyte
{
	alias Impl = ubyte;

}
isAggregateType!(const(ubyte))
{
	enum bool isAggregateType = false;

}
Unqual!(const(ubyte), ubyte)
{
	alias Unqual = ubyte;

}
isSIMDVector!ubyte
{
	enum bool isSIMDVector = false;

}
isDelegate!ubyte
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, ubyte, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(ubyte) obj, ref scope const(FormatSpec!char) f)
	{
		alias U = ubyte;
		ubyte val = obj;
		if (cast(int)f.spec == 114)
		{
			const(char)[] raw = (*function (ref ubyte val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..1])(val);
			import std.range.primitives : put;
			if (needToSwapEndianess(f))
			{
				scope const(char)[] __r402 = raw[];
				ulong __key403 = __r402.length;
				for (; __key403--;)
				{
					const const(char) c = __r402[__key403];
					put(w, c);
				}
			}
			else
			{
				scope const(char)[] __r404 = raw[];
				ulong __key405 = 0LU;
				for (; __key405 < __r404.length; __key405 += 1LU)
				{
					const const(char) c = __r404[__key405];
					put(w, c);
				}
			}
			return ;
		}
		const const(bool) negative = false;
		ulong arg = cast(ulong)val;
		arg &= 255LU;
		formatValueImplUlong(w, arg, false, f);
	}

}
__lambda5!ubyte
{
	function (ref ubyte val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..1]
}
put!(Appender!string, const(char))
{
	pure nothrow @safe void put(ref Appender!string r, const(char) e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, const(char))
{
	pure nothrow @safe void doPut(ref Appender!string r, ref const(char) e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
isSigned!ubyte
{
	enum bool isSigned = false;

}
formatValueImplUlong!(Appender!string, char)
{
	pure @safe void formatValueImplUlong(ref Appender!string w, ulong arg, in bool negative, ref scope const(FormatSpec!char) f)
	{
		immutable immutable(uint) base = baseOfSpec(f.spec);
		const const(bool) zero = arg == 0LU;
		char[64] digits = void;
		ulong pos = 63LU;
		do
		{
			digits[pos--] = cast(char)(48LU + arg % cast(ulong)base);
			if (base > 10u && (cast(int)digits[pos + 1LU] > 57))
				cast(int)digits[pos + 1LU] += (cast(int)f.spec == 120 || cast(int)f.spec == 97 ? 97 : 65) - 48 - 10;
			arg /= cast(ulong)base;
		}
		while (arg > 0LU);
		char[3] prefix = void;
		ulong left = 2LU;
		ulong right = 2LU;
		if (cast(int)f.spec != 120 && (cast(int)f.spec != 88) && (cast(int)f.spec != 98) && (cast(int)f.spec != 111) && (cast(int)f.spec != 117))
		{
			if (negative)
				prefix[right++] = '-';
			else if (f.flPlus())
				prefix[right++] = '+';
			else if (f.flSpace())
				prefix[right++] = ' ';
		}
		if (cast(int)f.spec == 120 || cast(int)f.spec == 88 || cast(int)f.spec == 98 || cast(int)f.spec == 111 || cast(int)f.spec == 117 || cast(int)f.spec == 100 || cast(int)f.spec == 115)
		{
			if (f.flHash() && (base == 16u) && !zero)
			{
				prefix[left -= 1LU] = f.spec;
				prefix[left -= 1LU] = '0';
			}
			if (f.flHash() && (base == 8u) && !zero && (64LU - (pos + 1LU) >= cast(ulong)f.precision || f.precision == 2147483646))
				prefix[left -= 1LU] = '0';
			writeAligned(w, prefix[left..right], digits[pos + 1LU..64], "", f, true);
			return ;
		}
		FormatSpec!char fs = f;
		if (f.precision == 2147483646)
			fs.precision = cast(int)(64LU - pos - 2LU);
		if (cast(int)f.spec == 102 || cast(int)f.spec == 70 || (cast(int)f.spec == 103 || cast(int)f.spec == 71) && (cast(ulong)fs.precision >= 64LU - pos - 2LU))
		{
			if (f.precision == 2147483646)
				fs.precision = 0;
			writeAligned(w, prefix[left..right], digits[pos + 1LU..64], ".", "", fs, cast(int)f.spec == 103 || cast(int)f.spec == 71 ? PrecisionType.allDigits : PrecisionType.fractionalDigits);
			return ;
		}
		import std.algorithm.searching : all;
		if ((cast(int)f.spec == 103 || cast(int)f.spec == 71) && (fs.precision == 0))
			fs.precision = 1;
		ulong digit_end = pos + cast(ulong)fs.precision + (cast(int)f.spec == 103 || cast(int)f.spec == 71 ? 1LU : 2LU);
		if (digit_end <= 64LU)
		{
			RoundingClass rt = RoundingClass.ZERO;
			if (digit_end < 64LU)
			{
				char tie = cast(int)f.spec == 97 || cast(int)f.spec == 65 ? '8' : '5';
				if (cast(int)digits[digit_end] >= cast(int)tie)
				{
					rt = RoundingClass.UPPER;
					if (cast(int)digits[digit_end] == cast(int)tie && all(digits[digit_end + 1LU..64]))
						rt = RoundingClass.FIVE;
				}
				else
				{
					rt = RoundingClass.LOWER;
					if (all(digits[digit_end..64]))
						rt = RoundingClass.ZERO;
				}
			}
			if (round(digits, pos + 1LU, digit_end, rt, negative, cast(int)f.spec == 97 ? 'f' : cast(int)f.spec == 65 ? 'F' : '9'))
			{
				pos--;
				digit_end--;
			}
		}
		char[1] int_digit = void;
		int_digit[0] = digits[pos + 1LU];
		digits[pos + 1LU] = '.';
		char[4] suffix = void;
		if (cast(int)f.spec == 101 || cast(int)f.spec == 69 || cast(int)f.spec == 103 || cast(int)f.spec == 71)
		{
			suffix[0] = cast(int)f.spec == 101 || cast(int)f.spec == 103 ? 'e' : 'E';
			suffix[1] = '+';
			suffix[2] = cast(char)(48LU + (64LU - pos - 2LU) / 10LU);
			suffix[3] = cast(char)(48LU + (64LU - pos - 2LU) % 10LU);
		}
		else
		{
			if (right == 3LU)
				prefix[0] = prefix[2];
			prefix[1] = '0';
			prefix[2] = cast(int)f.spec == 97 ? 'x' : 'X';
			left = right == 3LU ? 0LU : 1LU;
			right = 3LU;
			suffix[0] = cast(int)f.spec == 97 ? 'p' : 'P';
			suffix[1] = '+';
			suffix[2] = cast(char)(48LU + (64LU - pos - 2LU) * 4LU / 10LU);
			suffix[3] = cast(char)(48LU + (64LU - pos - 2LU) * 4LU % 10LU);
		}
		import std.algorithm.comparison : min;
		if ((cast(int)f.spec == 103 || cast(int)f.spec == 71) && !f.flHash())
		{
			digit_end = min(digit_end, 64LU);
			for (; digit_end > pos + 1LU && (cast(int)digits[digit_end - 1LU] == 48 || cast(int)digits[digit_end - 1LU] == 46);)
			{
				digit_end--;
			}
		}
		writeAligned(w, prefix[left..right], int_digit[0..1], digits[pos + 1LU..min(digit_end, 64LU)], suffix[0..4], fs, cast(int)f.spec == 103 || cast(int)f.spec == 71 ? PrecisionType.allDigits : PrecisionType.fractionalDigits);
	}

}
writeAligned!(Appender!string, char[], char[], string, char)
{
	pure @safe void writeAligned(ref Appender!string w, char[] prefix, char[] grouped, string suffix, ref scope const(FormatSpec!char) f, bool integer_precision = false)
	{
		writeAligned(w, prefix, grouped, "", suffix, f, integer_precision ? PrecisionType.integer : PrecisionType.none);
	}

}
writeAligned!(Appender!string, char[], char[], string, string, char)
{
	pure @safe void writeAligned(ref Appender!string w, char[] prefix, char[] grouped, string fracts, string suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key406 = 0LU;
					ulong __limit407 = fracts.length;
					for (; __key406 < __limit407; __key406 += 1LU)
					{
						ulong i = __key406;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key408 = 0L;
					long __limit409 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key408 < __limit409; __key408 += 1L)
					{
						long i = __key408;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key410 = 0L;
					long __limit411 = delta;
					for (; __key410 < __limit411; __key410 += 1L)
					{
						long i = __key410;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key412 = 0L;
					long __limit413 = delta;
					for (; __key412 < __limit413; __key412 += 1L)
					{
						long i = __key412;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key415 = 0L;
				long __limit416 = delta;
				for (; __key415 < __limit416; __key415 += 1L)
				{
					long i = __key415;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key417 = 0LU;
				ulong __limit418 = cast(ulong)pregrouped + grouped.length;
				for (; __key417 < __limit418; __key417 += 1LU)
				{
					ulong i = __key417;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key419 = 0L;
				long __limit420 = pregrouped;
				for (; __key419 < __limit420; __key419 += 1L)
				{
					long i = __key419;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key421 = 0L;
			long __limit422 = trailingZeros;
			for (; __key421 < __limit422; __key421 += 1L)
			{
				long i = __key421;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key423 = 0L;
					long __limit424 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key423 < __limit424; __key423 += 1L)
					{
						long i = __key423;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key425 = 0L;
					long __limit426 = delta;
					for (; __key425 < __limit426; __key425 += 1L)
					{
						long i = __key425;
						put(w, ' ');
					}
				}
			}
		}
	}

}
put!(Appender!string, char[])
{
	pure nothrow @safe void put(ref Appender!string r, char[] e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, char[])
{
	pure nothrow @safe void doPut(ref Appender!string r, ref char[] e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
put!(Appender!string, const(dchar))
{
	pure @safe void put(ref Appender!string r, const(dchar) e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, const(dchar))
{
	pure @safe void doPut(ref Appender!string r, ref const(dchar) e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
canPutItem!(const(dchar))
{
	enum bool canPutItem = true;

}
Unqual!(const(dchar), dchar)
{
	alias Unqual = dchar;

}
canPutConstRange!(const(dchar))
{
	enum bool canPutConstRange = false;

}
isInputRange!(const(dchar))
{
	enum bool isInputRange = false;

}
canPutRange!(const(dchar))
{
	enum bool canPutRange = false;

}
put!(const(dchar))
{
	pure @safe void put(const(dchar) item)
	{
		import std.utf : encode;
		char[4] encoded = '\xff';
		ulong len = encode(encoded, item);
		this.put(encoded[0..len]);
	}

}
put!(Appender!string, string)
{
	pure nothrow @safe void put(ref Appender!string r, string e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, string)
{
	pure nothrow @safe void doPut(ref Appender!string r, ref string e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
all!((a) => a == '0')
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
all!(char[])
{
	pure @safe bool all(char[] range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda16, "a")
{
	__lambda16(__T9)(a)
	{
		return a == '0';
	}

}
needOpCallAlias!(__lambda16)
{
	enum bool needOpCallAlias = false;

}
__lambda16!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a == 48u
}
not!(__lambda16)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, char[])
{
	pure @safe char[] find(char[] haystack)
	{
		alias R = char[];
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		import std.utf : decode;
		immutable immutable(ulong) len = haystack.length;
		ulong i = 0LU;
		ulong next = 0LU;
		for (; next < len;)
		{
			{
				if (not(decode(haystack, next)))
					return haystack[i..__dollar];
				i = next;
			}
		}
		return haystack[__dollar..__dollar];
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(dchar _param_0)
	{
		return !__lambda16(_param_0);
	}

}
all!((a) => a == '0')
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
all!(char[])
{
	pure @safe bool all(char[] range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda17, "a")
{
	__lambda17(__T10)(a)
	{
		return a == '0';
	}

}
needOpCallAlias!(__lambda17)
{
	enum bool needOpCallAlias = false;

}
__lambda17!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a == 48u
}
not!(__lambda17)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, char[])
{
	pure @safe char[] find(char[] haystack)
	{
		alias R = char[];
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		import std.utf : decode;
		immutable immutable(ulong) len = haystack.length;
		ulong i = 0LU;
		ulong next = 0LU;
		for (; next < len;)
		{
			{
				if (not(decode(haystack, next)))
					return haystack[i..__dollar];
				i = next;
			}
		}
		return haystack[__dollar..__dollar];
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(dchar _param_0)
	{
		return !__lambda17(_param_0);
	}

}
writeAligned!(Appender!string, char[], char[], char[], char[], char)
{
	pure @safe void writeAligned(ref Appender!string w, char[] prefix, char[] grouped, char[] fracts, char[] suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key427 = 0LU;
					ulong __limit428 = fracts.length;
					for (; __key427 < __limit428; __key427 += 1LU)
					{
						ulong i = __key427;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key429 = 0L;
					long __limit430 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key429 < __limit430; __key429 += 1L)
					{
						long i = __key429;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key431 = 0L;
					long __limit432 = delta;
					for (; __key431 < __limit432; __key431 += 1L)
					{
						long i = __key431;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key433 = 0L;
					long __limit434 = delta;
					for (; __key433 < __limit434; __key433 += 1L)
					{
						long i = __key433;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key435 = 0L;
				long __limit436 = delta;
				for (; __key435 < __limit436; __key435 += 1L)
				{
					long i = __key435;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key437 = 0LU;
				ulong __limit438 = cast(ulong)pregrouped + grouped.length;
				for (; __key437 < __limit438; __key437 += 1LU)
				{
					ulong i = __key437;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key439 = 0L;
				long __limit440 = pregrouped;
				for (; __key439 < __limit440; __key439 += 1L)
				{
					long i = __key439;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key441 = 0L;
			long __limit442 = trailingZeros;
			for (; __key441 < __limit442; __key441 += 1L)
			{
				long i = __key441;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key443 = 0L;
					long __limit444 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key443 < __limit444; __key443 += 1L)
					{
						long i = __key443;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key445 = 0L;
					long __limit446 = delta;
					for (; __key445 < __limit446; __key445 += 1L)
					{
						long i = __key445;
						put(w, ' ');
					}
				}
			}
		}
	}

}
formatValue!(Appender!string, const(int), char)
{
	pure @safe void formatValue(ref Appender!string w, ref const(int) val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
OriginalType!(const(int))
{
	alias OriginalType = const(int);

}
_OriginalType!(const(int))
{
	alias OriginalType = const(int);

}
ModifyTypePreservingTQ!(Impl, const(int))
{
	alias ModifyTypePreservingTQ = const const(int);

}
Modifier!int
{
	alias Impl = int;

}
isAggregateType!(const(int))
{
	enum bool isAggregateType = false;

}
Unqual!(const(int), int)
{
	alias Unqual = int;

}
formatValueImpl!(Appender!string, int, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(int) obj, ref scope const(FormatSpec!char) f)
	{
		alias U = int;
		int val = obj;
		if (cast(int)f.spec == 114)
		{
			const(char)[] raw = (*function (ref int val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..4])(val);
			import std.range.primitives : put;
			if (needToSwapEndianess(f))
			{
				scope const(char)[] __r451 = raw[];
				ulong __key452 = __r451.length;
				for (; __key452--;)
				{
					const const(char) c = __r451[__key452];
					put(w, c);
				}
			}
			else
			{
				scope const(char)[] __r453 = raw[];
				ulong __key454 = 0LU;
				for (; __key454 < __r453.length; __key454 += 1LU)
				{
					const const(char) c = __r453[__key454];
					put(w, c);
				}
			}
			return ;
		}
		const const(bool) negative = val < 0 && (cast(int)f.spec != 120) && (cast(int)f.spec != 88) && (cast(int)f.spec != 98) && (cast(int)f.spec != 111) && (cast(int)f.spec != 117);
		ulong arg = negative ? -cast(ulong)val : cast(ulong)val;
		arg &= 4294967295LU;
		formatValueImplUlong(w, arg, negative, f);
	}

}
__lambda5!int
{
	function (ref int val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..4]
}
isOutputRange!(Appender!string, char)
{
	enum bool isOutputRange = true;

}
lvalueOf!(Appender!string)
{
	@property ref Appender!string lvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
toString!(Appender!string)
{
	const pure @safe void toString(ref Appender!string writer)
	{
		import std.format.write : formatValue;
		FormatSpec!char s = singleSpec("%s");
		put(writer, "address = ");
		formatValue(writer, &this, s);
		put(writer, "\nwidth = ");
		formatValue(writer, this.width, s);
		put(writer, "\nprecision = ");
		formatValue(writer, this.precision, s);
		put(writer, "\nspec = ");
		formatValue(writer, this.spec, s);
		put(writer, "\nindexStart = ");
		formatValue(writer, this.indexStart, s);
		put(writer, "\nindexEnd = ");
		formatValue(writer, this.indexEnd, s);
		put(writer, "\nflDash = ");
		formatValue(writer, this.flDash(), s);
		put(writer, "\nflZero = ");
		formatValue(writer, this.flZero(), s);
		put(writer, "\nflSpace = ");
		formatValue(writer, this.flSpace(), s);
		put(writer, "\nflPlus = ");
		formatValue(writer, this.flPlus(), s);
		put(writer, "\nflEqual = ");
		formatValue(writer, this.flEqual(), s);
		put(writer, "\nflHash = ");
		formatValue(writer, this.flHash(), s);
		put(writer, "\nflSeparator = ");
		formatValue(writer, this.flSeparator(), s);
		put(writer, "\nnested = ");
		formatValue(writer, this.nested, s);
		put(writer, "\ntrailing = ");
		formatValue(writer, this.trailing, s);
		put(writer, '\n');
	}

}
singleSpec!(immutable(char))
{
	pure @safe FormatSpec!char singleSpec(string fmt)
	{
		import std.conv : text;
		import std.format : enforceFmt;
		import std.range.primitives : empty, front;
		enforce(fmt.length >= 2LU, delegate const(char)[]() pure nothrow @nogc @safe => "fmt must be at least 2 characters long", "/usr/include/dmd/phobos/std/format/spec.d", 859LU);
		enforce(cast(uint)front(cast(const(char)[])fmt) == 37u, delegate const(char)[]() pure nothrow @nogc @safe => "fmt must start with a '%' character", "/usr/include/dmd/phobos/std/format/spec.d", 860LU);
		enforce(cast(int)fmt[1] != 37, delegate const(char)[]() pure nothrow @nogc @safe => "'%%' is not a permissible format specifier", "/usr/include/dmd/phobos/std/format/spec.d", 861LU);
		static struct DummyOutputRange
		{
			void put(C)(scope const C[] buf)
			{
			}
		}
		DummyOutputRange a = DummyOutputRange();
		FormatSpec!char spec = spec = FormatSpec , spec.this(fmt);
		spec.writeUpToNextSpec(a);
		enforce(empty(spec.trailing), delegate const(char)[]() pure nothrow @nogc @safe => text("Trailing characters in fmt string: '", spec.trailing), "/usr/include/dmd/phobos/std/format/spec.d", 872LU);
		return spec;
	}

}
FormatSpec!(immutable(char))
{
	alias FormatSpec = FormatSpec!char;

}
RTInfo!(DummyOutputRange)
{
	enum immutable(void)* RTInfo = null;

}
writeUpToNextSpec!(DummyOutputRange)
{
	pure scope @safe bool writeUpToNextSpec(ref DummyOutputRange writer)
	{
		import std.format : enforceFmt;
		if (empty(this.trailing))
			return false;
		{
			ulong i = 0LU;
			for (; i < this.trailing.length; i += 1LU)
			{
				{
					if (cast(int)this.trailing[i] != 37)
						continue;
					put(writer, this.trailing[0..i]);
					this.trailing = this.trailing[i..__dollar];
					enforce(this.trailing.length >= 2LU, delegate const(char)[]() pure nothrow @nogc @safe => "Unterminated format specifier: \"%\"", "/usr/include/dmd/phobos/std/format/spec.d", 260LU);
					this.trailing = this.trailing[1..__dollar];
					if (cast(int)this.trailing[0] != 37)
					{
						this.fillUp();
						return true;
					}
					i = 0LU;
				}
			}
		}
		put(writer, this.trailing);
		this.trailing = null;
		return false;
	}

}
put!(DummyOutputRange, const(char)[])
{
	pure nothrow @nogc @safe void put(ref DummyOutputRange r, const(char)[] e)
	{
		doPut(r, e);
	}

}
doPut!(DummyOutputRange, const(char)[])
{
	pure nothrow @nogc @safe void doPut(ref DummyOutputRange r, ref const(char)[] e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
hasMember!(DummyOutputRange, "put")
{
	enum bool hasMember = true;

}
put!char
{
	pure nothrow @nogc @safe void put(scope const(char[]) buf)
	{
	}

}
formatValue!(Appender!string, const(FormatSpec!char)*, char)
{
	pure @safe void formatValue(ref Appender!string w, const(FormatSpec!char)* val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
OriginalType!(const(FormatSpec!char)*)
{
	alias OriginalType = const(FormatSpec!char)*;

}
_OriginalType!(const(FormatSpec!char)*)
{
	alias OriginalType = const(FormatSpec!char)*;

}
ModifyTypePreservingTQ!(Impl, const(FormatSpec!char)*)
{
	alias ModifyTypePreservingTQ = const(FormatSpec!char)*;

}
Modifier!(const(FormatSpec!char)*)
{
	alias Impl = const(FormatSpec!char)*;

}
isAggregateType!(const(FormatSpec!char)*)
{
	enum bool isAggregateType = false;

}
Unqual!(const(FormatSpec!char)*, const(FormatSpec!char)*)
{
	alias Unqual = const(FormatSpec!char)*;

}
isPointer!(const(FormatSpec!char)*)
{
	enum bool isPointer = true;

}
hasToString!(const(FormatSpec!char)*, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isSIMDVector!(const(FormatSpec!char)*)
{
	enum bool isSIMDVector = false;

}
isDelegate!(const(FormatSpec!char)*)
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, const(FormatSpec!char)*, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, scope const(FormatSpec!char*) val, ref scope const(FormatSpec!char) f)
	{
		template SharedOf(T)
		{
			alias SharedOf = T;
		}
		const const(void*) p = cast(const(void*))val;
		const const(ulong) pnum = delegate () pure nothrow @nogc @trusted => cast(ulong)p();
		if (cast(int)f.spec == 115)
		{
			if (p is null)
			{
				writeAligned(w, "null", f);
				return ;
			}
			FormatSpec!char fs = f;
			fs.spec = 'X';
			formatValueImpl(w, pnum, fs);
		}
		else
		{
			import std.format : enforceFmt;
			enforce(cast(int)f.spec == 88 || cast(int)f.spec == 120, delegate const(char)[]() pure nothrow @nogc @safe => "Expected one of %s, %x or %X for pointer type.", "/usr/include/dmd/phobos/std/format/internal/write.d", 3129LU);
			formatValueImpl(w, pnum, f);
		}
	}

}
writeAligned!(Appender!string, string, char)
{
	pure @safe void writeAligned(ref Appender!string w, string s, ref scope const(FormatSpec!char) f)
	{
		FormatSpec!char fs = f;
		fs.flZero(false);
		writeAligned(w, "", "", s, fs, false);
	}

}
writeAligned!(Appender!string, string, string, string, char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, string suffix, ref scope const(FormatSpec!char) f, bool integer_precision = false)
	{
		writeAligned(w, prefix, grouped, "", suffix, f, integer_precision ? PrecisionType.integer : PrecisionType.none);
	}

}
writeAligned!(Appender!string, string, string, string, string, char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, string fracts, string suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key461 = 0LU;
					ulong __limit462 = fracts.length;
					for (; __key461 < __limit462; __key461 += 1LU)
					{
						ulong i = __key461;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key463 = 0L;
					long __limit464 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key463 < __limit464; __key463 += 1L)
					{
						long i = __key463;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key465 = 0L;
					long __limit466 = delta;
					for (; __key465 < __limit466; __key465 += 1L)
					{
						long i = __key465;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key467 = 0L;
					long __limit468 = delta;
					for (; __key467 < __limit468; __key467 += 1L)
					{
						long i = __key467;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key469 = 0L;
				long __limit470 = delta;
				for (; __key469 < __limit470; __key469 += 1L)
				{
					long i = __key469;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key471 = 0LU;
				ulong __limit472 = cast(ulong)pregrouped + grouped.length;
				for (; __key471 < __limit472; __key471 += 1LU)
				{
					ulong i = __key471;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key473 = 0L;
				long __limit474 = pregrouped;
				for (; __key473 < __limit474; __key473 += 1L)
				{
					long i = __key473;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key475 = 0L;
			long __limit476 = trailingZeros;
			for (; __key475 < __limit476; __key475 += 1L)
			{
				long i = __key475;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key477 = 0L;
					long __limit478 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key477 < __limit478; __key477 += 1L)
					{
						long i = __key477;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key479 = 0L;
					long __limit480 = delta;
					for (; __key479 < __limit480; __key479 += 1L)
					{
						long i = __key479;
						put(w, ' ');
					}
				}
			}
		}
	}

}
IntegralTypeOf!ulong
{
	alias IntegralTypeOf = ulong;

}
hasToString!(ulong, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!ulong
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
OriginalType!(const(ulong))
{
	alias OriginalType = const(ulong);

}
_OriginalType!(const(ulong))
{
	alias OriginalType = const(ulong);

}
ModifyTypePreservingTQ!(Impl, const(ulong))
{
	alias ModifyTypePreservingTQ = const const(ulong);

}
Modifier!ulong
{
	alias Impl = ulong;

}
isAggregateType!(const(ulong))
{
	enum bool isAggregateType = false;

}
isSIMDVector!ulong
{
	enum bool isSIMDVector = false;

}
isDelegate!ulong
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, ulong, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(ulong) obj, ref scope const(FormatSpec!char) f)
	{
		alias U = ulong;
		ulong val = obj;
		if (cast(int)f.spec == 114)
		{
			const(char)[] raw = (*function (ref ulong val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..8])(val);
			import std.range.primitives : put;
			if (needToSwapEndianess(f))
			{
				scope const(char)[] __r486 = raw[];
				ulong __key487 = __r486.length;
				for (; __key487--;)
				{
					const const(char) c = __r486[__key487];
					put(w, c);
				}
			}
			else
			{
				scope const(char)[] __r488 = raw[];
				ulong __key489 = 0LU;
				for (; __key489 < __r488.length; __key489 += 1LU)
				{
					const const(char) c = __r488[__key489];
					put(w, c);
				}
			}
			return ;
		}
		const const(bool) negative = false;
		ulong arg = val;
		arg &= 18446744073709551615LU;
		formatValueImplUlong(w, arg, false, f);
	}

}
__lambda5!ulong
{
	function (ref ulong val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..8]
}
formatValue!(Appender!string, const(char), char)
{
	pure @safe void formatValue(ref Appender!string w, ref const(char) val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
OriginalType!char
{
	alias OriginalType = char;

}
CharTypeOf!char
{
	alias CharTypeOf = char;

}
hasToString!(char, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!char
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
OriginalType!(const(char))
{
	alias OriginalType = const(char);

}
_OriginalType!(const(char))
{
	alias OriginalType = const(char);

}
ModifyTypePreservingTQ!(Impl, const(char))
{
	alias ModifyTypePreservingTQ = const const(char);

}
Modifier!char
{
	alias Impl = char;

}
isAggregateType!(const(char))
{
	enum bool isAggregateType = false;

}
isSIMDVector!char
{
	enum bool isSIMDVector = false;

}
isDelegate!char
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, char, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(char) obj, ref scope const(FormatSpec!char) f)
	{
		import std.meta : AliasSeq;
		char[1] val = obj;
		if (cast(int)f.spec == 115 || cast(int)f.spec == 99)
			writeAligned(w, val[], f);
		else
		{
			alias U = ubyte;
			formatValueImpl(w, cast(ubyte)val[0], f);
		}
	}

}
writeAligned!(Appender!string, char[], char)
{
	pure @safe void writeAligned(ref Appender!string w, char[] s, ref scope const(FormatSpec!char) f)
	{
		FormatSpec!char fs = f;
		fs.flZero(false);
		writeAligned(w, "", "", s, fs, false);
	}

}
writeAligned!(Appender!string, string, string, char[], char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, char[] suffix, ref scope const(FormatSpec!char) f, bool integer_precision = false)
	{
		writeAligned(w, prefix, grouped, "", suffix, f, integer_precision ? PrecisionType.integer : PrecisionType.none);
	}

}
writeAligned!(Appender!string, string, string, string, char[], char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, string fracts, char[] suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key498 = 0LU;
					ulong __limit499 = fracts.length;
					for (; __key498 < __limit499; __key498 += 1LU)
					{
						ulong i = __key498;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key500 = 0L;
					long __limit501 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key500 < __limit501; __key500 += 1L)
					{
						long i = __key500;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key502 = 0L;
					long __limit503 = delta;
					for (; __key502 < __limit503; __key502 += 1L)
					{
						long i = __key502;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key504 = 0L;
					long __limit505 = delta;
					for (; __key504 < __limit505; __key504 += 1L)
					{
						long i = __key504;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key506 = 0L;
				long __limit507 = delta;
				for (; __key506 < __limit507; __key506 += 1L)
				{
					long i = __key506;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key508 = 0LU;
				ulong __limit509 = cast(ulong)pregrouped + grouped.length;
				for (; __key508 < __limit509; __key508 += 1LU)
				{
					ulong i = __key508;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key510 = 0L;
				long __limit511 = pregrouped;
				for (; __key510 < __limit511; __key510 += 1L)
				{
					long i = __key510;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key512 = 0L;
			long __limit513 = trailingZeros;
			for (; __key512 < __limit513; __key512 += 1L)
			{
				long i = __key512;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key514 = 0L;
					long __limit515 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key514 < __limit515; __key514 += 1L)
					{
						long i = __key514;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key516 = 0L;
					long __limit517 = delta;
					for (; __key516 < __limit517; __key516 += 1L)
					{
						long i = __key516;
						put(w, ' ');
					}
				}
			}
		}
	}

}
isAggregateType!ubyte
{
	enum bool isAggregateType = false;

}
formatValue!(Appender!string, bool, char)
{
	pure @safe void formatValue(ref Appender!string w, bool val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
BooleanTypeOf!bool
{
	alias BooleanTypeOf = bool;

}
OriginalType!bool
{
	alias OriginalType = bool;

}
_OriginalType!bool
{
	alias OriginalType = bool;

}
ModifyTypePreservingTQ!(Impl, bool)
{
	alias ModifyTypePreservingTQ = bool;

}
Modifier!bool
{
	alias Impl = bool;

}
hasToString!(bool, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!bool
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
isAggregateType!bool
{
	enum bool isAggregateType = false;

}
Unqual!(bool, bool)
{
	alias Unqual = bool;

}
isSIMDVector!bool
{
	enum bool isSIMDVector = false;

}
isDelegate!bool
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, bool, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(bool) obj, ref scope const(FormatSpec!char) f)
	{
		bool val = obj;
		if (cast(int)f.spec == 115)
			writeAligned(w, val ? "true" : "false", f);
		else
			formatValueImpl(w, cast(byte)val, f);
	}

}
OriginalType!byte
{
	alias OriginalType = byte;

}
_OriginalType!byte
{
	alias OriginalType = byte;

}
ModifyTypePreservingTQ!(Impl, byte)
{
	alias ModifyTypePreservingTQ = byte;

}
Modifier!byte
{
	alias Impl = byte;

}
IntegralTypeOf!byte
{
	alias IntegralTypeOf = byte;

}
hasToString!(byte, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!byte
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
isAggregateType!byte
{
	enum bool isAggregateType = false;

}
Unqual!(byte, byte)
{
	alias Unqual = byte;

}
isSIMDVector!byte
{
	enum bool isSIMDVector = false;

}
isDelegate!byte
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, byte, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(byte) obj, ref scope const(FormatSpec!char) f)
	{
		alias U = byte;
		byte val = obj;
		if (cast(int)f.spec == 114)
		{
			const(char)[] raw = (*function (ref byte val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..1])(val);
			import std.range.primitives : put;
			if (needToSwapEndianess(f))
			{
				scope const(char)[] __r533 = raw[];
				ulong __key534 = __r533.length;
				for (; __key534--;)
				{
					const const(char) c = __r533[__key534];
					put(w, c);
				}
			}
			else
			{
				scope const(char)[] __r535 = raw[];
				ulong __key536 = 0LU;
				for (; __key536 < __r535.length; __key536 += 1LU)
				{
					const const(char) c = __r535[__key536];
					put(w, c);
				}
			}
			return ;
		}
		const const(bool) negative = cast(int)val < 0 && (cast(int)f.spec != 120) && (cast(int)f.spec != 88) && (cast(int)f.spec != 98) && (cast(int)f.spec != 111) && (cast(int)f.spec != 117);
		ulong arg = negative ? -cast(ulong)val : cast(ulong)cast(int)val;
		arg &= 255LU;
		formatValueImplUlong(w, arg, negative, f);
	}

}
__lambda5!byte
{
	function (ref byte val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..1]
}
isSigned!byte
{
	enum bool isSigned = true;

}
Unsigned!byte
{
	alias Unsigned = ubyte;

}
ModifyTypePreservingTQ!(Impl, byte)
{
	alias ModifyTypePreservingTQ = ubyte;

}
_ModifyTypePreservingTQ!(Impl, byte)
{
	alias ModifyTypePreservingTQ = ubyte;

}
Modifier!byte
{
	alias Impl = ubyte;

}
isUnsigned!byte
{
	enum bool isUnsigned = false;

}
isFloatingPoint!byte
{
	enum bool isFloatingPoint = false;

}
formatValue!(Appender!string, const(char[]), char)
{
	pure @safe void formatValue(ref Appender!string w, ref const(char[]) val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
OriginalType!(const(char)[])
{
	alias OriginalType = const(char)[];

}
_OriginalType!(const(char)[])
{
	alias OriginalType = const(char)[];

}
ModifyTypePreservingTQ!(Impl, const(char)[])
{
	alias ModifyTypePreservingTQ = const(char)[];

}
Modifier!(const(char)[])
{
	alias Impl = const(char)[];

}
hasToString!(const(char)[], char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!(const(char)[])
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
OriginalType!(const(char[]))
{
	alias OriginalType = const(char[]);

}
_OriginalType!(const(char[]))
{
	alias OriginalType = const(char[]);

}
ModifyTypePreservingTQ!(Impl, const(char[]))
{
	alias ModifyTypePreservingTQ = const const(char[]);

}
Modifier!(const(char)[])
{
	alias Impl = const(char)[];

}
DynamicArrayTypeOf!(const(char)[])
{
	alias DynamicArrayTypeOf = const(char)[];

}
_DynamicArrayTypeOf!(const(char)[])
{
	alias DynamicArrayTypeOf = const(char)[];

}
isAggregateType!(const(char)[])
{
	enum bool isAggregateType = false;

}
isSIMDVector!(const(char)[])
{
	enum bool isSIMDVector = false;

}
isDelegate!(const(char)[])
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, const(char)[], char)
{
	pure @safe void formatValueImpl(ref Appender!string w, scope const(char[]) obj, ref scope const(FormatSpec!char) f)
	{
		const(char)[] val = obj;
		formatRange(w, val, f);
	}

}
Unqual!(const(char[]), const(char)[])
{
	alias Unqual = const(char)[];

}
formatRange!(Appender!string, const(char)[], char)
{
	pure @safe void formatRange(ref Appender!string w, ref const(char)[] val, ref scope const(FormatSpec!char) f)
	{
		import std.conv : text;
		import std.format : FormatException, formatValue, NoOpSink;
		import std.range.primitives : ElementType, empty, front, hasLength, walkLength, isForwardRange, isInfinite, popFront, put;
		enum bool formatTestMode = false;
		if (cast(int)f.spec == 115)
		{
			alias E = dchar;
			writeAligned(w, val[0..cast(ulong)f.precision < __dollar ? cast(ulong)f.precision : __dollar], f);
		}
		else if (cast(int)f.spec == 114)
		{
			alias ARR = const(char)[];
			scope const(char)[] a = val;
			{
				scope const(char)[] __r565 = a[];
				ulong __key566 = 0LU;
				for (; __key566 < __r565.length; __key566 += 1LU)
				{
					const const(char) e = __r565[__key566];
					formatValue(w, e, f);
				}
			}
		}
		else if (cast(int)f.spec == 40)
		{
			if (empty(val))
				return ;
			for (;;)
			{
				{
					FormatSpec!char fmt = fmt = FormatSpec , fmt.this(f.nested);
					w:
					for (; true;)
					{
						{
							immutable immutable(bool) r = fmt.writeUpToNextSpec(w);
							if (!r)
								break;
							if (f.flDash())
								formatValue(w, front(val), fmt);
							else
								formatElement(w, front(val), fmt);
							{
								ulong __key621 = 0LU;
								ulong __limit622 = fmt.trailing.length;
								for (; __key621 < __limit622; __key621 += 1LU)
								{
									ulong i = __key621;
									if (cast(int)fmt.trailing[i] == 37)
										continue w;
								}
							}
							break w;
						}
					}
					if (f.sep !is null)
					{
						put(w, fmt.trailing);
						popFront(val);
						if (empty(val))
							break;
						put(w, f.sep);
					}
					else
					{
						popFront(val);
						if (empty(val))
							break;
						put(w, fmt.trailing);
					}
				}
			}
		}
		else
			throw new FormatException(text("Incorrect format specifier for range: %", f.spec), "/usr/include/dmd/phobos/std/format/internal/write.d", 1725LU, null);
	}

}
CharTypeOf!dchar
{
	alias CharTypeOf = dchar;

}
OriginalType!dchar
{
	alias OriginalType = dchar;

}
_OriginalType!dchar
{
	alias OriginalType = dchar;

}
ModifyTypePreservingTQ!(Impl, dchar)
{
	alias ModifyTypePreservingTQ = dchar;

}
Modifier!dchar
{
	alias Impl = dchar;

}
writeAligned!(Appender!string, const(char)[], char)
{
	pure @safe void writeAligned(ref Appender!string w, const(char)[] s, ref scope const(FormatSpec!char) f)
	{
		FormatSpec!char fs = f;
		fs.flZero(false);
		writeAligned(w, "", "", s, fs, false);
	}

}
writeAligned!(Appender!string, string, string, const(char)[], char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, const(char)[] suffix, ref scope const(FormatSpec!char) f, bool integer_precision = false)
	{
		writeAligned(w, prefix, grouped, "", suffix, f, integer_precision ? PrecisionType.integer : PrecisionType.none);
	}

}
writeAligned!(Appender!string, string, string, string, const(char)[], char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, string fracts, const(char)[] suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key545 = 0LU;
					ulong __limit546 = fracts.length;
					for (; __key545 < __limit546; __key545 += 1LU)
					{
						ulong i = __key545;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key547 = 0L;
					long __limit548 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key547 < __limit548; __key547 += 1L)
					{
						long i = __key547;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key549 = 0L;
					long __limit550 = delta;
					for (; __key549 < __limit550; __key549 += 1L)
					{
						long i = __key549;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key551 = 0L;
					long __limit552 = delta;
					for (; __key551 < __limit552; __key551 += 1L)
					{
						long i = __key551;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key553 = 0L;
				long __limit554 = delta;
				for (; __key553 < __limit554; __key553 += 1L)
				{
					long i = __key553;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key555 = 0LU;
				ulong __limit556 = cast(ulong)pregrouped + grouped.length;
				for (; __key555 < __limit556; __key555 += 1LU)
				{
					ulong i = __key555;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key557 = 0L;
				long __limit558 = pregrouped;
				for (; __key557 < __limit558; __key557 += 1L)
				{
					long i = __key557;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key559 = 0L;
			long __limit560 = trailingZeros;
			for (; __key559 < __limit560; __key559 += 1L)
			{
				long i = __key559;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key561 = 0L;
					long __limit562 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key561 < __limit562; __key561 += 1L)
					{
						long i = __key561;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key563 = 0L;
					long __limit564 = delta;
					for (; __key563 < __limit564; __key563 += 1L)
					{
						long i = __key563;
						put(w, ' ');
					}
				}
			}
		}
	}

}
getWidth!(const(char)[])
{
	pure @safe long getWidth(const(char)[] s)
	{
		import std.algorithm.searching : all;
		import std.uni : graphemeStride;
		if (all(s))
			return cast(long)s.length;
		long width = 0L;
		{
			ulong i = 0LU;
			for (; i < s.length; i += graphemeStride(s, i))
			{
				width += 1L;
			}
		}
		return width;
	}

}
all!((a) => a <= 127)
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
all!(const(char)[])
{
	pure @safe bool all(const(char)[] range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda2, "a")
{
	__lambda2(__T12)(a)
	{
		return a <= 127;
	}

}
needOpCallAlias!(__lambda2)
{
	enum bool needOpCallAlias = false;

}
__lambda2!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a <= 127u
}
not!(__lambda2)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, const(char)[])
{
	pure @safe const(char)[] find(const(char)[] haystack)
	{
		alias R = const(char)[];
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		import std.utf : decode;
		immutable immutable(ulong) len = haystack.length;
		ulong i = 0LU;
		ulong next = 0LU;
		for (; next < len;)
		{
			{
				if (not(decode(haystack, next)))
					return haystack[i..__dollar];
				i = next;
			}
		}
		return haystack[__dollar..__dollar];
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(dchar _param_0)
	{
		return !__lambda2(_param_0);
	}

}
empty!(const(char)[])
{
	pure nothrow @nogc @property @safe bool empty(scope const(char)[] a)
	{
		return !a.length;
	}

}
put!(Appender!string, const(char)[])
{
	pure nothrow @safe void put(ref Appender!string r, const(char)[] e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, const(char)[])
{
	pure nothrow @safe void doPut(ref Appender!string r, ref const(char)[] e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
writeUpToNextSpec!(Appender!string)
{
	pure scope @safe bool writeUpToNextSpec(ref Appender!string writer)
	{
		import std.format : enforceFmt;
		if (empty(this.trailing))
			return false;
		{
			ulong i = 0LU;
			for (; i < this.trailing.length; i += 1LU)
			{
				{
					if (cast(int)this.trailing[i] != 37)
						continue;
					put(writer, this.trailing[0..i]);
					this.trailing = this.trailing[i..__dollar];
					enforce(this.trailing.length >= 2LU, delegate const(char)[]() pure nothrow @nogc @safe => "Unterminated format specifier: \"%\"", "/usr/include/dmd/phobos/std/format/spec.d", 260LU);
					this.trailing = this.trailing[1..__dollar];
					if (cast(int)this.trailing[0] != 37)
					{
						this.fillUp();
						return true;
					}
					i = 0LU;
				}
			}
		}
		put(writer, this.trailing);
		this.trailing = null;
		return false;
	}

}
formatValue!(Appender!string, dchar, char)
{
	pure @safe void formatValue(ref Appender!string w, dchar val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
hasToString!(dchar, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!dchar
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
isAggregateType!dchar
{
	enum bool isAggregateType = false;

}
isSIMDVector!dchar
{
	enum bool isSIMDVector = false;

}
isDelegate!dchar
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, dchar, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(dchar) obj, ref scope const(FormatSpec!char) f)
	{
		import std.meta : AliasSeq;
		dchar[1] val = obj;
		if (cast(int)f.spec == 115 || cast(int)f.spec == 99)
			writeAligned(w, val[], f);
		else
		{
			alias U = uint;
			formatValueImpl(w, cast(uint)val[0], f);
		}
	}

}
isSomeString!(dchar[])
{
	enum bool isSomeString = true;

}
writeAligned!(Appender!string, dchar[], char)
{
	pure @safe void writeAligned(ref Appender!string w, dchar[] s, ref scope const(FormatSpec!char) f)
	{
		FormatSpec!char fs = f;
		fs.flZero(false);
		writeAligned(w, "", "", s, fs, false);
	}

}
writeAligned!(Appender!string, string, string, dchar[], char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, dchar[] suffix, ref scope const(FormatSpec!char) f, bool integer_precision = false)
	{
		writeAligned(w, prefix, grouped, "", suffix, f, integer_precision ? PrecisionType.integer : PrecisionType.none);
	}

}
writeAligned!(Appender!string, string, string, string, dchar[], char)
{
	pure @safe void writeAligned(ref Appender!string w, string prefix, string grouped, string fracts, dchar[] suffix, ref scope const(FormatSpec!char) f, PrecisionType p = PrecisionType.none)
	{
		if (p == PrecisionType.integer && (f.precision == 2147483646))
			p = PrecisionType.none;
		import std.range.primitives : put;
		long prefixWidth = 0L;
		long groupedWidth = cast(long)grouped.length;
		long fractsWidth = cast(long)fracts.length;
		long suffixWidth = 0L;
		if (f.width > 0)
		{
			prefixWidth = getWidth(prefix);
			suffixWidth = getWidth(suffix);
		}
		bool doGrouping = f.flSeparator() && (groupedWidth > 0L) && (f.separators > 0) && (f.separators != 2147483646);
		long front = doGrouping ? (groupedWidth - 1L) % cast(long)f.separators + 1L : 0L;
		long sepCount = doGrouping ? (groupedWidth - 1L) / cast(long)f.separators : 0L;
		long trailingZeros = 0L;
		if (p == PrecisionType.fractionalDigits)
			trailingZeros = cast(long)f.precision - (fractsWidth - 1L);
		if (p == PrecisionType.allDigits && f.flHash())
		{
			if (!__equals(grouped, "0"))
				trailingZeros = cast(long)f.precision - (fractsWidth - 1L) - groupedWidth;
			else
			{
				trailingZeros = cast(long)f.precision - fractsWidth;
				{
					ulong __key579 = 0LU;
					ulong __limit580 = fracts.length;
					for (; __key579 < __limit580; __key579 += 1LU)
					{
						ulong i = __key579;
						if (cast(int)fracts[i] != 48 && (cast(int)fracts[i] != 46))
						{
							trailingZeros = cast(long)(cast(ulong)f.precision - (fracts.length - i));
							break;
						}
					}
				}
			}
		}
		bool nodot = __equals(fracts, ".") && (trailingZeros == 0L) && !f.flHash();
		if (nodot)
			fractsWidth = 0L;
		long width = prefixWidth + sepCount + groupedWidth + fractsWidth + trailingZeros + suffixWidth;
		long delta = cast(long)f.width - width;
		long pregrouped = 0L;
		if (p == PrecisionType.integer && (groupedWidth < cast(long)f.precision))
		{
			pregrouped = cast(long)f.precision - groupedWidth;
			delta -= pregrouped;
			if (doGrouping)
			{
				front = (front - 1L + pregrouped) % cast(long)f.separators + 1L;
				delta -= cast(long)((f.precision - 1) / f.separators) - sepCount;
			}
		}
		if ((!f.flZero() || p == PrecisionType.integer) && (delta > 0L))
		{
			if (f.flEqual())
			{
				{
					long __key581 = 0L;
					long __limit582 = delta / 2L + (delta % 2L == 1L && !f.flDash() ? 1L : 0L);
					for (; __key581 < __limit582; __key581 += 1L)
					{
						long i = __key581;
						put(w, ' ');
					}
				}
			}
			else if (!f.flDash())
			{
				{
					long __key583 = 0L;
					long __limit584 = delta;
					for (; __key583 < __limit584; __key583 += 1L)
					{
						long i = __key583;
						put(w, ' ');
					}
				}
			}
		}
		put(w, prefix);
		if (f.flZero() && (p != PrecisionType.integer) && !f.flDash() && (delta > 0L))
		{
			if (doGrouping)
			{
				long front2 = (delta + front - 1L) % cast(long)(f.separators + 1) + 1L;
				long sepCount2 = (delta + front - 1L) / cast(long)(f.separators + 1);
				delta -= sepCount2;
				if (front2 > cast(long)f.separators)
				{
					front2 = 1L;
				}
				{
					long __key585 = 0L;
					long __limit586 = delta;
					for (; __key585 < __limit586; __key585 += 1L)
					{
						long i = __key585;
						if (front2 == 0L)
						{
							put(w, f.separatorChar);
							front2 = cast(long)f.separators;
						}
						front2--;
						put(w, '0');
					}
				}
				if (front == cast(long)f.separators)
					put(w, f.separatorChar);
			}
			else
			{
				long __key587 = 0L;
				long __limit588 = delta;
				for (; __key587 < __limit588; __key587 += 1L)
				{
					long i = __key587;
					put(w, '0');
				}
			}
		}
		if (doGrouping)
		{
			{
				ulong __key589 = 0LU;
				ulong __limit590 = cast(ulong)pregrouped + grouped.length;
				for (; __key589 < __limit590; __key589 += 1LU)
				{
					ulong i = __key589;
					if (front == 0L)
					{
						put(w, f.separatorChar);
						front = cast(long)f.separators;
					}
					front--;
					put(w, i < cast(ulong)pregrouped ? '0' : grouped[i - cast(ulong)pregrouped]);
				}
			}
		}
		else
		{
			{
				long __key591 = 0L;
				long __limit592 = pregrouped;
				for (; __key591 < __limit592; __key591 += 1L)
				{
					long i = __key591;
					put(w, '0');
				}
			}
			put(w, grouped);
		}
		if (!nodot)
			put(w, fracts);
		{
			long __key593 = 0L;
			long __limit594 = trailingZeros;
			for (; __key593 < __limit594; __key593 += 1L)
			{
				long i = __key593;
				put(w, '0');
			}
		}
		put(w, suffix);
		if (delta > 0L)
		{
			if (f.flEqual())
			{
				{
					long __key601 = 0L;
					long __limit602 = delta / 2L + (delta % 2L == 1L && f.flDash() ? 1L : 0L);
					for (; __key601 < __limit602; __key601 += 1L)
					{
						long i = __key601;
						put(w, ' ');
					}
				}
			}
			else if (f.flDash())
			{
				{
					long __key603 = 0L;
					long __limit604 = delta;
					for (; __key603 < __limit604; __key603 += 1L)
					{
						long i = __key603;
						put(w, ' ');
					}
				}
			}
		}
	}

}
getWidth!(dchar[])
{
	pure nothrow @nogc @safe long getWidth(dchar[] s)
	{
		import std.algorithm.searching : all;
		import std.uni : graphemeStride;
		if (all(s))
			return cast(long)s.length;
		long width = 0L;
		{
			ulong i = 0LU;
			for (; i < s.length; i += graphemeStride(s, i))
			{
				width += 1L;
			}
		}
		return width;
	}

}
all!((a) => a <= 127)
{
	bool all(Range)(Range range) if (isInputRange!Range
	{
	}
	)
	{
		static assert(is(typeof(unaryFun!pred
		{
		}
		(range.front))), "`" ~ (isSomeString!(typeof(pred))
		{
		}
		 ? pred.stringof[1..__dollar - 1] : pred.stringof) ~ "` isn't a unary predicate function for range.front");
		import std.functional : not;
		return find!(not!(unaryFun!pred
		{
		}
		)
		{
		}
		)
		{
		}
		(range).empty;
	}

}
isInputRange!(dchar[])
{
	enum bool isInputRange = true;

}
empty!(dchar[])
{
	pure nothrow @nogc @property @safe bool empty(ref scope dchar[] a)
	{
		return !a.length;
	}

}
isCallable!(function (dchar[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (dchar[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (dchar[] r) pure nothrow @nogc @safe => empty(r))
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (dchar[] r) pure nothrow @nogc @safe => empty(r))
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(dchar[] r);

}
isAutodecodableString!(dchar[])
{
	enum bool isAutodecodableString = false;

}
front!dchar
{
	pure nothrow @nogc @property ref @safe inout(dchar) front(return scope inout(dchar)[] a)
	{
		assert(a.length, "Attempting to fetch the front of an empty array of dchar");
		return a[0];
	}

}
isCallable!(function (dchar[] r) pure nothrow @nogc @safe => front(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (dchar[] r) pure nothrow @nogc @safe => front(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (dchar[] r) pure nothrow @nogc @safe => front(r))
{
	alias ReturnType = dchar;

}
FunctionTypeOf!(function (dchar[] r) pure nothrow @nogc @safe => front(r))
{
	alias pure nothrow @nogc @safe dchar FunctionTypeOf(dchar[] r);

}
popFront!dchar
{
	pure nothrow @nogc @safe void popFront(ref scope inout(dchar)[] a)
	{
		assert(a.length, "Attempting to popFront() past the end of an array of dchar");
		a = a[1..__dollar];
	}

}
all!(dchar[])
{
	pure nothrow @nogc @safe bool all(dchar[] range)
	{
		import std.functional : not;
		return empty(find(range));
	}

}
unaryFun!(__lambda2, "a")
{
	__lambda2(__T12)(a)
	{
		return a <= 127;
	}

}
needOpCallAlias!(__lambda2)
{
	enum bool needOpCallAlias = false;

}
__lambda2!dchar
{
	function (dchar a) pure nothrow @nogc @safe => cast(uint)a <= 127u
}
not!(__lambda2)
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
find!(not, dchar[])
{
	pure nothrow @nogc @safe dchar[] find(dchar[] haystack)
	{
		alias R = dchar[];
		alias predFun = auto not(T...)(auto ref T args)
		{
			static if (is(typeof(!pred(args))))
			{
				return !pred(args);
			}
			else
			{
				static if (T.length == 1)
				{
					return !unaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static if (T.length == 2)
					{
						return !binaryFun!pred
						{
						}
						(args);
					}
					else
					{
						static assert(0);
					}
				}
			}
		}
		;
		for (; !empty(haystack); popFront(haystack))
		{
			{
				if (not(front(haystack)))
					break;
			}
		}
		return haystack;
	}

}
unaryFun!(not, "a")
{
	auto not(T...)(auto ref T args)
	{
		static if (is(typeof(!pred(args))))
		{
			return !pred(args);
		}
		else
		{
			static if (T.length == 1)
			{
				return !unaryFun!pred
				{
				}
				(args);
			}
			else
			{
				static if (T.length == 2)
				{
					return !binaryFun!pred
					{
					}
					(args);
				}
				else
				{
					static assert(0);
				}
			}
		}
	}

}
needOpCallAlias!(not)
{
	enum bool needOpCallAlias = false;

}
not!()
{
	auto pure nothrow @nogc @safe void not()
	{
	}

}
isNarrowString!(dchar[])
{
	enum bool isNarrowString = false;

}
not!dchar
{
	auto pure nothrow @nogc @safe bool not(ref dchar _param_0)
	{
		return !__lambda2(_param_0);
	}

}
empty!(dchar[])
{
	pure nothrow @nogc @property @safe bool empty(scope dchar[] a)
	{
		return !a.length;
	}

}
graphemeStride!dchar
{
	pure nothrow @nogc @safe ulong graphemeStride(scope const(dchar[]) input, ulong index)
	{
		const(dchar)[] src = input[index..__dollar];
		ulong n = src.length;
		genericDecodeGrapheme(src);
		return n - src.length;
	}

}
genericDecodeGrapheme!(const(dchar)[])
{
	pure nothrow @nogc @safe void genericDecodeGrapheme(ref const(dchar)[] range)
	{
		import std.internal.unicode_tables : isHangL, isHangT, isHangV;
		enum GraphemeState : int
		{
			GraphemeState Start = cast(GraphemeState)0,
			GraphemeState CR = cast(GraphemeState)1,
			GraphemeState RI = cast(GraphemeState)2,
			GraphemeState L = cast(GraphemeState)3,
			GraphemeState V = cast(GraphemeState)4,
			GraphemeState LVT = cast(GraphemeState)5,
		}
		GraphemeState state = GraphemeState.Start;
		enum string eat = "\n            static if (getValue)\n                grapheme ~= ch;\n            range.popFront();\n        ";
		dchar ch = '\uffff';
		assert(!empty(range), "Attempting to decode grapheme from an empty const(dchar)[]");
		for (; !empty(range);)
		{
			{
				ch = front(range);
				final switch (state)
				{
					with (GraphemeState)
					{
						case GraphemeState.Start:
						{
							popFront(range);
							if (cast(uint)ch == 13u)
								state = GraphemeState.CR;
							else if (isRegionalIndicator(ch))
								state = GraphemeState.RI;
							else if (isHangL(ch))
								state = GraphemeState.L;
							else if (((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop573 = hangLV();) , __dop573.opIndex(ch)) || isHangV(ch))
								state = GraphemeState.V;
							else if ((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop574 = hangLVT();) , __dop574.opIndex(ch))
								state = GraphemeState.LVT;
							else if (isHangT(ch))
								state = GraphemeState.LVT;
							else
							{
								switch (cast(uint)ch)
								{
									case 0u:
									;
									case 1u:
									;
									case 2u:
									;
									case 3u:
									;
									case 4u:
									;
									case 5u:
									;
									case 6u:
									;
									case 7u:
									;
									case 8u:
									{
									}
									case 14u:
									;
									case 15u:
									;
									case 16u:
									;
									case 17u:
									;
									case 18u:
									;
									case 19u:
									;
									case 20u:
									;
									case 21u:
									;
									case 22u:
									;
									case 23u:
									;
									case 24u:
									;
									case 25u:
									;
									case 26u:
									;
									case 27u:
									;
									case 28u:
									;
									case 29u:
									;
									case 30u:
									;
									case 31u:
									{
									}
									case 127u:
									;
									case 128u:
									;
									case 129u:
									;
									case 130u:
									;
									case 131u:
									;
									case 132u:
									{
									}
									case 134u:
									;
									case 135u:
									;
									case 136u:
									;
									case 137u:
									;
									case 138u:
									;
									case 139u:
									;
									case 140u:
									;
									case 141u:
									;
									case 142u:
									;
									case 143u:
									;
									case 144u:
									;
									case 145u:
									;
									case 146u:
									;
									case 147u:
									;
									case 148u:
									;
									case 149u:
									;
									case 150u:
									;
									case 151u:
									;
									case 152u:
									;
									case 153u:
									;
									case 154u:
									;
									case 155u:
									;
									case 156u:
									;
									case 157u:
									;
									case 158u:
									;
									case 159u:
									{
									}
									case 9u:
									;
									case 10u:
									;
									case 11u:
									;
									case 12u:
									{
									}
									case 133u:
									{
									}
									goto L_End;
									default:
									{
										goto L_End_Extend;
									}
								}
							}
							break;
						}
						case GraphemeState.CR:
						{
							if (cast(uint)ch == 10u)
								popFront(range);
							goto L_End_Extend;
						}
						case GraphemeState.RI:
						{
							if (isRegionalIndicator(ch))
								popFront(range);
							goto L_End_Extend;
						}
						case GraphemeState.L:
						{
							if (isHangL(ch))
								popFront(range);
							else if (isHangV(ch) || ((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop575 = hangLV();) , __dop575.opIndex(ch)))
							{
								state = GraphemeState.V;
								popFront(range);
							}
							else if ((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop576 = hangLVT();) , __dop576.opIndex(ch))
							{
								state = GraphemeState.LVT;
								popFront(range);
							}
							else
								goto L_End_Extend;
							break;
						}
						case GraphemeState.V:
						{
							if (isHangV(ch))
								popFront(range);
							else if (isHangT(ch))
							{
								state = GraphemeState.LVT;
								popFront(range);
							}
							else
								goto L_End_Extend;
							break;
						}
						case GraphemeState.LVT:
						{
							if (isHangT(ch))
							{
								popFront(range);
							}
							else
								goto L_End_Extend;
							break;
						}
					}
					default:
					SwitchErrorStatement::toCBuffer()
				}
			}
		}
		L_End_Extend:
		for (; !empty(range);)
		{
			{
				ch = front(range);
				if (!((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop577 = graphemeExtendTrie();) , __dop577.opIndex(ch)) && !((immutable immutable(Trie!(BitPacked!(bool, 1LU), dchar, 1114112LU, sliceBits!(13LU, 21LU), sliceBits!(8LU, 13LU), sliceBits!(0LU, 8LU))) __dop578 = mcTrie();) , __dop578.opIndex(ch)))
					break;
				popFront(range);
			}
		}
		L_End:
	}

}
empty!(const(dchar)[])
{
	pure nothrow @nogc @property @safe bool empty(ref scope const(dchar)[] a)
	{
		return !a.length;
	}

}
put!(Appender!string, dchar[])
{
	pure @safe void put(ref Appender!string r, dchar[] e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, dchar[])
{
	pure @safe void doPut(ref Appender!string r, ref dchar[] e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
canPutItem!(dchar[])
{
	enum bool canPutItem = false;

}
Unqual!(dchar[], dchar[])
{
	alias Unqual = dchar[];

}
isImplicitlyConvertible!(dchar[], char)
{
	enum bool isImplicitlyConvertible = false;

}
isSomeChar!(dchar[])
{
	enum bool isSomeChar = false;

}
canPutConstRange!(dchar[])
{
	enum bool canPutConstRange = false;

}
canPutRange!(dchar[])
{
	enum bool canPutRange = true;

}
put!(dchar[])
{
	pure @safe void put(dchar[] items)
	{
		import std.utf : decodeFront;
		for (; !empty(items);)
		{
			{
				dchar c = decodeFront(items);
				this.put(c);
			}
		}
	}

}
ElementType!(dchar[])
{
	alias ElementType = dchar;

}
decodeFront!(Flag.no, dchar[])
{
	pure @safe dchar decodeFront(ref dchar[] str)
	{
		ulong numCodeUnits = 0LU;
		return decodeFront(str, numCodeUnits);
	}

}
decodeFront!(Flag.no, dchar[])
{
	pure @trusted dchar decodeFront(ref scope dchar[] str, out ulong numCodeUnits)
	in
	{
		assert(!empty(str));
	}
	out(result)
	{
		assert(isValidDchar(result));
	}
	do
	{
		numCodeUnits = 0LU;
		{
			{
				assert(!empty(str));
			}
		}
		if (cast(uint)str[0] < 55296u)
		{
			numCodeUnits = 1LU;
			immutable immutable(dchar) retval = str[0];
			str = str[1..__dollar];
			__result = retval;
			goto __returnLabel;
		}
		else
		{
			immutable immutable(dchar) retval = decodeImpl(cast(const(dchar)[])str, numCodeUnits);
			str = str[numCodeUnits..__dollar];
			__result = retval;
			goto __returnLabel;
		}
		__returnLabel:
		{
			const ref const(dchar) result = __result;
			{
				assert(isValidDchar(result));
			}
		}
		return __result;
	}

}
ElementEncodingType!(dchar[])
{
	alias ElementEncodingType = dchar;

}
StringTypeOf!(dchar[])
{
	alias StringTypeOf = dchar[];

}
codeUnitLimit!(dchar[])
{
	enum dchar codeUnitLimit = '\ud800';

}
isInputRange!(const(dchar)[])
{
	enum bool isInputRange = true;

}
isCallable!(function (const(dchar)[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (const(dchar)[] r) pure nothrow @nogc @safe => empty(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (const(dchar)[] r) pure nothrow @nogc @safe => empty(r))
{
	alias ReturnType = bool;

}
FunctionTypeOf!(function (const(dchar)[] r) pure nothrow @nogc @safe => empty(r))
{
	alias pure nothrow @nogc @safe bool FunctionTypeOf(const(dchar)[] r);

}
isCallable!(function (const(dchar)[] r) pure nothrow @nogc @safe => front(r))
{
	enum bool isCallable = true;

}
isSomeFunction!(function (const(dchar)[] r) pure nothrow @nogc @safe => front(r))
{
	enum bool isSomeFunction = true;

}
ReturnType!(function (const(dchar)[] r) pure nothrow @nogc @safe => front(r))
{
	alias ReturnType = const(dchar);

}
FunctionTypeOf!(function (const(dchar)[] r) pure nothrow @nogc @safe => front(r))
{
	alias pure nothrow @nogc @safe const(dchar) FunctionTypeOf(const(dchar)[] r);

}
ElementEncodingType!(const(dchar)[])
{
	alias ElementEncodingType = const(dchar);

}
StringTypeOf!(const(dchar)[])
{
	alias StringTypeOf = const(dchar)[];

}
decodeImpl!(true, Flag.no, const(dchar)[])
{
	pure @system dchar decodeImpl(const(dchar)[] str, ref ulong index)
	{
		const(dchar)* pstr = cast(const(dchar)*)str;
		dchar dc = pstr[index];
		if (!isValidDchar(dc))
		{
			throw (new UTFException("Invalid UTF-32 value", "/usr/include/dmd/phobos/std/utf.d", 1869LU, null)).setSequence([cast(uint)dc][]);
		}
		index += 1LU;
		return dc;
	}

}
IntegralTypeOf!uint
{
	alias IntegralTypeOf = uint;

}
hasToString!(uint, char)
{
	enum HasToStringResult hasToString = HasToStringResult.none;

}
isPointer!uint
{
	enum bool isPointer = false;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
RTInfo!(S)
{
	enum immutable(void)* RTInfo = null;

}
isAggregateType!uint
{
	enum bool isAggregateType = false;

}
isSIMDVector!uint
{
	enum bool isSIMDVector = false;

}
isDelegate!uint
{
	enum bool isDelegate = false;

}
formatValueImpl!(Appender!string, uint, char)
{
	pure @safe void formatValueImpl(ref Appender!string w, const(uint) obj, ref scope const(FormatSpec!char) f)
	{
		alias U = uint;
		uint val = obj;
		if (cast(int)f.spec == 114)
		{
			const(char)[] raw = (*function (ref uint val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..4])(val);
			import std.range.primitives : put;
			if (needToSwapEndianess(f))
			{
				scope const(char)[] __r610 = raw[];
				ulong __key611 = __r610.length;
				for (; __key611--;)
				{
					const const(char) c = __r610[__key611];
					put(w, c);
				}
			}
			else
			{
				scope const(char)[] __r612 = raw[];
				ulong __key613 = 0LU;
				for (; __key613 < __r612.length; __key613 += 1LU)
				{
					const const(char) c = __r612[__key613];
					put(w, c);
				}
			}
			return ;
		}
		const const(bool) negative = false;
		ulong arg = cast(ulong)val;
		arg &= 4294967295LU;
		formatValueImplUlong(w, arg, false, f);
	}

}
__lambda5!uint
{
	function (ref uint val) pure nothrow @nogc @trusted => (cast(const(char*))&val)[0..4]
}
formatElement!(Appender!string, dchar, char)
{
	pure @safe void formatElement(ref Appender!string w, dchar val, ref scope const(FormatSpec!char) f)
	{
		import std.range.primitives : put;
		import std.format.write : formatValue;
		if (cast(int)f.spec == 115)
		{
			put(w, '\'');
			formatChar(w, val, '\'');
			put(w, '\'');
		}
		else
			formatValue(w, val, f);
	}

}
formatChar!(Appender!string)
{
	pure @safe void formatChar(ref Appender!string w, in dchar c, in char quote)
	{
		import std.format : formattedWrite;
		import std.range.primitives : put;
		import std.uni : isGraphical;
		string fmt = null;
		if (isGraphical(c))
		{
			if (cast(uint)c == cast(uint)cast(int)quote || cast(uint)c == 92u)
				put(w, '\\');
			put(w, c);
			return ;
		}
		else if (cast(uint)c <= 255u)
		{
			if (cast(uint)c < 32u)
			{
				{
					scope string __r615 = "\n\r\t\x07\b\f\x0b\0"[];
					ulong __key614 = 0LU;
					for (; __key614 < __r615.length; __key614 += 1LU)
					{
						immutable immutable(char) k = __r615[__key614];
						ulong i = __key614;
						if (cast(uint)c == cast(uint)cast(int)k)
						{
							put(w, '\\');
							put(w, "nrtabfv0"[i]);
							return ;
						}
					}
				}
			}
			fmt = "\\x%02X";
		}
		else if (cast(uint)c <= 65535u)
			fmt = "\\u%04X";
		else
			fmt = "\\U%08X";
		formattedWrite(w, fmt, cast(uint)c);
	}

}
put!(Appender!string, immutable(char))
{
	pure nothrow @safe void put(ref Appender!string r, immutable(char) e)
	{
		doPut(r, e);
	}

}
doPut!(Appender!string, immutable(char))
{
	pure nothrow @safe void doPut(ref Appender!string r, ref immutable(char) e)
	{
		enum bool usingPut = true;
		r.put(e);
	}

}
canPutItem!(immutable(char))
{
	enum bool canPutItem = true;

}
canPutConstRange!(immutable(char))
{
	enum bool canPutConstRange = false;

}
isInputRange!(immutable(char))
{
	enum bool isInputRange = false;

}
canPutRange!(immutable(char))
{
	enum bool canPutRange = false;

}
put!(immutable(char))
{
	pure nothrow @safe void put(immutable(char) item)
	{
		import core.lifetime : emplace;
		this.ensureAddable(1LU);
		immutable immutable(ulong) len = (*this._data).arr.length;
		char[] bigData = delegate () pure nothrow @nogc @trusted => (cast(char*)(*this._data).arr)[0..len + 1LU]();
		char* itemUnqual = delegate () pure nothrow @nogc @trusted => & item();
		emplace(&bigData[len], *itemUnqual);
		(*this._data).arr = bigData;
	}

}
formattedWrite!(Appender!string, char, uint)
{
	pure @safe uint formattedWrite(ref Appender!string w, scope const(char[]) fmt, uint _param_2)
	{
		import std.conv : text;
		import std.format : enforceFmt, FormatException;
		import std.traits : isSomeChar;
		FormatSpec!char spec = spec = FormatSpec , spec.this(fmt);
		uint currentArg = 0u;
		for (; spec.writeUpToNextSpec(w);)
		{
			{
				if (cast(ulong)currentArg == 1LU && !spec.indexStart)
				{
					enforce(fmt.length == 0LU, delegate const(char)[]() pure nothrow @nogc @safe => text("Orphan format specifier: %", spec.spec), "/usr/include/dmd/phobos/std/format/write.d", 542LU);
					break;
				}
				if (spec.width == 2147483647)
				{
					int width = getNthInt(currentArg, _param_2);
					if (width < 0)
					{
						spec.flDash(true);
						width = -width;
					}
					spec.width = width;
					currentArg += 1u;
				}
				else if (spec.width < 0)
				{
					uint index = cast(uint)-spec.width;
					assert(index > 0u, "The index must be greater than zero");
					int width = getNthInt(index - 1u, _param_2);
					if (currentArg < index)
						currentArg = index;
					if (width < 0)
					{
						spec.flDash(true);
						width = -width;
					}
					spec.width = width;
				}
				if (spec.precision == 2147483647)
				{
					int precision = getNthInt(currentArg, _param_2);
					if (precision >= 0)
						spec.precision = precision;
					else
						spec.precision = 2147483646;
					currentArg += 1u;
				}
				else if (spec.precision < 0)
				{
					uint index = cast(uint)-spec.precision;
					assert(index > 0u, "The precision must be greater than zero");
					int precision = getNthInt(index - 1u, _param_2);
					if (currentArg < index)
						currentArg = index;
					if (precision >= 0)
						spec.precision = precision;
					else
						spec.precision = 2147483646;
				}
				if (spec.separators == 2147483647)
				{
					int separators = getNthInt(currentArg, _param_2);
					spec.separators = separators;
					currentArg += 1u;
				}
				if (spec.dynamicSeparatorChar)
				{
					dchar separatorChar = getNth(currentArg, _param_2);
					spec.separatorChar = separatorChar;
					spec.dynamicSeparatorChar = false;
					currentArg += 1u;
				}
				if (cast(ulong)currentArg == 1LU && !spec.indexStart)
				{
					enforce(fmt.length == 0LU, delegate const(char)[]() pure nothrow @nogc @safe => text("Orphan format specifier: %", spec.spec), "/usr/include/dmd/phobos/std/format/write.d", 612LU);
					break;
				}
				ulong index = cast(ulong)currentArg;
				if (cast(int)spec.indexStart != 0)
					index = cast(ulong)(cast(int)spec.indexStart - 1);
				else
					currentArg += 1u;
				SWITCH:
				switch (index)
				{
					/*unrolled*/ {
						{
							enum ulong i = 0LU;
							alias Tunused = uint;
							case 0LU:
							{
								formatValue(w, _param_2, spec);
								if (currentArg < cast(uint)cast(int)spec.indexEnd)
									currentArg = cast(uint)spec.indexEnd;
								if (1LU < cast(ulong)cast(int)spec.indexEnd)
								{
									goto default;
								}
								else
									break SWITCH;
							}
						}
					}
					default:
					{
						throw new FormatException(text("Positional specifier %", spec.indexStart, '$', spec.spec, " index exceeds ", 1LU), "/usr/include/dmd/phobos/std/format/write.d", 651LU, null);
					}
				}
			}
		}
		return currentArg;
	}

}
getNthInt!("integer width", uint)
{
	pure @safe int getNthInt(uint index, uint _param_1)
	{
		return getNth(index, _param_1);
	}

}
getNth!("integer width", isIntegral, int, uint)
{
	pure @safe int getNth(uint index, uint _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = uint;
					case 0u:
					{
						return to(_param_1);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "integer width", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
to!uint
{
	pure @safe int to(uint _param_0)
	{
		return toImpl(_param_0);
	}

}
isImplicitlyConvertible!(uint, int)
{
	enum bool isImplicitlyConvertible = true;

}
isEnumStrToStr!(uint, int)
{
	enum bool isEnumStrToStr = false;

}
isNullToStr!(uint, int)
{
	enum bool isNullToStr = false;

}
toImpl!(int, uint)
{
	pure @safe int toImpl(uint value)
	{
		enum isSignedInt(T) = isIntegral!T
		{
		}
		 && isSigned!T
		{
		}
		;
		alias isUnsignedInt = template isUnsigned(T)
		{
			static if (!__traits(isUnsigned, T))
			{
				enum isUnsigned = false;
			}
			else
			{
				static if (is(T U == enum))
				{
					enum isUnsigned = isUnsigned!U
					{
					}
					;
				}
				else
				{
					enum isUnsigned = __traits(isZeroInit, T) && !is(immutable(T) == immutable(bool)) && !is(T == __vector);
				}
			}
		}
		;
		import std.exception : enforce;
		enforce(value <= 2147483647u, delegate Throwable() pure nothrow @safe => new ConvOverflowException("Conversion positive overflow", "/usr/include/dmd/phobos/std/conv.d", 559LU));
		return cast(int)value;
	}

}
isSignedInt!int
{
	enum bool isSignedInt = true;

}
getNthInt!("integer precision", uint)
{
	pure @safe int getNthInt(uint index, uint _param_1)
	{
		return getNth(index, _param_1);
	}

}
getNth!("integer precision", isIntegral, int, uint)
{
	pure @safe int getNth(uint index, uint _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = uint;
					case 0u:
					{
						return to(_param_1);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "integer precision", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
getNthInt!("separator digit width", uint)
{
	pure @safe int getNthInt(uint index, uint _param_1)
	{
		return getNth(index, _param_1);
	}

}
getNth!("separator digit width", isIntegral, int, uint)
{
	pure @safe int getNth(uint index, uint _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = uint;
					case 0u:
					{
						return to(_param_1);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "separator digit width", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
getNth!("separator character", isSomeChar, dchar, uint)
{
	pure @safe dchar getNth(uint index, uint _param_1)
	{
		import std.conv : text, to;
		import std.format : FormatException;
		switch (index)
		{
			/*unrolled*/ {
				{
					enum ulong n = 0LU;
					alias _ = uint;
					case 0u:
					{
						throw new FormatException(text("separator character", " expected, not ", "uint", " for argument #", index + 1u), "/usr/include/dmd/phobos/std/format/internal/write.d", 3424LU, null);
					}
				}
			}
			default:
			{
				throw new FormatException(text("Missing ", "separator character", " argument"), "/usr/include/dmd/phobos/std/format/internal/write.d", 3430LU, null);
			}
		}
	}

}
formatValue!(Appender!string, uint, char)
{
	pure @safe void formatValue(ref Appender!string w, ref uint val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
formatValue!(Appender!string, dchar, char)
{
	pure @safe void formatValue(ref Appender!string w, ref dchar val, ref scope const(FormatSpec!char) f)
	{
		import std.format : enforceFmt;
		enforce(f.width != 2147483647 && (f.precision != 2147483647) && (f.separators != 2147483647) && !f.dynamicSeparatorChar, delegate const(char)[]() pure nothrow @nogc @safe => "Dynamic argument not allowed for `formatValue`", "/usr/include/dmd/phobos/std/format/write.d", 1235LU);
		formatValueImpl(w, val, f);
	}

}
RTInfo!(FormatSpec!char)
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([72LU, 336LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [72LU, 336LU];

}
static __gshared TypeInfo_Const _D11TypeInfo_xi6__initZ;
static __gshared TypeInfo_Const _D11TypeInfo_xw6__initZ;
static __gshared TypeInfo_Const _D11TypeInfo_xa6__initZ;
static __gshared TypeInfo_Const _D11TypeInfo_xh6__initZ;
static __gshared TypeInfo_Const _D12TypeInfo_xAa6__initZ;
RTInfo!(Data)
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
RTInfoImpl!([32LU, 4LU])
{
	immutable immutable(ulong[2]) RTInfoImpl = [32LU, 4LU];

}
RTInfo!(Appender!string)
{
	enum immutable(ulong)* RTInfo = & RTInfoImpl;

}
TraceHook!("char[]", "_d_arraysetlengthT")
{
	const const(char[]) TraceHook = "\n        import core.internal.array.utils : gcStatsPure, accumulatePure;\n\n        pragma(inline, false);\n        string name = `char[]`;\n\n        // FIXME: use rt.tracegc.accumulator when it is accessable in the future.\n        version (tracegc)\n    {\n\n            import core.stdc.stdio;\n\n            printf(\"%sTrace file = '%.*s' line = %d function = '%.*s' type = %.*s\\n\",\n            \"_d_arraysetlengthT\".ptr,\n                file.length, file.ptr,\n                line,\n                funcname.length, funcname.ptr,\n                name.length, name.ptr\n            );\n        }\n\n        ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;\n\n        scope(exit)\n        {\n            ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;\n            if (size > 0)\n                if (!accumulatePure(file, line, funcname, name, size)) {\n                    // This 'if' and 'assert' is needed to force the compiler to not remove the call to\n                    // `accumulatePure`. It really want to do that while optimizing as the function is\n                    // `pure` and it does not influence the result of this hook.\n\n                    // `accumulatePure` returns the value of `size`, which can never be zero due to the\n                    // previous 'if'. So this assert will never be triggered.\n                    assert(0);\n                }\n        }\n    ";

}
TraceHook!("char[]", "_d_arrayappendcTX")
{
	const const(char[]) TraceHook = "\n        import core.internal.array.utils : gcStatsPure, accumulatePure;\n\n        pragma(inline, false);\n        string name = `char[]`;\n\n        // FIXME: use rt.tracegc.accumulator when it is accessable in the future.\n        version (tracegc)\n    {\n\n            import core.stdc.stdio;\n\n            printf(\"%sTrace file = '%.*s' line = %d function = '%.*s' type = %.*s\\n\",\n            \"_d_arrayappendcTX\".ptr,\n                file.length, file.ptr,\n                line,\n                funcname.length, funcname.ptr,\n                name.length, name.ptr\n            );\n        }\n\n        ulong currentlyAllocated = gcStatsPure().allocatedInCurrentThread;\n\n        scope(exit)\n        {\n            ulong size = gcStatsPure().allocatedInCurrentThread - currentlyAllocated;\n            if (size > 0)\n                if (!accumulatePure(file, line, funcname, name, size)) {\n                    // This 'if' and 'assert' is needed to force the compiler to not remove the call to\n                    // `accumulatePure`. It really want to do that while optimizing as the function is\n                    // `pure` and it does not influence the result of this hook.\n\n                    // `accumulatePure` returns the value of `size`, which can never be zero due to the\n                    // previous 'if'. So this assert will never be triggered.\n                    assert(0);\n                }\n        }\n    ";

}
hashOf!uint
{
	pure nothrow @nogc @trusted ulong hashOf(const(uint) val)
	{
		return cast(ulong)val;
	}

}
hashOf!ulong
{
	pure nothrow @nogc @trusted ulong hashOf(const(ulong) val)
	{
		return val;
	}

}
RTInfo!(Tuple!(uint, ulong))
{
	enum immutable(void)* RTInfo = null;

}
areCompatibleTuples!(const(Tuple!(uint, ulong)), const(Tuple!(uint, ulong)), "==")
{
	enum bool areCompatibleTuples = true;

}
OriginalType!(const(Tuple!(uint, ulong)))
{
	alias OriginalType = const(Tuple!(uint, ulong));

}
_OriginalType!(const(Tuple!(uint, ulong)))
{
	alias OriginalType = const(Tuple!(uint, ulong));

}
ModifyTypePreservingTQ!(Impl, const(Tuple!(uint, ulong)))
{
	alias ModifyTypePreservingTQ = const const(Tuple!(uint, ulong));

}
Modifier!(Tuple!(uint, ulong))
{
	alias Impl = Tuple!(uint, ulong);

}
isTuple!(const(Tuple!(uint, ulong)))
{
	enum bool isTuple = true;

}
f!(uint, ulong)
{
	pure nothrow @nogc @safe void f(Tuple!(uint, ulong) tup)
	{
	}

}
opEquals!(const(Tuple!(uint, ulong)))
{
	const pure nothrow @nogc @safe bool opEquals(const(Tuple!(uint, ulong)) rhs)
	{
		return this.__expand_field_0 == rhs.__expand_field_0 && (this.__expand_field_1 == rhs.__expand_field_1);
	}

}
areCompatibleTuples!(const(Tuple!(uint, ulong)), const(Tuple!(uint, ulong)), "<")
{
	enum bool areCompatibleTuples = true;

}
opCmp!(const(Tuple!(uint, ulong)))
{
	auto const pure nothrow @nogc @safe int opCmp(const(Tuple!(uint, ulong)) rhs)
	{
		if (this.__expand_field_0 != rhs.__expand_field_0)
		{
			import std.math.traits : isNaN;
			return this.__expand_field_0 < rhs.__expand_field_0 ? -1 : 1;
		}
		if (this.__expand_field_1 != rhs.__expand_field_1)
		{
			import std.math.traits : isNaN;
			return this.__expand_field_1 < rhs.__expand_field_1 ? -1 : 1;
		}
		return 0;
	}

}
isFloatingPoint!(const(ulong))
{
	enum bool isFloatingPoint = false;

}
RTInfo!(Tuple!(uint, "data", ulong, "count"))
{
	enum immutable(void)* RTInfo = null;

}
areCompatibleTuples!(const(Tuple!(uint, "data", ulong, "count")), const(Tuple!(uint, "data", ulong, "count")), "==")
{
	enum bool areCompatibleTuples = true;

}
OriginalType!(const(Tuple!(uint, "data", ulong, "count")))
{
	alias OriginalType = const(Tuple!(uint, "data", ulong, "count"));

}
_OriginalType!(const(Tuple!(uint, "data", ulong, "count")))
{
	alias OriginalType = const(Tuple!(uint, "data", ulong, "count"));

}
ModifyTypePreservingTQ!(Impl, const(Tuple!(uint, "data", ulong, "count")))
{
	alias ModifyTypePreservingTQ = const const(Tuple!(uint, "data", ulong, "count"));

}
Modifier!(Tuple!(uint, "data", ulong, "count"))
{
	alias Impl = Tuple!(uint, "data", ulong, "count");

}
isTuple!(const(Tuple!(uint, "data", ulong, "count")))
{
	enum bool isTuple = true;

}
f!(uint, "data", ulong, "count")
{
	pure nothrow @nogc @safe void f(Tuple!(uint, "data", ulong, "count") tup)
	{
	}

}
opEquals!(const(Tuple!(uint, "data", ulong, "count")))
{
	const pure nothrow @nogc @safe bool opEquals(const(Tuple!(uint, "data", ulong, "count")) rhs)
	{
		return this.__expand_field_0 == rhs.__expand_field_0 && (this.__expand_field_1 == rhs.__expand_field_1);
	}

}
areCompatibleTuples!(const(Tuple!(uint, "data", ulong, "count")), const(Tuple!(uint, "data", ulong, "count")), "<")
{
	enum bool areCompatibleTuples = true;

}
opCmp!(const(Tuple!(uint, "data", ulong, "count")))
{
	auto const pure nothrow @nogc @safe int opCmp(const(Tuple!(uint, "data", ulong, "count")) rhs)
	{
		if (this.__expand_field_0 != rhs.__expand_field_0)
		{
			import std.math.traits : isNaN;
			return this.__expand_field_0 < rhs.__expand_field_0 ? -1 : 1;
		}
		if (this.__expand_field_1 != rhs.__expand_field_1)
		{
			import std.math.traits : isNaN;
			return this.__expand_field_1 < rhs.__expand_field_1 ? -1 : 1;
		}
		return 0;
	}

}
__equals!(uint, uint)
{
	pure nothrow @nogc @trusted bool __equals(scope const(uint[]) lhs, scope const(uint[]) rhs)
	{
		const const(ulong) length = lhs.length;
		if (__ctfe)
			return length == rhs.length && isEqual(cast(const(uint)*)lhs, cast(const(uint)*)rhs, length);
		else
		{
			import core.stdc.string : memcmp;
			return length == rhs.length && (!length || 0 == memcmp(cast(const(void*))cast(const(uint)*)lhs, cast(const(void*))cast(const(uint)*)rhs, length * 4LU));
		}
	}

}
isEqual!(uint, uint)
{
	pure nothrow @nogc @system bool isEqual(scope const(uint*) t1, scope const(uint*) t2, ulong length)
	{
		{
			ulong __key660 = 0LU;
			ulong __limit661 = length;
			for (; __key660 < __limit661; __key660 += 1LU)
			{
				const const(ulong) i = __key660;
				if (t1[i] != t2[i])
					return false;
			}
		}
		return true;
	}

}
isBlitAssignable!(Tuple!(uint, ulong))
{
	enum bool isBlitAssignable = true;

}
isStaticArray!(Tuple!(uint, ulong))
{
	enum bool isStaticArray = false;

}
isMutable!(Tuple!(uint, ulong))
{
	enum bool isMutable = true;

}
FieldTypeTuple!(Tuple!(uint, ulong))
{
	alias Fields = (uint, ulong);

}
_Fields!(Tuple!(uint, ulong))
{
	alias Fields = (uint, ulong);

}
isBlitAssignable!uint
{
	enum bool isBlitAssignable = true;

}
isMutable!uint
{
	enum bool isMutable = true;

}
isBlitAssignable!ulong
{
	enum bool isBlitAssignable = true;

}
isMutable!ulong
{
	enum bool isMutable = true;

}
swap!(Tuple!(uint, ulong))
{
	pure nothrow @nogc @trusted void swap(ref Tuple!(uint, ulong) lhs, ref Tuple!(uint, ulong) rhs)
	{
		import std.traits : hasAliasing, hasElaborateAssign, isAssignable, isStaticArray;
		if (&lhs !is &rhs)
		{
			ubyte[16] t = void;
			ubyte[] a = (cast(ubyte*)&lhs)[0..16];
			ubyte[] b = (cast(ubyte*)&rhs)[0..16];
			t[] = a[];
			a[] = b[];
			b[] = t[];
		}
	}

}
hasAliasing!(Tuple!(uint, ulong))
{
	enum bool hasAliasing = false;

}
anySatisfy!(hasAliasingImpl, Tuple!(uint, ulong))
{
	enum bool anySatisfy = false;

}
F!(Tuple!(uint, ulong))
{
	enum bool hasAliasingImpl = false;

}
hasRawAliasing!(Tuple!(uint, ulong))
{
	enum bool hasRawAliasing = false;

}
RepresentationTypeTuple!(Tuple!(uint, ulong))
{
	alias RepresentationTypeTuple = (uint, ulong);

}
staticMapMeta!(RepresentationTypeTupleImpl, uint, ulong)
{
	staticMap
}
fun!uint
{
	alias RepresentationTypeTupleImpl = (uint);

}
fun!ulong
{
	alias RepresentationTypeTupleImpl = (ulong);

}
anySatisfy!(hasRawAliasingImpl, uint, ulong)
{
	enum bool anySatisfy = false;

}
F!uint
{
	enum bool hasRawAliasingImpl = false;

}
F!ulong
{
	enum bool hasRawAliasingImpl = false;

}
hasObjects!(Tuple!(uint, ulong))
{
	enum bool hasObjects = false;

}
anySatisfy!(hasObjects, uint, ulong)
{
	enum bool anySatisfy = false;

}
F!uint
{
	enum bool hasObjects = false;

}
F!ulong
{
	enum bool hasObjects = false;

}
anySatisfy!(isAliasingDelegate, Tuple!(uint, ulong), uint, ulong)
{
	enum bool anySatisfy = false;

}
F!(Tuple!(uint, ulong))
{
	enum bool isAliasingDelegate = false;

}
isDelegate!(Tuple!(uint, ulong))
{
	enum bool isDelegate = false;

}
F!uint
{
	enum bool isAliasingDelegate = false;

}
F!ulong
{
	enum bool isAliasingDelegate = false;

}
hasElaborateAssign!(Tuple!(uint, ulong))
{
	enum bool hasElaborateAssign = true;

}
rvalueOf!(Tuple!(uint, ulong))
{
	@property Tuple!(uint, ulong) rvalueOf(inout(__InoutWorkaroundStruct) = __InoutWorkaroundStruct());

}
